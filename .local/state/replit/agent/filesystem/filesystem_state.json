{"file_contents":{"services/ai_assistant.py":{"content":"import pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Any, Optional\nfrom database.database import get_session\nfrom database.models import Stock, Order, Account, User\nfrom services.technical_indicators import TechnicalIndicators\nimport random\n\nclass TradingAssistant:\n    \"\"\"AI-powered trading assistant that provides contextual advice\"\"\"\n    \n    def __init__(self):\n        self.session = get_session()\n        self.indicators = TechnicalIndicators()\n        \n    def analyze_market_sentiment(self) -> str:\n        \"\"\"Analyze current market sentiment based on available data\"\"\"\n        try:\n            stocks = self.session.query(Stock).filter(Stock.priority > 0).all()\n            if not stocks:\n                return \"neutral\"\n                \n            positive_moves = 0\n            total_stocks = len(stocks)\n            \n            for stock in stocks:\n                if stock.change_percent is not None and stock.change_percent > 0:\n                    positive_moves += 1\n                    \n            sentiment_ratio = positive_moves / total_stocks if total_stocks > 0 else 0.5\n            \n            if sentiment_ratio > 0.6:\n                return \"bullish\"\n            elif sentiment_ratio < 0.4:\n                return \"bearish\"\n            else:\n                return \"neutral\"\n                \n        except Exception:\n            return \"neutral\"\n    \n    def get_portfolio_analysis(self, user_id: int) -> Dict[str, Any]:\n        \"\"\"Analyze user's portfolio and provide insights\"\"\"\n        try:\n            # Get user's orders/positions\n            orders = self.session.query(Order).filter(\n                Order.user_id == user_id,\n                Order.status == 'filled'\n            ).all()\n            \n            if not orders:\n                return {\n                    \"total_positions\": 0,\n                    \"portfolio_health\": \"No positions\",\n                    \"risk_level\": \"low\",\n                    \"suggestions\": [\"Start with paper trading to practice\", \"Consider diversified ETFs for beginners\"]\n                }\n            \n            # Calculate portfolio metrics\n            total_value = sum(order.quantity * (order.fill_price or 0) for order in orders)\n            position_count = len(set(order.symbol for order in orders))\n            \n            # Determine portfolio health\n            if position_count < 3:\n                portfolio_health = \"Under-diversified\"\n                risk_level = \"high\"\n            elif position_count > 10:\n                portfolio_health = \"Well-diversified\"\n                risk_level = \"moderate\"\n            else:\n                portfolio_health = \"Moderately diversified\"\n                risk_level = \"moderate\"\n            \n            return {\n                \"total_positions\": position_count,\n                \"portfolio_value\": total_value,\n                \"portfolio_health\": portfolio_health,\n                \"risk_level\": risk_level,\n                \"recent_trades\": len([o for o in orders if o.created_at is not None and \n                                    o.created_at > datetime.now() - timedelta(days=7)])\n            }\n            \n        except Exception:\n            return {\n                \"total_positions\": 0,\n                \"portfolio_health\": \"Unable to analyze\",\n                \"risk_level\": \"unknown\",\n                \"suggestions\": [\"Check your account connection\"]\n            }\n    \n    def get_stock_recommendation(self, symbol: str) -> Dict[str, Any]:\n        \"\"\"Get recommendation for a specific stock\"\"\"\n        try:\n            stock = self.session.query(Stock).filter(Stock.symbol == symbol).first()\n            if not stock:\n                return {\"recommendation\": \"unknown\", \"reason\": \"Stock not found in database\"}\n            \n            # Simple recommendation logic based on change percent\n            change = stock.change_percent if stock.change_percent is not None else 0\n            price = stock.last_price if stock.last_price is not None else 0\n            \n            if change > 3:\n                recommendation = \"strong_buy\"\n                reason = f\"{symbol} showing strong upward momentum (+{change:.1f}%)\"\n            elif change > 1:\n                recommendation = \"buy\"\n                reason = f\"{symbol} has positive momentum (+{change:.1f}%)\"\n            elif change < -3:\n                recommendation = \"strong_sell\"\n                reason = f\"{symbol} showing weakness ({change:.1f}%)\"\n            elif change < -1:\n                recommendation = \"sell\"\n                reason = f\"{symbol} declining ({change:.1f}%)\"\n            else:\n                recommendation = \"hold\"\n                reason = f\"{symbol} trading sideways ({change:.1f}%)\"\n            \n            return {\n                \"recommendation\": recommendation,\n                \"reason\": reason,\n                \"current_price\": price,\n                \"change_percent\": change,\n                \"sector\": stock.sector\n            }\n            \n        except Exception as e:\n            return {\"recommendation\": \"unknown\", \"reason\": f\"Analysis error: {str(e)}\"}\n    \n    def get_market_opportunities(self) -> List[Dict[str, Any]]:\n        \"\"\"Identify potential trading opportunities\"\"\"\n        try:\n            stocks = self.session.query(Stock).filter(\n                Stock.priority > 0,\n                Stock.last_price.isnot(None)\n            ).all()\n            \n            opportunities = []\n            \n            for stock in stocks[:5]:  # Top 5 opportunities\n                change = stock.change_percent if stock.change_percent is not None else 0\n                \n                # Look for momentum plays\n                if abs(change) > 2:\n                    opportunity_type = \"momentum\" if change > 0 else \"reversal\"\n                    confidence = min(90, 60 + abs(change) * 5)\n                    \n                    opportunities.append({\n                        \"symbol\": stock.symbol,\n                        \"name\": stock.name,\n                        \"type\": opportunity_type,\n                        \"reason\": f\"Strong {'upward' if change > 0 else 'downward'} movement ({change:.1f}%)\",\n                        \"confidence\": confidence,\n                        \"sector\": stock.sector,\n                        \"price\": stock.last_price\n                    })\n            \n            return opportunities\n            \n        except Exception:\n            return []\n    \n    def get_contextual_advice(self, user_id: int, context: str = \"\") -> Dict[str, Any]:\n        \"\"\"Provide contextual trading advice based on user situation\"\"\"\n        market_sentiment = self.analyze_market_sentiment()\n        portfolio = self.get_portfolio_analysis(user_id)\n        opportunities = self.get_market_opportunities()\n        \n        # Generate contextual advice\n        advice_parts = []\n        \n        # Market sentiment advice\n        if market_sentiment == \"bullish\":\n            advice_parts.append(\"Market sentiment is positive. Consider long positions in strong sectors.\")\n        elif market_sentiment == \"bearish\":\n            advice_parts.append(\"Market showing weakness. Consider defensive positions or wait for better entry points.\")\n        else:\n            advice_parts.append(\"Market is neutral. Focus on individual stock fundamentals.\")\n        \n        # Portfolio-specific advice\n        if portfolio[\"total_positions\"] == 0:\n            advice_parts.append(\"Start with small positions in blue-chip stocks to build experience.\")\n        elif portfolio[\"risk_level\"] == \"high\":\n            advice_parts.append(\"Consider diversifying across different sectors to reduce risk.\")\n        \n        # Opportunity-based advice\n        if opportunities:\n            top_opportunity = opportunities[0]\n            advice_parts.append(f\"Watch {top_opportunity['symbol']} - showing {top_opportunity['type']} potential.\")\n        \n        return {\n            \"market_sentiment\": market_sentiment,\n            \"portfolio_analysis\": portfolio,\n            \"opportunities\": opportunities,\n            \"advice\": \" \".join(advice_parts),\n            \"risk_assessment\": self._assess_current_risk(),\n            \"suggested_actions\": self._get_suggested_actions(market_sentiment, portfolio)\n        }\n    \n    def _assess_current_risk(self) -> str:\n        \"\"\"Assess current market risk level\"\"\"\n        # Simple risk assessment based on market volatility indicators\n        risk_factors = []\n        \n        try:\n            stocks = self.session.query(Stock).filter(Stock.priority > 0).all()\n            volatility_scores = []\n            \n            for stock in stocks:\n                if stock.change_percent is not None:\n                    volatility_scores.append(abs(stock.change_percent))\n            \n            if volatility_scores:\n                avg_volatility = np.mean(volatility_scores)\n                if avg_volatility > 3:\n                    return \"high\"\n                elif avg_volatility > 1.5:\n                    return \"moderate\"\n                else:\n                    return \"low\"\n                    \n        except Exception:\n            pass\n            \n        return \"moderate\"\n    \n    def _get_suggested_actions(self, sentiment: str, portfolio: Dict) -> List[str]:\n        \"\"\"Get specific action suggestions\"\"\"\n        actions = []\n        \n        if sentiment == \"bullish\":\n            actions.append(\"Consider increasing equity exposure\")\n            actions.append(\"Look for breakout patterns in tech stocks\")\n        elif sentiment == \"bearish\":\n            actions.append(\"Review stop-loss levels\")\n            actions.append(\"Consider defensive sectors like utilities\")\n        \n        if portfolio[\"total_positions\"] < 3:\n            actions.append(\"Diversify into at least 3-5 different stocks\")\n        \n        if portfolio[\"risk_level\"] == \"high\":\n            actions.append(\"Reduce position sizes to manage risk\")\n        \n        return actions\n    \n    def ask_question(self, question: str, user_id: int) -> str:\n        \"\"\"Process user questions and provide relevant answers\"\"\"\n        question_lower = question.lower()\n        \n        # Portfolio questions\n        if any(word in question_lower for word in [\"portfolio\", \"positions\", \"holdings\"]):\n            portfolio = self.get_portfolio_analysis(user_id)\n            return f\"Your portfolio has {portfolio['total_positions']} positions with {portfolio['portfolio_health']} diversification. Risk level: {portfolio['risk_level']}.\"\n        \n        # Market questions\n        elif any(word in question_lower for word in [\"market\", \"sentiment\", \"outlook\"]):\n            sentiment = self.analyze_market_sentiment()\n            return f\"Current market sentiment appears {sentiment}. {self._get_sentiment_explanation(sentiment)}\"\n        \n        # Stock-specific questions\n        elif \"should i buy\" in question_lower or \"should i sell\" in question_lower:\n            # Extract stock symbol if mentioned\n            words = question_lower.split()\n            stock_symbols = [\"aapl\", \"msft\", \"googl\", \"amzn\", \"tsla\", \"meta\", \"nvda\", \"jpm\", \"jnj\", \"v\"]\n            mentioned_symbol = None\n            \n            for word in words:\n                if word.upper() in [s.upper() for s in stock_symbols]:\n                    mentioned_symbol = word.upper()\n                    break\n            \n            if mentioned_symbol:\n                rec = self.get_stock_recommendation(mentioned_symbol)\n                return f\"For {mentioned_symbol}: {rec['recommendation'].replace('_', ' ').title()}. {rec['reason']}\"\n            else:\n                return \"Please specify which stock you're asking about. I can analyze AAPL, MSFT, GOOGL, AMZN, TSLA, META, NVDA, JPM, JNJ, or V.\"\n        \n        # Risk questions\n        elif any(word in question_lower for word in [\"risk\", \"safe\", \"dangerous\"]):\n            risk = self._assess_current_risk()\n            return f\"Current market risk level is {risk}. {self._get_risk_explanation(risk)}\"\n        \n        # General advice\n        else:\n            advice = self.get_contextual_advice(user_id)\n            return advice[\"advice\"]\n    \n    def _get_sentiment_explanation(self, sentiment: str) -> str:\n        \"\"\"Get explanation for market sentiment\"\"\"\n        explanations = {\n            \"bullish\": \"Most stocks are showing positive movement. Good time for growth strategies.\",\n            \"bearish\": \"Many stocks are declining. Consider defensive strategies or wait for better entries.\",\n            \"neutral\": \"Mixed signals in the market. Focus on individual stock analysis.\"\n        }\n        return explanations.get(sentiment, \"Market conditions are unclear.\")\n    \n    def _get_risk_explanation(self, risk: str) -> str:\n        \"\"\"Get explanation for risk level\"\"\"\n        explanations = {\n            \"high\": \"High volatility detected. Use smaller position sizes and tight stops.\",\n            \"moderate\": \"Normal market conditions. Standard risk management applies.\",\n            \"low\": \"Low volatility environment. Consider slightly larger positions if fundamentals support.\"\n        }\n        return explanations.get(risk, \"Monitor risk levels closely.\")","size_bytes":13240},"services/database_service.py":{"content":"\"\"\"\nDatabase service for managing priority calculations, archiving, and database operations\nas specified in the requirements.\n\"\"\"\n\nfrom datetime import datetime, timedelta\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import func, and_\nfrom database.models import (\n    Stock, EnvironmentVariable, PriorityCurrentPrice, PriorityArchivePrice,\n    StockPriceHistory, Order, TransactionLog\n)\nimport numpy as np\nfrom typing import List, Optional\n\nclass DatabaseService:\n    \"\"\"Service for managing database operations per specifications\"\"\"\n    \n    def __init__(self, session: Session):\n        self.session = session\n    \n    def get_environment_variable(self, key: str, default=None):\n        \"\"\"Get environment variable value with type conversion\"\"\"\n        env_var = self.session.query(EnvironmentVariable).filter(\n            EnvironmentVariable.key == key\n        ).first()\n        \n        if not env_var:\n            return default\n            \n        value = env_var.value\n        var_type = env_var.variable_type\n        \n        try:\n            if var_type == 'integer':\n                return int(value)\n            elif var_type == 'float':\n                return float(value)\n            elif var_type == 'boolean':\n                return value.lower() in ('true', '1', 'yes', 'on')\n            else:\n                return value\n        except (ValueError, AttributeError):\n            return default\n    \n    def update_stock_priorities(self):\n        \"\"\"\n        Update stock priorities based on specifications:\n        - Set priority=1 if closing price is > 1 std dev above/below 20-day MA\n        - And closing price is above/below MA by more than PRIORITY_PERCENTAGE_TARGET%\n        - Set priority=0 for all others (except sector ETFs which stay at 9)\n        \"\"\"\n        percentage_target = self.get_environment_variable('PRIORITY_PERCENTAGE_TARGET', 2.5)\n        \n        # Get all stocks except sector ETFs\n        stocks = self.session.query(Stock).filter(Stock.priority != 9).all()\n        \n        for stock in stocks:\n            # Get last 20 days of price history\n            history = self.session.query(StockPriceHistory).filter(\n                StockPriceHistory.stock_id == stock.id\n            ).order_by(StockPriceHistory.date.desc()).limit(20).all()\n            \n            if len(history) >= 20:\n                # Calculate 20-day moving average and standard deviation\n                closes = [float(h.close_price) for h in reversed(history)]\n                ma_20 = np.mean(closes)\n                std_20 = np.std(closes)\n                current_price = float(stock.last_price) if stock.last_price else closes[-1]\n                \n                # Check if price is > 1 std dev from MA\n                upper_threshold = ma_20 + std_20\n                lower_threshold = ma_20 - std_20\n                \n                # Check percentage change from MA\n                pct_change_from_ma = abs((current_price - ma_20) / ma_20) * 100\n                \n                # Set priority based on conditions\n                if ((current_price > upper_threshold or current_price < lower_threshold) and \n                    pct_change_from_ma > percentage_target):\n                    stock.priority = 1\n                else:\n                    stock.priority = 0\n            else:\n                # Not enough history, set to 0\n                stock.priority = 0\n        \n        self.session.commit()\n        return len([s for s in stocks if s.priority == 1])\n    \n    def update_priority_current_prices(self):\n        \"\"\"\n        Update priority current price table for stocks with priority > 0\n        Record every X seconds as per environment variables\n        \"\"\"\n        # Get all priority stocks\n        priority_stocks = self.session.query(Stock).filter(Stock.priority > 0).all()\n        current_time = datetime.now()\n        \n        updated_count = 0\n        for stock in priority_stocks:\n            # Get market open price for today\n            today_start = current_time.replace(hour=0, minute=0, second=0, microsecond=0)\n            \n            # Check if we have an open price for today\n            open_record = self.session.query(PriorityCurrentPrice).filter(\n                and_(\n                    PriorityCurrentPrice.stock_id == stock.id,\n                    PriorityCurrentPrice.datetime >= today_start\n                )\n            ).order_by(PriorityCurrentPrice.datetime.asc()).first()\n            \n            price_at_open = float(open_record.price_at_open) if open_record and open_record.price_at_open else float(stock.last_price or 0)\n            current_price = float(stock.last_price or 0)\n            \n            # Get previous price for percent change calculation\n            last_record = self.session.query(PriorityCurrentPrice).filter(\n                PriorityCurrentPrice.stock_id == stock.id\n            ).order_by(PriorityCurrentPrice.datetime.desc()).first()\n            \n            previous_price = float(last_record.current_price) if last_record else current_price\n            \n            # Calculate percent changes\n            pct_change_from_previous = ((current_price - previous_price) / previous_price * 100) if previous_price > 0 else 0\n            pct_change_from_open = ((current_price - price_at_open) / price_at_open * 100) if price_at_open > 0 else 0\n            \n            # Create new price record\n            price_record = PriorityCurrentPrice(\n                stock_id=stock.id,\n                symbol=stock.symbol,\n                datetime=current_time,\n                price_at_open=price_at_open if not open_record else open_record.price_at_open,\n                current_price=current_price,\n                percent_change_from_previous=round(pct_change_from_previous, 4),\n                percent_change_from_open=round(pct_change_from_open, 4),\n                volume=stock.volume,\n                bid=current_price * 0.999,  # Simulate bid/ask spread\n                ask=current_price * 1.001\n            )\n            \n            self.session.add(price_record)\n            updated_count += 1\n        \n        self.session.commit()\n        return updated_count\n    \n    def archive_priority_prices(self):\n        \"\"\"\n        Move records from priority_current_price to priority_archive_price \n        at the end of each day\n        \"\"\"\n        # Get yesterday's cutoff\n        yesterday = datetime.now() - timedelta(days=1)\n        cutoff = yesterday.replace(hour=23, minute=59, second=59)\n        \n        # Get records to archive\n        records_to_archive = self.session.query(PriorityCurrentPrice).filter(\n            PriorityCurrentPrice.datetime <= cutoff\n        ).all()\n        \n        archived_count = 0\n        for record in records_to_archive:\n            # Create archive record\n            archive_record = PriorityArchivePrice(\n                stock_id=record.stock_id,\n                symbol=record.symbol,\n                datetime=record.datetime,\n                price_at_open=record.price_at_open,\n                current_price=record.current_price,\n                percent_change_from_previous=record.percent_change_from_previous,\n                percent_change_from_open=record.percent_change_from_open,\n                volume=record.volume,\n                bid=record.bid,\n                ask=record.ask\n            )\n            \n            self.session.add(archive_record)\n            self.session.delete(record)\n            archived_count += 1\n        \n        self.session.commit()\n        return archived_count\n    \n    def purge_old_archive_data(self):\n        \"\"\"Purge archive data older than X days (from environment variables)\"\"\"\n        retention_days = self.get_environment_variable('ARCHIVE_RETENTION_DAYS', 30)\n        cutoff_date = datetime.now() - timedelta(days=retention_days)\n        \n        deleted_count = self.session.query(PriorityArchivePrice).filter(\n            PriorityArchivePrice.archived_date < cutoff_date\n        ).delete()\n        \n        self.session.commit()\n        return deleted_count\n    \n    def evaluate_trading_opportunities(self):\n        \"\"\"\n        Evaluate priority current price table for trading opportunities\n        If no order exists for ticker and X periods meet criteria, trigger trading logic\n        \"\"\"\n        evaluation_periods = self.get_environment_variable('PRIORITY_EVALUATION_PERIODS', 3)\n        \n        # Get all priority stocks\n        priority_stocks = self.session.query(Stock).filter(Stock.priority > 0).all()\n        opportunities = []\n        \n        for stock in priority_stocks:\n            # Check if there's already an open order for this stock\n            existing_order = self.session.query(Order).filter(\n                and_(\n                    Order.symbol == stock.symbol,\n                    Order.status.in_(['pending', 'partially_filled'])\n                )\n            ).first()\n            \n            if not existing_order:\n                # Get last X periods of price data\n                recent_prices = self.session.query(PriorityCurrentPrice).filter(\n                    PriorityCurrentPrice.stock_id == stock.id\n                ).order_by(PriorityCurrentPrice.datetime.desc()).limit(evaluation_periods).all()\n                \n                if len(recent_prices) >= evaluation_periods:\n                    # Analyze price movement for trading signals\n                    prices = [float(p.current_price) for p in reversed(recent_prices)]\n                    \n                    # Simple momentum strategy\n                    if len(prices) >= 2:\n                        momentum = (prices[-1] - prices[0]) / prices[0] * 100\n                        \n                        # Generate buy/sell signals based on momentum\n                        if momentum > 1.0:  # 1% positive momentum\n                            opportunities.append({\n                                'symbol': stock.symbol,\n                                'action': 'buy',\n                                'momentum': momentum,\n                                'current_price': prices[-1],\n                                'confidence': min(abs(momentum) * 10, 100)\n                            })\n                        elif momentum < -1.0:  # 1% negative momentum\n                            opportunities.append({\n                                'symbol': stock.symbol,\n                                'action': 'sell',\n                                'momentum': momentum,\n                                'current_price': prices[-1],\n                                'confidence': min(abs(momentum) * 10, 100)\n                            })\n        \n        return opportunities\n    \n    def get_lifo_cost_basis(self, symbol: str, quantity: int) -> tuple:\n        \"\"\"\n        Calculate LIFO cost basis for sale transactions\n        Returns (cost_basis, realized_gain_loss)\n        \"\"\"\n        # Get all buy transactions for this symbol, ordered by date desc (LIFO)\n        buy_transactions = self.session.query(TransactionLog).filter(\n            and_(\n                TransactionLog.symbol == symbol,\n                TransactionLog.transaction_type == 'buy'\n            )\n        ).order_by(TransactionLog.transaction_date.desc()).all()\n        \n        remaining_quantity = quantity\n        total_cost_basis = 0.0\n        \n        for transaction in buy_transactions:\n            if remaining_quantity <= 0:\n                break\n                \n            available_shares = transaction.quantity\n            shares_to_use = min(remaining_quantity, available_shares)\n            \n            cost_basis_portion = shares_to_use * float(transaction.price_per_share)\n            total_cost_basis += cost_basis_portion\n            \n            remaining_quantity -= shares_to_use\n        \n        return total_cost_basis, 0.0  # Return 0 for realized_gain_loss, to be calculated by caller\n    \n    def get_database_stats(self):\n        \"\"\"Get comprehensive database statistics\"\"\"\n        stats = {\n            'environment_variables': self.session.query(EnvironmentVariable).count(),\n            'stocks_total': self.session.query(Stock).count(),\n            'stocks_priority_1': self.session.query(Stock).filter(Stock.priority == 1).count(),\n            'stocks_sector_etf': self.session.query(Stock).filter(Stock.priority == 9).count(),\n            'priority_current_prices': self.session.query(PriorityCurrentPrice).count(),\n            'priority_archive_prices': self.session.query(PriorityArchivePrice).count(),\n            'orders_total': self.session.query(Order).count(),\n            'orders_pending': self.session.query(Order).filter(Order.status == 'pending').count(),\n            'transactions_total': self.session.query(TransactionLog).count()\n        }\n        \n        return stats","size_bytes":12795},"app_pages/dashboard.py":{"content":"import streamlit as st\nimport pandas as pd\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom datetime import datetime, timedelta\n\nfrom database.database import get_session\nfrom database.models import Stock, Order, TransactionLog, Account\nfrom services.data_fetcher import DataFetcher\nfrom services.broker_apis import BrokerManager\nfrom utils.helpers import format_currency, format_percentage, calculate_portfolio_value\nfrom utils.broker_status_widget import display_animated_broker_status, display_connection_health_chart\n\ndef show_dashboard():\n    st.title(\"ðŸ“Š Trading Dashboard\")\n    \n    # Animated broker status widget\n    st.subheader(\"ðŸ”— Broker Connection Status\")\n    is_connected, account_info = display_animated_broker_status()\n    \n    if not is_connected:\n        st.warning(\"âš ï¸ Broker connection issues detected. Some features may be limited.\")\n        return\n    \n    # Connection health monitoring\n    with st.expander(\"ðŸ“ˆ Connection Health Monitor\", expanded=False):\n        display_connection_health_chart()\n    \n    # Initialize broker manager if not already done\n    if 'broker_manager' not in st.session_state:\n        st.session_state.broker_manager = BrokerManager()\n    \n    broker_manager = st.session_state.broker_manager\n    \n    # Get account information from active broker\n    account_info = broker_manager.get_account_info()\n    \n    if 'error' not in account_info:\n        # Portfolio overview section\n        st.subheader(\"ðŸ’¼ Portfolio Overview\")\n        \n        col1, col2, col3, col4 = st.columns(4)\n        \n        with col1:\n            st.metric(\n                \"Portfolio Value\", \n                f\"${account_info.get('portfolio_value', 0):,.2f}\",\n                delta=f\"${account_info.get('portfolio_value', 0) - account_info.get('cash', 0):,.2f}\"\n            )\n        \n        with col2:\n            st.metric(\n                \"Cash Available\", \n                f\"${account_info.get('cash', 0):,.2f}\"\n            )\n        \n        with col3:\n            st.metric(\n                \"Buying Power\", \n                f\"${account_info.get('buying_power', 0):,.2f}\"\n            )\n        \n        with col4:\n            st.metric(\n                \"Day Trades Used\", \n                account_info.get('day_trade_count', 0),\n                delta=\"3 remaining\" if account_info.get('day_trade_count', 0) < 3 else \"Limit reached\"\n            )\n    else:\n        st.error(f\"âŒ Unable to connect to broker: {account_info.get('error', 'Unknown error')}\")\n    \n    # Current positions section\n    st.subheader(\"ðŸ“ˆ Current Positions\")\n    \n    positions = broker_manager.get_positions()\n    if positions:\n        position_data = []\n        for position in positions:\n            position_data.append({\n                \"Symbol\": position.get('symbol', 'N/A'),\n                \"Quantity\": position.get('qty', 0),\n                \"Market Value\": f\"${position.get('market_value', 0):,.2f}\",\n                \"Cost Basis\": f\"${position.get('cost_basis', 0):,.2f}\",\n                \"Unrealized P&L\": f\"${position.get('unrealized_pl', 0):,.2f}\",\n                \"Unrealized P&L %\": f\"{position.get('unrealized_plpc', 0):.2f}%\"\n            })\n        \n        if position_data:\n            df = pd.DataFrame(position_data)\n            \n            # Apply color styling to P&L columns\n            def color_pnl(val):\n                if isinstance(val, str) and '$' in val:\n                    num_val = float(val.replace('$', '').replace(',', ''))\n                    return 'color: green' if num_val >= 0 else 'color: red'\n                elif isinstance(val, str) and '%' in val:\n                    num_val = float(val.replace('%', ''))\n                    return 'color: green' if num_val >= 0 else 'color: red'\n                return ''\n            \n            styled_df = df.style.applymap(color_pnl, subset=['Unrealized P&L', 'Unrealized P&L %'])\n            st.dataframe(styled_df, use_container_width=True)\n        else:\n            st.info(\"No current positions\")\n    else:\n        st.info(\"No positions found\")\n    \n    # Market data section\n    st.subheader(\"ðŸ“Š Market Overview\")\n    \n    # Get live market data for major ETFs\n    market_symbols = ['SPY', 'QQQ', 'DIA', 'VIX']\n    market_data = broker_manager.get_market_data(market_symbols)\n    \n    if market_data:\n        cols = st.columns(len(market_symbols))\n        for i, symbol in enumerate(market_symbols):\n            if symbol in market_data:\n                data = market_data[symbol]\n                with cols[i]:\n                    price = data.get('price', 0)\n                    change_pct = data.get('change_percent', 0)\n                    delta_color = \"normal\" if change_pct >= 0 else \"inverse\"\n                    st.metric(\n                        symbol,\n                        f\"${price:.2f}\",\n                        f\"{change_pct:+.2f}%\",\n                        delta_color=delta_color\n                    )\n    \n    # Trading activity chart\n    st.subheader(\"ðŸ“ˆ Recent Trading Activity\")\n    \n    session = get_session()\n    try:\n        # Get recent transactions\n        recent_transactions = session.query(TransactionLog)\\\n            .order_by(TransactionLog.transaction_date.desc())\\\n            .limit(50).all()\n        \n        if recent_transactions:\n            # Create daily P&L chart\n            daily_data = {}\n            for transaction in recent_transactions:\n                date_str = transaction.transaction_date.strftime('%Y-%m-%d')\n                if date_str not in daily_data:\n                    daily_data[date_str] = {'pnl': 0, 'volume': 0}\n                \n                pnl = (transaction.price * transaction.quantity) * (1 if transaction.side == 'sell' else -1)\n                daily_data[date_str]['pnl'] += pnl\n                daily_data[date_str]['volume'] += abs(transaction.price * transaction.quantity)\n            \n            if daily_data:\n                df_chart = pd.DataFrame.from_dict(daily_data, orient='index')\n                df_chart.index = pd.to_datetime(df_chart.index)\n                df_chart = df_chart.sort_index()\n                \n                fig = go.Figure()\n                fig.add_trace(go.Scatter(\n                    x=df_chart.index,\n                    y=df_chart['pnl'].cumsum(),\n                    mode='lines+markers',\n                    name='Cumulative P&L',\n                    line=dict(color='green')\n                ))\n                \n                fig.update_layout(\n                    title=\"Cumulative P&L Over Time\",\n                    xaxis_title=\"Date\",\n                    yaxis_title=\"P&L ($)\",\n                    height=400\n                )\n                \n                st.plotly_chart(fig, use_container_width=True)\n        else:\n            st.info(\"No recent trading activity\")\n    \n    finally:\n        session.close()\n    \n    # Quick actions\n    st.subheader(\"âš¡ Quick Actions\")\n    \n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        if st.button(\"ðŸ”„ Refresh Data\"):\n            # Clear broker manager cache to reload from database\n            if 'broker_manager' in st.session_state:\n                st.session_state.broker_manager.reload_configuration()\n            st.rerun()\n    \n    with col2:\n        if st.button(\"ðŸ“Š Update Market Data\"):\n            with st.spinner(\"Updating market data...\"):\n                data_fetcher = DataFetcher()\n                data_fetcher.update_priority_stocks()\n                st.success(\"Market data updated!\")\n    \n    with col3:\n        if st.button(\"ðŸ’¹ Go to Trading\"):\n            st.switch_page(\"app_pages/trading.py\")\n    \n    with col4:\n        if st.button(\"âš™ï¸ Settings\"):\n            st.switch_page(\"app_pages/settings.py\")\n\nif __name__ == \"__main__\":\n    show_dashboard()","size_bytes":7809},"database/database.py":{"content":"import os\nfrom sqlalchemy import create_engine, event\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy.pool import StaticPool\nimport sqlite3\n\n# Database configuration - Force SQLite for stability\nDATABASE_URL = \"sqlite:///trading_platform.db\"\n\n# Create engine\nif DATABASE_URL.startswith(\"sqlite\"):\n    engine = create_engine(\n        DATABASE_URL,\n        connect_args={\n            \"check_same_thread\": False,\n            \"timeout\": 20\n        },\n        poolclass=StaticPool,\n        echo=False\n    )\n    \n    # Enable WAL mode for SQLite\n    @event.listens_for(engine, \"connect\")\n    def set_sqlite_pragma(dbapi_connection, connection_record):\n        if isinstance(dbapi_connection, sqlite3.Connection):\n            cursor = dbapi_connection.cursor()\n            cursor.execute(\"PRAGMA journal_mode=WAL\")\n            cursor.execute(\"PRAGMA synchronous=NORMAL\")\n            cursor.execute(\"PRAGMA cache_size=10000\")\n            cursor.execute(\"PRAGMA temp_store=MEMORY\")\n            cursor.close()\nelse:\n    engine = create_engine(DATABASE_URL)\n\n# Create session factory\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\n# Base class for models\nBase = declarative_base()\n\ndef get_session():\n    \"\"\"Get database session\"\"\"\n    session = SessionLocal()\n    try:\n        return session\n    except Exception:\n        session.close()\n        raise\n\ndef init_database():\n    \"\"\"Initialize database and create tables\"\"\"\n    from database.models import (\n        User, EnvironmentVariable, BrokerageInfo, Account, \n        Stock, StockPriceHistory, PriorityCurrentPrice, \n        PriorityArchivePrice, Order, TransactionLog\n    )\n    \n    # Create all tables\n    Base.metadata.create_all(bind=engine)\n    \n    # Initialize default data\n    session = get_session()\n    try:\n        # Create default admin user if not exists\n        admin_user = session.query(User).filter(User.username == 'admin').first()\n        if not admin_user:\n            from utils.auth import hash_password\n            admin_user = User(\n                username='admin',\n                email='admin@trading.com',\n                password_hash=hash_password('admin123'),\n                role='admin',\n                is_active=True\n            )\n            session.add(admin_user)\n        \n        # Create default environment variables\n        default_env_vars = {\n            'TRADING_MODE': 'paper',  # paper or live\n            'ACTIVE_BROKER': 'alpaca',\n            'PRICE_UPDATE_INTERVAL': '30',  # seconds\n            'ARCHIVE_RETENTION_DAYS': '30',\n            'MAX_POSITION_SIZE_PERCENT': '5',\n            'RISK_MANAGEMENT_ENABLED': 'true',\n            'TECHNICAL_ANALYSIS_PERIODS': '14'\n        }\n        \n        for key, value in default_env_vars.items():\n            existing = session.query(EnvironmentVariable).filter(\n                EnvironmentVariable.key == key\n            ).first()\n            if not existing:\n                env_var = EnvironmentVariable(\n                    key=key,\n                    value=value,\n                    description=f'Default {key.lower().replace(\"_\", \" \")}'\n                )\n                session.add(env_var)\n        \n        # Create default brokerage info\n        brokers = [\n            {\n                'name': 'Alpaca',\n                'api_url': 'https://paper-api.alpaca.markets',\n                'trading_fees_per_share': 0.0,\n                'trading_fees_per_contract': 0.65,\n                'day_trade_limit': 3,\n                'supports_options': True,\n                'supports_crypto': True,\n                'is_active': True\n            },\n            {\n                'name': 'Robinhood',\n                'api_url': 'https://robinhood.com/api',\n                'trading_fees_per_share': 0.0,\n                'trading_fees_per_contract': 0.0,\n                'day_trade_limit': 3,\n                'supports_options': True,\n                'supports_crypto': True,\n                'is_active': False\n            }\n        ]\n        \n        for broker_data in brokers:\n            existing = session.query(BrokerageInfo).filter(\n                BrokerageInfo.name == broker_data['name']\n            ).first()\n            if not existing:\n                broker = BrokerageInfo(**broker_data)\n                session.add(broker)\n        \n        # Initialize S&P 500 stocks with sample data including prices\n        sample_stocks = [\n            {'symbol': 'AAPL', 'name': 'Apple Inc.', 'sector': 'Technology', 'industry': 'Consumer Electronics', 'market_cap': 3000000000000, 'last_price': 185.50, 'change_percent': 1.2},\n            {'symbol': 'MSFT', 'name': 'Microsoft Corporation', 'sector': 'Technology', 'industry': 'Software', 'market_cap': 2800000000000, 'last_price': 420.25, 'change_percent': 0.8},\n            {'symbol': 'GOOGL', 'name': 'Alphabet Inc.', 'sector': 'Communication Services', 'industry': 'Internet Services', 'market_cap': 1800000000000, 'last_price': 155.75, 'change_percent': -0.5},\n            {'symbol': 'AMZN', 'name': 'Amazon.com Inc.', 'sector': 'Consumer Discretionary', 'industry': 'E-commerce', 'market_cap': 1600000000000, 'last_price': 165.80, 'change_percent': 2.1},\n            {'symbol': 'TSLA', 'name': 'Tesla Inc.', 'sector': 'Consumer Discretionary', 'industry': 'Electric Vehicles', 'market_cap': 800000000000, 'last_price': 245.30, 'change_percent': 3.5},\n            {'symbol': 'META', 'name': 'Meta Platforms Inc.', 'sector': 'Communication Services', 'industry': 'Social Media', 'market_cap': 900000000000, 'last_price': 485.60, 'change_percent': 1.8},\n            {'symbol': 'NVDA', 'name': 'NVIDIA Corporation', 'sector': 'Technology', 'industry': 'Semiconductors', 'market_cap': 2200000000000, 'last_price': 875.40, 'change_percent': 4.2},\n            {'symbol': 'JPM', 'name': 'JPMorgan Chase & Co.', 'sector': 'Financials', 'industry': 'Banking', 'market_cap': 500000000000, 'last_price': 195.75, 'change_percent': 0.3},\n            {'symbol': 'JNJ', 'name': 'Johnson & Johnson', 'sector': 'Healthcare', 'industry': 'Pharmaceuticals', 'market_cap': 450000000000, 'last_price': 155.20, 'change_percent': -0.2},\n            {'symbol': 'V', 'name': 'Visa Inc.', 'sector': 'Financials', 'industry': 'Payment Processing', 'market_cap': 520000000000, 'last_price': 295.85, 'change_percent': 1.1}\n        ]\n        \n        for stock_data in sample_stocks:\n            existing = session.query(Stock).filter(Stock.symbol == stock_data['symbol']).first()\n            if not existing:\n                stock = Stock(**stock_data, priority=1, has_options=True)\n                session.add(stock)\n        \n        session.commit()\n    except Exception as e:\n        session.rollback()\n        raise e\n    finally:\n        session.close()\n","size_bytes":6819},"app_pages/dashboard_old.py":{"content":"import streamlit as st\nimport pandas as pd\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom datetime import datetime, timedelta\n\nfrom database.database import get_session\nfrom database.models import Stock, Order, TransactionLog, Account\nfrom services.data_fetcher import DataFetcher\nfrom services.broker_apis import BrokerManager\nfrom utils.helpers import format_currency, format_percentage, calculate_portfolio_value\n\ndef show_dashboard():\n    st.title(\"ðŸ’¹ Trading Interface\")\n    \n    # Trading mode selector\n    col1, col2 = st.columns([1, 1])\n    with col1:\n        trading_mode = st.selectbox(\"Trading Mode\", [\"Paper Trading\", \"Live Trading\"])\n    \n    with col2:\n        auto_trading = st.checkbox(\"Enable Auto Trading\", value=False)\n    \n    if trading_mode == \"Live Trading\":\n        st.warning(\"âš ï¸ Live trading is enabled. Real money will be used!\")\n    \n    # Priority stocks section\n    st.subheader(\"ðŸŽ¯ Priority Stocks\")\n    \n    session = get_session()\n    try:\n        priority_stocks = session.query(Stock).filter(Stock.priority > 0).all()\n        \n        if priority_stocks:\n            # Create DataFrame for display\n            stock_data = []\n            for stock in priority_stocks:\n                stock_data.append({\n                    \"Symbol\": stock.symbol,\n                    \"Name\": stock.name,\n                    \"Sector\": stock.sector,\n                    \"Last Price\": stock.last_price or 0,\n                    \"Change %\": stock.change_percent or 0,\n                    \"Priority\": stock.priority,\n                    \"Has Options\": \"âœ…\" if stock.has_options else \"âŒ\"\n                })\n            \n            df = pd.DataFrame(stock_data)\n            \n            # Apply styling to the dataframe\n            def color_change(val):\n                color = 'green' if val > 0 else 'red' if val < 0 else 'gray'\n                return f'color: {color}'\n            \n            styled_df = df.style.map(color_change, subset=['Change %'])\n            st.dataframe(styled_df, use_container_width=True)\n            \n            # Stock selection for manual trading\n            st.subheader(\"ðŸ“‹ Manual Trading\")\n            \n            col1, col2, col3, col4 = st.columns([2, 1, 1, 1])\n            \n            with col1:\n                selected_symbol = st.selectbox(\"Select Stock\", [s.symbol for s in priority_stocks])\n            \n            with col2:\n                trade_side = st.selectbox(\"Side\", [\"Buy\", \"Sell\"])\n            \n            with col3:\n                asset_type = st.selectbox(\"Asset Type\", [\"Stock\", \"Call Option\", \"Put Option\"])\n            \n            with col4:\n                quantity = st.number_input(\"Quantity\", min_value=1, value=100)\n            \n            if asset_type in [\"Call Option\", \"Put Option\"]:\n                col1, col2 = st.columns(2)\n                with col1:\n                    strike_price = st.number_input(\"Strike Price\", min_value=0.01, value=100.0)\n                with col2:\n                    expiry_date = st.date_input(\"Expiry Date\", value=datetime.now() + timedelta(days=30))\n            \n            if st.button(\"Place Order\", type=\"primary\"):\n                if _place_manual_order(selected_symbol, trade_side, asset_type, quantity, trading_mode):\n                    st.success(f\"Order placed: {trade_side} {quantity} {selected_symbol}\")\n                    st.rerun()\n                else:\n                    st.error(\"Failed to place order\")\n        \n        else:\n            st.info(\"No priority stocks identified. Run market analysis to identify priority stocks.\")\n            \n            if st.button(\"ðŸ”„ Run Market Analysis\"):\n                with st.spinner(\"Analyzing market data...\"):\n                    data_fetcher = DataFetcher()\n                    data_fetcher.update_priority_stocks()\n                    st.success(\"Market analysis completed!\")\n                    st.rerun()\n    \n    finally:\n        session.close()\n    \n    # Recent orders section\n    st.subheader(\"ðŸ“„ Recent Orders\")\n    _show_recent_orders()\n    \n    # Market data section\n    st.subheader(\"ðŸ“Š Market Data\")\n    _show_market_data()\n\ndef _place_manual_order(symbol: str, side: str, asset_type: str, quantity: int, trading_mode: str) -> bool:\n    \"\"\"Place a manual trading order\"\"\"\n    session = get_session()\n    try:\n        # Create order record\n        order = Order(\n            account_id=1,  # Default account\n            symbol=symbol,\n            order_type='market',\n            side=side.lower(),\n            quantity=quantity,\n            asset_type='stock' if asset_type == 'Stock' else 'option',\n            option_type=asset_type.split()[0].lower() if 'Option' in asset_type else None,\n            status='pending'\n        )\n        \n        session.add(order)\n        session.commit()\n        \n        # For paper trading, immediately fill the order\n        if trading_mode == \"Paper Trading\":\n            order.status = 'filled'\n            order.filled_at = datetime.utcnow()\n            \n            # Create transaction record\n            stock = session.query(Stock).filter(Stock.symbol == symbol).first()\n            price = stock.last_price if stock and stock.last_price else 100.0\n            \n            transaction = TransactionLog(\n                order_id=order.id,\n                account_id=order.account_id,\n                symbol=symbol,\n                side=side.lower(),\n                quantity=quantity,\n                price=price,\n                asset_type=order.asset_type,\n                option_type=order.option_type\n            )\n            session.add(transaction)\n            session.commit()\n        \n        return True\n    \n    except Exception as e:\n        session.rollback()\n        st.error(f\"Error placing order: {e}\")\n        return False\n    finally:\n        session.close()\n\ndef _show_recent_orders():\n    \"\"\"Display recent orders\"\"\"\n    session = get_session()\n    try:\n        recent_orders = session.query(Order).order_by(Order.created_at.desc()).limit(10).all()\n        \n        if recent_orders:\n            order_data = []\n            for order in recent_orders:\n                order_data.append({\n                    \"Time\": order.created_at.strftime(\"%Y-%m-%d %H:%M\"),\n                    \"Symbol\": order.symbol,\n                    \"Side\": order.side.upper(),\n                    \"Type\": order.asset_type.title(),\n                    \"Quantity\": order.quantity,\n                    \"Status\": order.status.title(),\n                    \"Price\": f\"${order.price:.2f}\" if order.price else \"Market\"\n                })\n            \n            df = pd.DataFrame(order_data)\n            st.dataframe(df, use_container_width=True)\n        else:\n            st.info(\"No recent orders\")\n    \n    finally:\n        session.close()\n\ndef _show_market_data():\n    \"\"\"Display market overview data\"\"\"\n    # Market indices (simulated data for demo)\n    indices_data = {\n        \"Index\": [\"S&P 500\", \"NASDAQ\", \"DOW\", \"VIX\"],\n        \"Value\": [4520.45, 14230.50, 35180.25, 18.45],\n        \"Change\": [45.20, 120.30, -25.80, 2.15],\n        \"Change %\": [1.01, 0.85, -0.07, 13.20]\n    }\n    \n    indices_df = pd.DataFrame(indices_data)\n    \n    # Apply color styling\n    def color_change(val):\n        color = 'green' if val > 0 else 'red' if val < 0 else 'gray'\n        return f'color: {color}'\n    \n    styled_indices = indices_df.style.map(color_change, subset=['Change', 'Change %'])\n    st.dataframe(styled_indices, use_container_width=True)\n    \n    # Sector performance chart\n    sector_data = {\n        \"Sector\": [\"Technology\", \"Healthcare\", \"Financials\", \"Energy\", \"Materials\"],\n        \"Performance\": [2.5, 1.8, -0.5, 3.2, 1.2]\n    }\n    \n    fig = px.bar(\n        sector_data, \n        x=\"Sector\", \n        y=\"Performance\",\n        title=\"Sector Performance (%)\",\n        color=\"Performance\",\n        color_continuous_scale=['red', 'yellow', 'green']\n    )\n    \n    st.plotly_chart(fig, use_container_width=True)\n","size_bytes":8000},"app_pages/settings.py":{"content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime\n\nfrom database.database import get_session\nfrom database.models import EnvironmentVariable, BrokerageInfo, Account, User\nfrom utils.auth import check_permission, hash_password\nfrom services.data_fetcher import DataFetcher\nfrom utils.broker_status_widget import display_animated_broker_status\n\ndef show_settings_page():\n    \"\"\"Settings and configuration page\"\"\"\n    st.title(\"âš™ï¸ Settings & Configuration\")\n    \n    # Check user permissions\n    user = st.session_state.user\n    is_admin = user.role == 'admin'\n    is_trader = user.role == 'trader'\n    is_viewer = user.role == 'viewer'\n    \n    # Settings tabs based on role\n    if is_admin:\n        tab1, tab2, tab3, tab4, tab5 = st.tabs([\n            \"ðŸ“Š Trading Settings\", \n            \"ðŸ¦ Broker Configuration\", \n            \"ðŸ’° Account Settings\",\n            \"ðŸ”§ System Settings\",\n            \"ðŸ‘¤ User Profile\"\n        ])\n    elif is_trader:\n        tab1, tab2, tab3, tab4 = st.tabs([\n            \"ðŸ“Š Trading Settings\",\n            \"ðŸ¦ Broker Configuration\",\n            \"ðŸ’° Account Settings\", \n            \"ðŸ‘¤ User Profile\"\n        ])\n    else:  # viewer\n        tab1, tab2 = st.tabs([\"ðŸ’° Account Settings\", \"ðŸ‘¤ User Profile\"])\n        \n        with tab1:\n            _show_account_settings()\n        with tab2:\n            _show_user_profile()\n        return\n    \n    # Admin tabs\n    if is_admin:\n        with tab1:\n            _show_trading_settings()\n        with tab2:\n            _show_broker_configuration()\n        with tab3:\n            _show_account_settings()\n        with tab4:\n            _show_system_settings()\n        with tab5:\n            _show_user_profile()\n    \n    # Trader tabs\n    elif is_trader:\n        with tab1:\n            _show_trading_settings()\n        with tab2:\n            _show_broker_configuration()\n        with tab3:\n            _show_account_settings()\n        with tab4:\n            _show_user_profile()\n\ndef _show_trading_settings():\n    \"\"\"Show trading configuration settings\"\"\"\n    st.subheader(\"ðŸ“Š Trading Configuration\")\n    \n    session = get_session()\n    try:\n        # Get current environment variables\n        env_vars = {var.key: var.value for var in session.query(EnvironmentVariable).all()}\n        \n        col1, col2 = st.columns(2)\n        \n        with col1:\n            st.write(\"**General Trading Settings**\")\n            \n            # Trading mode\n            trading_mode = st.selectbox(\n                \"Trading Mode\",\n                [\"paper\", \"live\"],\n                index=0 if env_vars.get('TRADING_MODE', 'paper') == 'paper' else 1\n            )\n            \n            # Active broker display (read-only)\n            from services.broker_apis import BrokerManager\n            broker_manager = BrokerManager()\n            real_active_broker = broker_manager.get_active_broker_name()\n            trading_mode = env_vars.get('TRADING_MODE', 'paper')\n            \n            st.write(\"**Active Broker**\")\n            st.success(f\"ðŸŽ¯ {real_active_broker} ({'Paper Trading' if trading_mode == 'paper' else 'Live Trading'})\")\n            st.caption(\"To change broker, use the 'Broker Configuration' tab below\")\n            \n            # Price update interval\n            price_interval = st.number_input(\n                \"Price Update Interval (seconds)\",\n                min_value=5,\n                max_value=300,\n                value=int(env_vars.get('PRICE_UPDATE_INTERVAL', '30'))\n            )\n        \n        with col2:\n            st.write(\"**Risk Management**\")\n            \n            # Maximum position size\n            max_position_size = st.number_input(\n                \"Max Position Size (%)\",\n                min_value=1.0,\n                max_value=25.0,\n                value=float(env_vars.get('MAX_POSITION_SIZE_PERCENT', '5.0')),\n                step=0.5\n            )\n            \n            # Risk management enabled\n            risk_management = st.checkbox(\n                \"Enable Risk Management\",\n                value=env_vars.get('RISK_MANAGEMENT_ENABLED', 'true').lower() == 'true'\n            )\n            \n            # Technical analysis periods\n            ta_periods = st.number_input(\n                \"Technical Analysis Periods\",\n                min_value=5,\n                max_value=50,\n                value=int(env_vars.get('TECHNICAL_ANALYSIS_PERIODS', '14'))\n            )\n        \n        st.write(\"**Data Management**\")\n        \n        col3, col4 = st.columns(2)\n        \n        with col3:\n            # Archive retention\n            archive_days = st.number_input(\n                \"Archive Retention (days)\",\n                min_value=7,\n                max_value=365,\n                value=int(env_vars.get('ARCHIVE_RETENTION_DAYS', '30'))\n            )\n        \n        with col4:\n            # Auto-update settings\n            auto_update = st.checkbox(\n                \"Auto-update Market Data\",\n                value=True\n            )\n        \n        # Save button\n        if st.button(\"ðŸ’¾ Save Trading Settings\", type=\"primary\"):\n            _save_environment_variables(session, {\n                'TRADING_MODE': trading_mode,\n                'PRICE_UPDATE_INTERVAL': str(price_interval),\n                'MAX_POSITION_SIZE_PERCENT': str(max_position_size),\n                'RISK_MANAGEMENT_ENABLED': str(risk_management).lower(),\n                'TECHNICAL_ANALYSIS_PERIODS': str(ta_periods),\n                'ARCHIVE_RETENTION_DAYS': str(archive_days)\n            })\n            st.success(\"Trading settings saved successfully!\")\n            st.rerun()\n    \n    except Exception as e:\n        st.error(f\"Error loading trading settings: {e}\")\n    finally:\n        session.close()\n\ndef _show_broker_configuration():\n    \"\"\"Show comprehensive broker API configuration\"\"\"\n    st.subheader(\"ðŸ¦ Broker Configuration\")\n    \n    session = get_session()\n    try:\n        # Get current configuration from environment variables\n        trading_mode_var = session.query(EnvironmentVariable)\\\n            .filter(EnvironmentVariable.key == 'TRADING_MODE').first()\n        paper_broker_var = session.query(EnvironmentVariable)\\\n            .filter(EnvironmentVariable.key == 'PAPER_TRADING_BROKER').first()\n        live_broker_var = session.query(EnvironmentVariable)\\\n            .filter(EnvironmentVariable.key == 'LIVE_TRADING_BROKER').first()\n        \n        current_mode = trading_mode_var.value if trading_mode_var else 'paper'\n        current_paper_broker = paper_broker_var.value if paper_broker_var else 'alpaca_paper'\n        current_live_broker = live_broker_var.value if live_broker_var else 'robinhood'\n        \n        # Get real active broker from broker manager for accuracy\n        from services.broker_apis import BrokerManager\n        test_manager = BrokerManager()\n        real_active_broker = test_manager.get_active_broker_name()\n        \n        # Current active broker display\n        active_broker = current_paper_broker if current_mode == 'paper' else current_live_broker\n        st.success(f\"ðŸŽ¯ **Currently Active:** {real_active_broker} ({'Paper Trading' if current_mode == 'paper' else 'Live Trading'})\")\n        \n        # Show sync status\n        if real_active_broker != active_broker:\n            st.warning(f\"âš ï¸ Configuration sync needed. Database shows '{active_broker}' but system is using '{real_active_broker}'\")\n        \n        # Trading mode selection\n        st.write(\"**Trading Mode Configuration**\")\n        trading_mode = st.selectbox(\n            \"Trading Mode\",\n            [\"paper\", \"live\"],\n            index=0 if current_mode == 'paper' else 1,\n            help=\"Paper trading uses virtual money, Live trading uses real money\",\n            key=\"trading_mode_select\"\n        )\n        \n        col1, col2 = st.columns(2)\n        \n        with col1:\n            st.subheader(\"ðŸ“„ Paper Trading Broker\")\n            paper_broker = st.selectbox(\n                \"Paper Trading Broker\",\n                [\"alpaca_paper\", \"tradier_paper\", \"robinhood\"],\n                index=[\"alpaca_paper\", \"tradier_paper\", \"robinhood\"].index(current_paper_broker) if current_paper_broker in [\"alpaca_paper\", \"tradier_paper\", \"robinhood\"] else 0,\n                key=\"paper_broker_select\"\n            )\n            \n            # Show broker details\n            broker_details = {\n                'alpaca_paper': \"âœ… Alpaca Markets - Paper Trading\\nâ€¢ Free real market data\\nâ€¢ $100K virtual portfolio\\nâ€¢ Full API access\",\n                'tradier_paper': \"âš™ï¸ Tradier - Sandbox Environment\\nâ€¢ Developer friendly\\nâ€¢ Options trading focus\\nâ€¢ Mock implementation\",\n                'robinhood': \"ðŸš§ Robinhood - Mock Interface\\nâ€¢ Commission free design\\nâ€¢ Future implementation\\nâ€¢ Mock data only\"\n            }\n            st.info(broker_details.get(paper_broker, \"\"))\n        \n        with col2:\n            st.subheader(\"ðŸ’° Live Trading Broker\")\n            live_broker = st.selectbox(\n                \"Live Trading Broker\",\n                [\"robinhood\", \"alpaca_live\", \"tradier_live\"],\n                index=[\"robinhood\", \"alpaca_live\", \"tradier_live\"].index(current_live_broker) if current_live_broker in [\"robinhood\", \"alpaca_live\", \"tradier_live\"] else 0,\n                key=\"live_broker_select\"\n            )\n            \n            # Show broker details\n            live_details = {\n                'robinhood': \"ðŸš§ Robinhood - Commission Free\\nâ€¢ $0 stock trades\\nâ€¢ $0 options contracts\\nâ€¢ Future implementation\",\n                'alpaca_live': \"âš ï¸ Alpaca Markets - Live Trading\\nâ€¢ Real money trades\\nâ€¢ Professional API\\nâ€¢ Requires live API keys\",\n                'tradier_live': \"ðŸ’¼ Tradier - Professional Platform\\nâ€¢ Advanced options trading\\nâ€¢ Institutional features\\nâ€¢ Future implementation\"\n            }\n            st.info(live_details.get(live_broker, \"\"))\n        \n        # Save configuration button\n        if st.button(\"ðŸ’¾ Save Broker Configuration\", type=\"primary\"):\n            # Update or create environment variables\n            def update_env_var(key: str, value: str):\n                env_var = session.query(EnvironmentVariable)\\\n                    .filter(EnvironmentVariable.key == key).first()\n                if env_var:\n                    env_var.value = value\n                else:\n                    env_var = EnvironmentVariable(key=key, value=value)\n                    session.add(env_var)\n            \n            update_env_var('TRADING_MODE', trading_mode)\n            update_env_var('PAPER_TRADING_BROKER', paper_broker)\n            update_env_var('LIVE_TRADING_BROKER', live_broker)\n            \n            session.commit()\n            \n            # Clear broker manager cache to force re-initialization across all pages\n            if 'broker_manager' in st.session_state:\n                del st.session_state['broker_manager']\n            \n            st.success(\"âœ… Broker configuration saved! All pages updated.\")\n            st.info(\"ðŸ”„ Dashboard, Trading, and Portfolio pages will now use the new broker.\")\n            st.balloons()\n            st.rerun()\n        \n        # Show current broker status with animated widget\n        st.subheader(\"ðŸ“Š Live Broker Connection Status\")\n        is_connected, account_info = display_animated_broker_status()\n        \n        if not is_connected:\n            st.error(\"âš ï¸ Connection test failed. Please verify broker credentials and network connectivity.\")\n        \n        # Trading fees configuration  \n        st.subheader(\"ðŸ’° Trading Fees Configuration\")\n        broker_info = session.query(BrokerageInfo).first()\n        \n        if not broker_info:\n            broker_info = BrokerageInfo(\n                name=\"Default Broker\",\n                trading_fees_per_share=0.01,\n                trading_fees_per_contract=0.65,\n                api_endpoint=\"https://api.broker.com\",\n                is_active=True\n            )\n            session.add(broker_info)\n            session.commit()\n        \n        col1, col2 = st.columns(2)\n        \n        with col1:\n            fees_per_share = st.number_input(\n                \"Trading Fees per Share ($)\", \n                value=float(broker_info.trading_fees_per_share),\n                min_value=0.0, \n                step=0.01,\n                key=\"broker_fees_per_share\"\n            )\n        \n        with col2:\n            fees_per_contract = st.number_input(\n                \"Trading Fees per Contract ($)\", \n                value=float(broker_info.trading_fees_per_contract),\n                min_value=0.0, \n                step=0.01,\n                key=\"broker_fees_per_contract\"\n            )\n        \n        if st.button(\"ðŸ’° Save Trading Fees\"):\n            broker_info.trading_fees_per_share = fees_per_share\n            broker_info.trading_fees_per_contract = fees_per_contract\n            session.commit()\n            st.success(\"Trading fees updated successfully!\")\n    \n    except Exception as e:\n        st.error(f\"Error in broker configuration: {e}\")\n    finally:\n        session.close()\n\ndef _show_account_settings():\n    \"\"\"Show account management settings\"\"\"\n    st.subheader(\"ðŸ’° Account Settings\")\n    \n    session = get_session()\n    try:\n        accounts = session.query(Account).all()\n        \n        # Display existing accounts\n        st.write(\"**Trading Accounts**\")\n        \n        if accounts:\n            account_data = []\n            for account in accounts:\n                brokerage = session.query(BrokerageInfo).filter(\n                    BrokerageInfo.id == account.brokerage_id\n                ).first()\n                \n                account_data.append({\n                    \"Account Name\": account.account_name,\n                    \"Brokerage\": brokerage.name if brokerage else \"Unknown\",\n                    \"Type\": account.account_type.title(),\n                    \"Total Balance\": f\"${account.total_balance:,.2f}\",\n                    \"Cash Balance\": f\"${account.cash_balance:,.2f}\",\n                    \"Status\": \"Active\" if account.is_active else \"Inactive\"\n                })\n            \n            df = pd.DataFrame(account_data)\n            st.dataframe(df, use_container_width=True)\n        else:\n            st.info(\"No accounts configured\")\n        \n        # Add new account form\n        st.write(\"**Add New Account**\")\n        \n        # Get available brokerages\n        brokerages = session.query(BrokerageInfo).filter(BrokerageInfo.is_active == True).all()\n        \n        if brokerages:\n            col1, col2 = st.columns(2)\n            \n            with col1:\n                selected_brokerage = st.selectbox(\n                    \"Brokerage\",\n                    brokerages,\n                    format_func=lambda x: x.name\n                )\n                \n                account_name = st.text_input(\"Account Name\")\n            \n            with col2:\n                account_type = st.selectbox(\n                    \"Account Type\",\n                    [\"cash\", \"margin\", \"ira\"]\n                )\n                \n                initial_balance = st.number_input(\n                    \"Initial Balance ($)\",\n                    min_value=0.0,\n                    value=10000.0\n                )\n            \n            if st.button(\"âž• Add Account\"):\n                if account_name:\n                    _add_new_account(\n                        session, selected_brokerage.id, account_name,\n                        account_type, initial_balance\n                    )\n                    st.success(f\"Account {account_name} added successfully!\")\n                    st.rerun()\n                else:\n                    st.error(\"Please enter an account name\")\n        else:\n            st.warning(\"Please configure at least one brokerage first\")\n    \n    except Exception as e:\n        st.error(f\"Error in account settings: {e}\")\n    finally:\n        session.close()\n\ndef _show_system_settings():\n    \"\"\"Show system-wide settings\"\"\"\n    st.subheader(\"ðŸ”§ System Settings\")\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.write(\"**Data Management**\")\n        \n        if st.button(\"ðŸ”„ Update Stock Database\"):\n            with st.spinner(\"Updating stock database...\"):\n                try:\n                    data_fetcher = DataFetcher()\n                    data_fetcher.update_stock_database()\n                    st.success(\"Stock database updated!\")\n                except Exception as e:\n                    st.error(f\"Error updating stock database: {e}\")\n        \n        if st.button(\"ðŸ“Š Update Historical Data\"):\n            with st.spinner(\"Updating historical data...\"):\n                try:\n                    data_fetcher = DataFetcher()\n                    data_fetcher.update_historical_data(days=90)\n                    st.success(\"Historical data updated!\")\n                except Exception as e:\n                    st.error(f\"Error updating historical data: {e}\")\n        \n        if st.button(\"ðŸŽ¯ Update Priority Stocks\"):\n            with st.spinner(\"Analyzing priority stocks...\"):\n                try:\n                    data_fetcher = DataFetcher()\n                    data_fetcher.update_priority_stocks()\n                    st.success(\"Priority stocks updated!\")\n                except Exception as e:\n                    st.error(f\"Error updating priority stocks: {e}\")\n    \n    with col2:\n        st.write(\"**Database Maintenance**\")\n        \n        if st.button(\"ðŸ—„ï¸ Archive Old Data\"):\n            with st.spinner(\"Archiving old data...\"):\n                try:\n                    data_fetcher = DataFetcher()\n                    data_fetcher.archive_priority_prices()\n                    st.success(\"Old data archived!\")\n                except Exception as e:\n                    st.error(f\"Error archiving data: {e}\")\n        \n        if st.button(\"ðŸ§¹ Cleanup Database\"):\n            st.warning(\"Database cleanup will remove old records. This action cannot be undone.\")\n            if st.button(\"Confirm Cleanup\", type=\"secondary\"):\n                st.info(\"Database cleanup feature not implemented in demo\")\n        \n        st.write(\"**System Information**\")\n        st.info(f\"Database: SQLite\")\n        st.info(f\"Last Updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")\n\ndef _show_user_profile():\n    \"\"\"Show user profile and preferences\"\"\"\n    st.subheader(\"ðŸ‘¤ User Profile\")\n    \n    user = st.session_state.user\n    \n    # User information\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.write(\"**Account Information**\")\n        st.info(f\"Username: {user.username}\")\n        st.info(f\"Email: {user.email}\")\n        st.info(f\"Role: {user.role.title()}\")\n        st.info(f\"Member Since: {user.created_at.strftime('%Y-%m-%d')}\")\n    \n    with col2:\n        st.write(\"**Update Profile**\")\n        \n        new_email = st.text_input(\"New Email\", value=user.email)\n        \n        if st.button(\"ðŸ“§ Update Email\"):\n            if new_email != user.email:\n                session = get_session()\n                try:\n                    user_record = session.query(User).filter(User.id == user.id).first()\n                    if user_record:\n                        user_record.email = new_email\n                        session.commit()\n                        st.success(\"Email updated successfully!\")\n                        st.rerun()\n                except Exception as e:\n                    session.rollback()\n                    st.error(f\"Error updating email: {e}\")\n                finally:\n                    session.close()\n    \n    # Change password\n    st.write(\"**Change Password**\")\n    \n    col3, col4 = st.columns(2)\n    \n    with col3:\n        current_password = st.text_input(\"Current Password\", type=\"password\")\n    \n    with col4:\n        new_password = st.text_input(\"New Password\", type=\"password\")\n        confirm_password = st.text_input(\"Confirm New Password\", type=\"password\")\n    \n    if st.button(\"ðŸ” Change Password\"):\n        if new_password != confirm_password:\n            st.error(\"New passwords don't match\")\n        elif len(new_password) < 6:\n            st.error(\"Password must be at least 6 characters\")\n        else:\n            session = get_session()\n            try:\n                from utils.auth import verify_password\n                user_record = session.query(User).filter(User.id == user.id).first()\n                \n                if user_record and verify_password(current_password, user_record.password_hash):\n                    user_record.password_hash = hash_password(new_password)\n                    session.commit()\n                    st.success(\"Password changed successfully!\")\n                else:\n                    st.error(\"Current password is incorrect\")\n            except Exception as e:\n                session.rollback()\n                st.error(f\"Error changing password: {e}\")\n            finally:\n                session.close()\n\ndef _save_environment_variables(session, variables):\n    \"\"\"Save environment variables to database\"\"\"\n    try:\n        for key, value in variables.items():\n            env_var = session.query(EnvironmentVariable).filter(\n                EnvironmentVariable.key == key\n            ).first()\n            \n            if env_var:\n                env_var.value = value\n                env_var.updated_at = datetime.utcnow()\n            else:\n                env_var = EnvironmentVariable(\n                    key=key,\n                    value=value,\n                    description=f\"Auto-generated {key}\"\n                )\n                session.add(env_var)\n        \n        session.commit()\n    except Exception as e:\n        session.rollback()\n        raise e\n\ndef _save_broker_configuration(session, name, api_url, api_key, api_secret, \n                             trading_fees_per_share, trading_fees_per_contract, day_trade_limit, is_active):\n    \"\"\"Save broker configuration\"\"\"\n    try:\n        broker = session.query(BrokerageInfo).filter(\n            BrokerageInfo.name == name\n        ).first()\n        \n        if broker:\n            broker.api_url = api_url\n            broker.trading_fees_per_share = trading_fees_per_share\n            broker.trading_fees_per_contract = trading_fees_per_contract\n            broker.day_trade_limit = day_trade_limit\n            broker.is_active = is_active\n            if api_key:\n                broker.api_key = api_key\n            if api_secret:\n                broker.api_secret = api_secret\n        else:\n            broker = BrokerageInfo(\n                name=name,\n                api_url=api_url,\n                api_key=api_key,\n                api_secret=api_secret,\n                trading_fees_per_share=trading_fees_per_share,\n                trading_fees_per_contract=trading_fees_per_contract,\n                day_trade_limit=day_trade_limit,\n                is_active=is_active\n            )\n            session.add(broker)\n        \n        session.commit()\n    except Exception as e:\n        session.rollback()\n        raise e\n\ndef _add_new_account(session, brokerage_id, account_name, account_type, initial_balance):\n    \"\"\"Add new trading account\"\"\"\n    try:\n        account = Account(\n            brokerage_id=brokerage_id,\n            account_name=account_name,\n            account_type=account_type,\n            total_balance=initial_balance,\n            cash_balance=initial_balance,\n            is_active=True\n        )\n        session.add(account)\n        session.commit()\n    except Exception as e:\n        session.rollback()\n        raise e\n","size_bytes":23616},"app_pages/trading_engine_control.py":{"content":"import streamlit as st\nimport time\nfrom datetime import datetime\nfrom services.trading_engine import TradingEngine\nfrom database.database import get_session\nfrom database.models import EnvironmentVariable, Order, TransactionLog\nfrom utils.auth import check_permission\n\ndef show_trading_engine_control():\n    \"\"\"Trading Engine Control Panel\"\"\"\n    \n    # Check authentication\n    if not st.session_state.get('authenticated', False):\n        st.error(\"ðŸš« Please log in to access this page.\")\n        return\n    \n    user = st.session_state.user\n    \n    # Only admin and trader roles can control the trading engine\n    if not check_permission(user, 'trader'):\n        st.error(\"ðŸš« Access denied. Trading engine control requires trader privileges or higher.\")\n        return\n    \n    st.title(\"ðŸ¤– Automated Trading Engine Control\")\n    \n    # Initialize trading engine in session state\n    if 'trading_engine' not in st.session_state:\n        st.session_state.trading_engine = None\n    if 'engine_status' not in st.session_state:\n        st.session_state.engine_status = \"Stopped\"\n    \n    # Current status\n    col1, col2, col3 = st.columns(3)\n    \n    with col1:\n        status_color = \"ðŸŸ¢\" if st.session_state.engine_status == \"Running\" else \"ðŸ”´\"\n        st.metric(\"Engine Status\", f\"{status_color} {st.session_state.engine_status}\")\n    \n    with col2:\n        session = get_session()\n        try:\n            trading_mode = session.query(EnvironmentVariable).filter(\n                EnvironmentVariable.key == 'TRADING_MODE'\n            ).first()\n            mode = trading_mode.value if trading_mode else 'paper'\n            st.metric(\"Trading Mode\", mode.title())\n        finally:\n            session.close()\n    \n    with col3:\n        # Count recent orders\n        session = get_session()\n        try:\n            recent_orders = session.query(Order).filter(\n                Order.created_at >= datetime.now().replace(hour=0, minute=0, second=0)\n            ).count()\n            st.metric(\"Orders Today\", recent_orders)\n        finally:\n            session.close()\n    \n    st.markdown(\"---\")\n    \n    # What is the Trading Engine?\n    with st.expander(\"â„¹ï¸ What is the Trading Engine?\", expanded=False):\n        st.markdown(\"\"\"\n        **The Trading Engine is the \"brain\" of your algorithmic trading system that:**\n        \n        **ðŸ”„ Continuously Monitors:**\n        - Stock prices every 30 seconds (configurable)\n        - Technical indicators (moving averages, momentum)\n        - Your existing positions and cash balance\n        \n        **ðŸŽ¯ Makes Trading Decisions:**\n        - Identifies stocks with strong momentum (priority stocks)\n        - Places buy orders when prices are trending up\n        - Places sell orders when momentum slows or reverses\n        - Buys call options when stocks are rising strongly\n        - Buys put options when stocks are falling strongly\n        \n        **âš¡ Executes Automatically:**\n        - Sends orders to your broker (Alpaca, RobinHood, etc.)\n        - Manages position sizes (uses only 2-5% of your cash per trade)\n        - Respects day trading limits\n        - Calculates gains/losses and updates your account balance\n        \n        **ðŸ›¡ï¸ Risk Management:**\n        - Never risks more than set percentage of your account\n        - Follows your broker's day trading rules\n        - Uses offsetting options to lock in gains when needed\n        - Stops trading if there are connection issues\n        \"\"\")\n    \n    # Engine Controls\n    st.subheader(\"ðŸŽ® Engine Controls\")\n    \n    col1, col2, col3 = st.columns(3)\n    \n    with col1:\n        is_running = st.session_state.get('engine_status', 'Stopped') == \"Running\"\n        if st.button(\"â–¶ï¸ Start Trading Engine\", disabled=is_running):\n            try:\n                st.session_state.trading_engine = TradingEngine()\n                st.session_state.trading_engine.start_trading()\n                st.session_state.engine_status = \"Running\"\n                st.success(\"âœ… Trading engine started successfully!\")\n                st.info(\"The engine is now monitoring markets and will place trades automatically based on your algorithms.\")\n                st.rerun()\n            except Exception as e:\n                st.error(f\"âŒ Failed to start trading engine: {e}\")\n    \n    with col2:\n        is_stopped = st.session_state.get('engine_status', 'Stopped') == \"Stopped\"\n        if st.button(\"â¹ï¸ Stop Trading Engine\", disabled=is_stopped):\n            try:\n                if st.session_state.get('trading_engine'):\n                    st.session_state.trading_engine.stop_trading()\n                    st.session_state.trading_engine = None\n                st.session_state.engine_status = \"Stopped\"\n                st.success(\"âœ… Trading engine stopped successfully!\")\n                st.info(\"All automated trading has been halted. Manual trading is still available.\")\n                st.rerun()\n            except Exception as e:\n                st.error(f\"âŒ Failed to stop trading engine: {e}\")\n    \n    with col3:\n        if st.button(\"ðŸ”„ Restart Engine\"):\n            try:\n                # Stop first\n                if st.session_state.get('trading_engine'):\n                    st.session_state.trading_engine.stop_trading()\n                \n                # Start fresh\n                st.session_state.trading_engine = TradingEngine()\n                st.session_state.trading_engine.start_trading()\n                st.session_state.engine_status = \"Running\"\n                st.success(\"âœ… Trading engine restarted successfully!\")\n                st.rerun()\n            except Exception as e:\n                st.error(f\"âŒ Failed to restart trading engine: {e}\")\n    \n    st.markdown(\"---\")\n    \n    # Engine Configuration\n    st.subheader(\"âš™ï¸ Engine Configuration\")\n    \n    session = get_session()\n    try:\n        # Get current configuration\n        config_vars = session.query(EnvironmentVariable).filter(\n            EnvironmentVariable.key.in_([\n                'PRICE_UPDATE_INTERVAL',\n                'MAX_POSITION_SIZE_PERCENT', \n                'PRIORITY_EVALUATION_PERIODS',\n                'TECHNICAL_ANALYSIS_PERIODS'\n            ])\n        ).all()\n        \n        config_dict = {var.key: var.value for var in config_vars}\n        \n        col1, col2 = st.columns(2)\n        \n        with col1:\n            price_interval = st.number_input(\n                \"Price Update Interval (seconds)\",\n                min_value=10,\n                max_value=300,\n                value=int(config_dict.get('PRICE_UPDATE_INTERVAL', 30)),\n                help=\"How often the engine checks stock prices\"\n            )\n            \n            max_position = st.number_input(\n                \"Max Position Size (%)\",\n                min_value=1.0,\n                max_value=10.0,\n                value=float(config_dict.get('MAX_POSITION_SIZE_PERCENT', 5.0)),\n                help=\"Maximum percentage of account to use per trade\"\n            )\n        \n        with col2:\n            eval_periods = st.number_input(\n                \"Evaluation Periods\",\n                min_value=2,\n                max_value=10,\n                value=int(config_dict.get('PRIORITY_EVALUATION_PERIODS', 3)),\n                help=\"Number of price periods to analyze for momentum\"\n            )\n            \n            ta_periods = st.number_input(\n                \"Technical Analysis Periods\",\n                min_value=10,\n                max_value=50,\n                value=int(config_dict.get('TECHNICAL_ANALYSIS_PERIODS', 20)),\n                help=\"Moving average period for technical analysis\"\n            )\n        \n        if st.button(\"ðŸ’¾ Save Configuration\"):\n            # Update configuration\n            updates = {\n                'PRICE_UPDATE_INTERVAL': str(price_interval),\n                'MAX_POSITION_SIZE_PERCENT': str(max_position),\n                'PRIORITY_EVALUATION_PERIODS': str(eval_periods),\n                'TECHNICAL_ANALYSIS_PERIODS': str(ta_periods)\n            }\n            \n            for key, value in updates.items():\n                env_var = session.query(EnvironmentVariable).filter(\n                    EnvironmentVariable.key == key\n                ).first()\n                \n                if env_var:\n                    env_var.value = value\n                else:\n                    env_var = EnvironmentVariable(key=key, value=value)\n                    session.add(env_var)\n            \n            session.commit()\n            st.success(\"âœ… Configuration saved! Restart the engine to apply changes.\")\n    \n    finally:\n        session.close()\n    \n    # Recent Activity\n    st.subheader(\"ðŸ“Š Recent Trading Activity\")\n    \n    session = get_session()\n    try:\n        # Recent orders\n        recent_orders = session.query(Order).order_by(Order.created_at.desc()).limit(10).all()\n        \n        if recent_orders:\n            order_data = []\n            for order in recent_orders:\n                order_data.append({\n                    'Time': order.created_at.strftime('%H:%M:%S'),\n                    'Symbol': order.symbol,\n                    'Action': order.action.title(),\n                    'Quantity': order.quantity,\n                    'Price': f\"${order.limit_price:.2f}\" if order.limit_price else \"Market\",\n                    'Status': order.status.title()\n                })\n            \n            st.dataframe(order_data, use_container_width=True)\n        else:\n            st.info(\"No recent orders. Start the trading engine to begin automated trading.\")\n    \n    finally:\n        session.close()\n    \n    # Warning messages\n    if st.session_state.get('engine_status', 'Stopped') == \"Running\":\n        st.warning(\"âš ï¸ **IMPORTANT:** The trading engine is actively placing real trades. Monitor your account regularly.\")\n    \n    if user.role == 'admin':\n        st.info(\"ðŸ‘¨â€ðŸ’¼ **Admin Note:** You can view all system logs and trading activity in the Database Admin section.\")","size_bytes":10009},"services/technical_indicators.py":{"content":"import numpy as np\nimport pandas as pd\nfrom typing import Tuple, List\n\nclass TechnicalIndicators:\n    \"\"\"Calculate technical indicators for algorithmic trading\"\"\"\n    \n    @staticmethod\n    def calculate_sma(prices: np.array, period: int = 20) -> np.array:\n        \"\"\"Calculate Simple Moving Average\"\"\"\n        return pd.Series(prices).rolling(window=period).mean().values\n    \n    @staticmethod\n    def calculate_std(prices: np.array, period: int = 20) -> np.array:\n        \"\"\"Calculate Standard Deviation\"\"\"\n        return pd.Series(prices).rolling(window=period).std().values\n    \n    @staticmethod\n    def calculate_adx_dmi(high: np.array, low: np.array, close: np.array, period: int = 14) -> Tuple[np.array, np.array, np.array]:\n        \"\"\"\n        Calculate Wilder's Directional Movement Index (DMI) and Average Directional Index (ADX)\n        Returns: (ADX, DI+, DI-)\n        \"\"\"\n        # Manual ADX and DMI calculation\n        df = pd.DataFrame({'high': high, 'low': low, 'close': close})\n        \n        # Calculate True Range\n        df['tr1'] = df['high'] - df['low']\n        df['tr2'] = abs(df['high'] - df['close'].shift(1))\n        df['tr3'] = abs(df['low'] - df['close'].shift(1))\n        df['tr'] = df[['tr1', 'tr2', 'tr3']].max(axis=1)\n        \n        # Calculate Directional Movement\n        df['dm_plus'] = np.where(\n            (df['high'] - df['high'].shift(1)) > (df['low'].shift(1) - df['low']),\n            np.maximum(df['high'] - df['high'].shift(1), 0), 0\n        )\n        df['dm_minus'] = np.where(\n            (df['low'].shift(1) - df['low']) > (df['high'] - df['high'].shift(1)),\n            np.maximum(df['low'].shift(1) - df['low'], 0), 0\n        )\n        \n        # Smooth the values using Wilder's smoothing\n        alpha = 1.0 / period\n        df['tr_smooth'] = df['tr'].ewm(alpha=alpha, adjust=False).mean()\n        df['dm_plus_smooth'] = df['dm_plus'].ewm(alpha=alpha, adjust=False).mean()\n        df['dm_minus_smooth'] = df['dm_minus'].ewm(alpha=alpha, adjust=False).mean()\n        \n        # Calculate DI+ and DI-\n        df['di_plus'] = 100 * df['dm_plus_smooth'] / df['tr_smooth']\n        df['di_minus'] = 100 * df['dm_minus_smooth'] / df['tr_smooth']\n        \n        # Calculate DX and ADX\n        df['dx'] = 100 * abs(df['di_plus'] - df['di_minus']) / (df['di_plus'] + df['di_minus'])\n        df['adx'] = df['dx'].ewm(alpha=alpha, adjust=False).mean()\n        \n        return df['adx'].values, df['di_plus'].values, df['di_minus'].values\n    \n    @staticmethod\n    def calculate_pivot_points(high: float, low: float, close: float) -> dict:\n        \"\"\"\n        Calculate Pivot Points and Support/Resistance levels\n        \"\"\"\n        pivot = (high + low + close) / 3\n        \n        # Standard Pivot Points\n        r1 = (2 * pivot) - low\n        r2 = pivot + (high - low)\n        s1 = (2 * pivot) - high\n        s2 = pivot - (high - low)\n        \n        return {\n            'pivot_point': pivot,\n            'resistance_1': r1,\n            'resistance_2': r2,\n            'support_1': s1,\n            'support_2': s2\n        }\n    \n    @staticmethod\n    def calculate_cci(high: np.array, low: np.array, close: np.array, period: int = 14) -> np.array:\n        \"\"\"\n        Calculate Commodity Channel Index (CCI)\n        CCI = (Price - MA) / (0.015 * D)\n        where Price = (High + Low + Close) / 3\n        \"\"\"\n        # Calculate typical price\n        tp = (high + low + close) / 3\n        # Calculate simple moving average of typical price\n        tp_ma = pd.Series(tp).rolling(window=period).mean()\n        # Calculate mean deviation\n        mad = pd.Series(tp).rolling(window=period).apply(lambda x: np.mean(np.abs(x - x.mean())))\n        # Calculate CCI\n        cci = (tp - tp_ma) / (0.015 * mad)\n        return cci.values\n    \n    @staticmethod\n    def calculate_stochastic(high: np.array, low: np.array, close: np.array, \n                           k_period: int = 14, d_period: int = 3) -> Tuple[np.array, np.array]:\n        \"\"\"\n        Calculate Stochastic Oscillator\n        %K = 100 * (C - L14) / (H14 - L14)\n        %D = 3-period moving average of %K\n        \"\"\"\n        df = pd.DataFrame({'high': high, 'low': low, 'close': close})\n        \n        # Calculate %K\n        df['lowest_low'] = df['low'].rolling(window=k_period).min()\n        df['highest_high'] = df['high'].rolling(window=k_period).max()\n        df['stoch_k'] = 100 * (df['close'] - df['lowest_low']) / (df['highest_high'] - df['lowest_low'])\n        \n        # Calculate %D (SMA of %K)\n        df['stoch_d'] = df['stoch_k'].rolling(window=d_period).mean()\n        \n        return df['stoch_k'].values, df['stoch_d'].values\n    \n    @staticmethod\n    def calculate_bollinger_bands(close: np.array, period: int = 20, std_dev: int = 2) -> Tuple[np.array, np.array, np.array]:\n        \"\"\"Calculate Bollinger Bands\"\"\"\n        middle = pd.Series(close).rolling(window=period).mean()\n        std = pd.Series(close).rolling(window=period).std()\n        upper = middle + (std * std_dev)\n        lower = middle - (std * std_dev)\n        return upper.values, middle.values, lower.values\n    \n    @staticmethod\n    def calculate_rsi(close: np.array, period: int = 14) -> np.array:\n        \"\"\"Calculate Relative Strength Index\"\"\"\n        delta = pd.Series(close).diff()\n        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()\n        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()\n        rs = gain / loss\n        rsi = 100 - (100 / (1 + rs))\n        return rsi.values\n    \n    @staticmethod\n    def calculate_macd(close: np.array, fast_period: int = 12, slow_period: int = 26, signal_period: int = 9) -> Tuple[np.array, np.array, np.array]:\n        \"\"\"Calculate MACD\"\"\"\n        ema_fast = pd.Series(close).ewm(span=fast_period).mean()\n        ema_slow = pd.Series(close).ewm(span=slow_period).mean()\n        macd = ema_fast - ema_slow\n        macd_signal = macd.ewm(span=signal_period).mean()\n        macd_hist = macd - macd_signal\n        return macd.values, macd_signal.values, macd_hist.values\n    \n    @staticmethod\n    def identify_priority_stocks(df: pd.DataFrame, symbol: str) -> bool:\n        \"\"\"\n        Identify if a stock should be priority based on criteria:\n        - Closing price > 1 std dev above/below 20-day MA\n        - Closing price > $5\n        \"\"\"\n        if len(df) < 20:\n            return False\n        \n        latest = df.iloc[-1]\n        close_price = latest['Close']\n        \n        # Must be above $5\n        if close_price <= 5:\n            return False\n        \n        # Calculate 20-day SMA and standard deviation\n        sma_20 = TechnicalIndicators.calculate_sma(df['Close'].values, 20)\n        std_20 = TechnicalIndicators.calculate_std(df['Close'].values, 20)\n        \n        if len(sma_20) == 0 or len(std_20) == 0:\n            return False\n        \n        latest_sma = sma_20[-1]\n        latest_std = std_20[-1]\n        \n        # Check if price is more than 1 std dev away from SMA\n        upper_threshold = latest_sma + latest_std\n        lower_threshold = latest_sma - latest_std\n        \n        return close_price > upper_threshold or close_price < lower_threshold\n    \n    @staticmethod\n    def calculate_all_indicators(df: pd.DataFrame) -> pd.DataFrame:\n        \"\"\"\n        Calculate all technical indicators for a DataFrame with OHLCV data\n        \"\"\"\n        if len(df) < 20:  # Need minimum data for calculations\n            return df\n        \n        # Convert to numpy arrays\n        high = df['High'].values\n        low = df['Low'].values\n        close = df['Close'].values\n        \n        # Calculate indicators\n        df['SMA_20'] = TechnicalIndicators.calculate_sma(close, 20)\n        df['STD_20'] = TechnicalIndicators.calculate_std(close, 20)\n        \n        # ADX and DMI\n        adx, di_plus, di_minus = TechnicalIndicators.calculate_adx_dmi(high, low, close)\n        df['ADX'] = adx\n        df['DI_Plus'] = di_plus\n        df['DI_Minus'] = di_minus\n        \n        # CCI\n        df['CCI'] = TechnicalIndicators.calculate_cci(high, low, close)\n        \n        # Stochastic\n        stoch_k, stoch_d = TechnicalIndicators.calculate_stochastic(high, low, close)\n        df['Stoch_K'] = stoch_k\n        df['Stoch_D'] = stoch_d\n        \n        # Calculate pivot points for each row\n        pivot_data = []\n        for _, row in df.iterrows():\n            pivots = TechnicalIndicators.calculate_pivot_points(row['High'], row['Low'], row['Close'])\n            pivot_data.append(pivots)\n        \n        pivot_df = pd.DataFrame(pivot_data)\n        df['Pivot_Point'] = pivot_df['pivot_point']\n        df['Resistance_1'] = pivot_df['resistance_1']\n        df['Resistance_2'] = pivot_df['resistance_2']\n        df['Support_1'] = pivot_df['support_1']\n        df['Support_2'] = pivot_df['support_2']\n        \n        # Additional indicators\n        df['RSI'] = TechnicalIndicators.calculate_rsi(close)\n        \n        # Bollinger Bands\n        bb_upper, bb_middle, bb_lower = TechnicalIndicators.calculate_bollinger_bands(close)\n        df['BB_Upper'] = bb_upper\n        df['BB_Middle'] = bb_middle\n        df['BB_Lower'] = bb_lower\n        \n        # MACD\n        macd, macd_signal, macd_hist = TechnicalIndicators.calculate_macd(close)\n        df['MACD'] = macd\n        df['MACD_Signal'] = macd_signal\n        df['MACD_Hist'] = macd_hist\n        \n        return df\n    \n    @staticmethod\n    def detect_price_momentum(prices: List[float], periods: int = 3) -> str:\n        \"\"\"\n        Detect price momentum direction\n        Returns: 'up', 'down', 'sideways'\n        \"\"\"\n        if len(prices) < periods + 1:\n            return 'sideways'\n        \n        recent_prices = prices[-periods-1:]\n        changes = [recent_prices[i+1] - recent_prices[i] for i in range(len(recent_prices)-1)]\n        \n        positive_changes = sum(1 for change in changes if change > 0)\n        negative_changes = sum(1 for change in changes if change < 0)\n        \n        if positive_changes == len(changes):\n            return 'up'\n        elif negative_changes == len(changes):\n            return 'down'\n        else:\n            return 'sideways'\n    \n    @staticmethod\n    def calculate_price_change_percentage(current_price: float, previous_price: float) -> float:\n        \"\"\"Calculate percentage change between two prices\"\"\"\n        if previous_price == 0:\n            return 0.0\n        return ((current_price - previous_price) / previous_price) * 100\n    \n    @staticmethod\n    def is_overbought_oversold(rsi: float, stoch_k: float, stoch_d: float) -> str:\n        \"\"\"\n        Determine if asset is overbought, oversold, or neutral\n        \"\"\"\n        overbought_signals = 0\n        oversold_signals = 0\n        \n        # RSI signals\n        if rsi > 70:\n            overbought_signals += 1\n        elif rsi < 30:\n            oversold_signals += 1\n        \n        # Stochastic signals\n        if stoch_k > 80 and stoch_d > 80:\n            overbought_signals += 1\n        elif stoch_k < 20 and stoch_d < 20:\n            oversold_signals += 1\n        \n        if overbought_signals >= 1:\n            return 'overbought'\n        elif oversold_signals >= 1:\n            return 'oversold'\n        else:\n            return 'neutral'\n    \n    @staticmethod\n    def calculate_support_resistance_levels(df: pd.DataFrame, lookback: int = 20) -> dict:\n        \"\"\"\n        Calculate dynamic support and resistance levels\n        \"\"\"\n        if len(df) < lookback:\n            return {'support': 0, 'resistance': 0}\n        \n        recent_data = df.tail(lookback)\n        \n        # Find local maxima and minima\n        highs = recent_data['High'].values\n        lows = recent_data['Low'].values\n        \n        resistance = np.max(highs)\n        support = np.min(lows)\n        \n        return {\n            'support': support,\n            'resistance': resistance,\n            'range_percent': ((resistance - support) / support) * 100\n        }\n","size_bytes":11939},"app_pages/database_admin.py":{"content":"\"\"\"\nDatabase Administration page to showcase the comprehensive database structure\nand test database functionality as per exact specifications.\n\"\"\"\n\nimport streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\nfrom database.database import get_session\nfrom database.models import (\n    EnvironmentVariable, BrokerageInfo, Account, Stock, StockPriceHistory,\n    PriorityCurrentPrice, PriorityArchivePrice, Order, TransactionLog, User\n)\nfrom services.database_service import DatabaseService\n\ndef render_database_admin_page():\n    \"\"\"Database Administration interface\"\"\"\n    \n    st.title(\"ðŸ—„ï¸ Database Administration\")\n    st.markdown(\"*Comprehensive database management and testing interface*\")\n    \n    # Authentication check\n    if 'user' not in st.session_state or not st.session_state.user or st.session_state.user.role != 'admin':\n        st.error(\"ðŸš« Access denied. Admin privileges required.\")\n        return\n    \n    session = get_session()\n    db_service = DatabaseService(session)\n    \n    # Create tabs for different database operations\n    tab1, tab2, tab3, tab4, tab5 = st.tabs([\n        \"ðŸ“Š Database Overview\", \n        \"âš™ï¸ Environment Variables\", \n        \"ðŸ¦ Brokerages & Accounts\",\n        \"ðŸ“ˆ Stock Management\",\n        \"ðŸ”„ Priority System\"\n    ])\n    \n    with tab1:\n        render_database_overview(session, db_service)\n    \n    with tab2:\n        render_environment_variables(session)\n    \n    with tab3:\n        render_brokerages_accounts(session)\n    \n    with tab4:\n        render_stock_management(session)\n    \n    with tab5:\n        render_priority_system(session, db_service)\n    \n    session.close()\n\ndef render_database_overview(session, db_service):\n    \"\"\"Database overview and statistics\"\"\"\n    \n    st.subheader(\"ðŸ“Š Database Statistics\")\n    \n    # Get comprehensive stats\n    stats = db_service.get_database_stats()\n    \n    # Create metrics display\n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        st.metric(\"Environment Variables\", stats['environment_variables'])\n        st.metric(\"Total Stocks\", stats['stocks_total'])\n    \n    with col2:\n        st.metric(\"Priority Stocks\", stats['stocks_priority_1'])\n        st.metric(\"Sector ETFs\", stats['stocks_sector_etf'])\n    \n    with col3:\n        st.metric(\"Current Price Records\", stats['priority_current_prices'])\n        st.metric(\"Archive Price Records\", stats['priority_archive_prices'])\n    \n    with col4:\n        st.metric(\"Total Orders\", stats['orders_total'])\n        st.metric(\"Pending Orders\", stats['orders_pending'])\n    \n    st.divider()\n    \n    # Tables overview\n    st.subheader(\"ðŸ“‹ Table Structure Overview\")\n    \n    table_info = [\n        {\"Table\": \"environment_variables\", \"Purpose\": \"Global trading configuration parameters\", \"Key Features\": \"Trading mode, broker settings, risk parameters\"},\n        {\"Table\": \"brokerage_info\", \"Purpose\": \"Broker credentials and fee structures\", \"Key Features\": \"RobinHood, Alpaca support with trading fees\"},\n        {\"Table\": \"accounts\", \"Purpose\": \"Individual trading accounts per brokerage\", \"Key Features\": \"Balance tracking, account types\"},\n        {\"Table\": \"stocks\", \"Purpose\": \"S&P 500 stocks + sector ETFs with priority system\", \"Key Features\": \"Priority ranking (0=normal, 1=priority, 9=ETF)\"},\n        {\"Table\": \"stock_price_history\", \"Purpose\": \"90-day historical data with technical indicators\", \"Key Features\": \"ADX, DMI, pivot points, Bollinger bands, CCI\"},\n        {\"Table\": \"priority_current_price\", \"Purpose\": \"Real-time tracking for priority stocks\", \"Key Features\": \"Updated every X seconds, bid/ask spreads\"},\n        {\"Table\": \"priority_archive_price\", \"Purpose\": \"Daily archive of priority price data\", \"Key Features\": \"Moved daily, purged after X days\"},\n        {\"Table\": \"orders\", \"Purpose\": \"Complete order lifecycle tracking\", \"Key Features\": \"Stocks + options, LIFO calculations\"},\n        {\"Table\": \"transaction_log\", \"Purpose\": \"LIFO gain/loss tracking\", \"Key Features\": \"Tax reporting, wash sale detection\"}\n    ]\n    \n    st.dataframe(pd.DataFrame(table_info), use_container_width=True)\n\ndef render_environment_variables(session):\n    \"\"\"Environment variables management\"\"\"\n    \n    st.subheader(\"âš™ï¸ Environment Variables\")\n    \n    # Display current variables\n    env_vars = session.query(EnvironmentVariable).order_by(EnvironmentVariable.key).all()\n    \n    if env_vars:\n        # Create DataFrame for display\n        env_data = []\n        for var in env_vars:\n            env_data.append({\n                \"Key\": var.key,\n                \"Value\": var.value,\n                \"Type\": var.variable_type,\n                \"System\": \"âœ“\" if var.is_system else \"\",\n                \"Description\": (var.description[:50] + \"...\" if var.description and len(var.description) > 50 else (var.description or \"N/A\"))\n            })\n        \n        df = pd.DataFrame(env_data)\n        st.dataframe(df, use_container_width=True, height=400)\n        \n        st.divider()\n        \n        # Key environment variables for trading\n        st.subheader(\"ðŸ”§ Key Trading Parameters\")\n        \n        col1, col2 = st.columns(2)\n        \n        with col1:\n            trading_mode = next((v.value for v in env_vars if v.key == \"TRADING_MODE\"), \"paper\")\n            active_broker = next((v.value for v in env_vars if v.key == \"ACTIVE_BROKER\"), \"Alpaca\")\n            \n            st.info(f\"**Trading Mode:** {trading_mode}\")\n            st.info(f\"**Active Broker:** {active_broker}\")\n        \n        with col2:\n            price_interval = next((v.value for v in env_vars if v.key == \"PRICE_UPDATE_INTERVAL\"), \"30\")\n            pct_target = next((v.value for v in env_vars if v.key == \"PRIORITY_PERCENTAGE_TARGET\"), \"2.5\")\n            \n            st.info(f\"**Price Update Interval:** {price_interval} seconds\")\n            st.info(f\"**Priority Threshold:** {pct_target}%\")\n\ndef render_brokerages_accounts(session):\n    \"\"\"Brokerages and accounts management\"\"\"\n    \n    st.subheader(\"ðŸ¦ Brokerage Information\")\n    \n    # Display brokerages\n    brokers = session.query(BrokerageInfo).all()\n    \n    if brokers:\n        broker_data = []\n        for broker in brokers:\n            broker_data.append({\n                \"Name\": broker.name,\n                \"API URL\": broker.api_url,\n                \"Fees/Share\": f\"${float(broker.trading_fees_per_share):.4f}\",\n                \"Fees/Contract\": f\"${float(broker.trading_fees_per_contract):.2f}\",\n                \"Day Trade Limit\": broker.day_trade_limit,\n                \"Options\": \"âœ“\" if broker.supports_options else \"âœ—\",\n                \"Crypto\": \"âœ“\" if broker.supports_crypto else \"âœ—\",\n                \"Active\": \"âœ“\" if broker.is_active else \"âœ—\"\n            })\n        \n        st.dataframe(pd.DataFrame(broker_data), use_container_width=True)\n    \n    st.divider()\n    \n    # Display accounts\n    st.subheader(\"ðŸ’³ Trading Accounts\")\n    \n    accounts = session.query(Account).join(BrokerageInfo).all()\n    \n    if accounts:\n        account_data = []\n        for account in accounts:\n            account_data.append({\n                \"Brokerage\": account.brokerage.name,\n                \"Account Name\": account.account_name,\n                \"Type\": account.account_type.title(),\n                \"Total Balance\": f\"${account.total_balance:,.2f}\",\n                \"Cash Balance\": f\"${account.cash_balance:,.2f}\",\n                \"Active\": \"âœ“\" if account.is_active else \"âœ—\"\n            })\n        \n        st.dataframe(pd.DataFrame(account_data), use_container_width=True)\n\ndef render_stock_management(session):\n    \"\"\"Stock management interface\"\"\"\n    \n    st.subheader(\"ðŸ“ˆ Stock Management\")\n    \n    # Stock summary by priority\n    col1, col2, col3 = st.columns(3)\n    \n    with col1:\n        normal_stocks = session.query(Stock).filter(Stock.priority == 0).count()\n        st.metric(\"S&P 500 Stocks (Priority 0)\", normal_stocks)\n    \n    with col2:\n        priority_stocks = session.query(Stock).filter(Stock.priority == 1).count()\n        st.metric(\"Priority Stocks (Priority 1)\", priority_stocks)\n    \n    with col3:\n        etf_stocks = session.query(Stock).filter(Stock.priority == 9).count()\n        st.metric(\"Sector ETFs (Priority 9)\", etf_stocks)\n    \n    st.divider()\n    \n    st.info(\"ðŸ“‹ **Stock Universe**: S&P 500 companies with actively traded options + Sector ETFs\")\n    \n    # Display stocks by category\n    category = st.selectbox(\"Select Category\", [\"All Stocks\", \"Priority Stocks (1)\", \"Sector ETFs (9)\", \"Normal S&P 500 (0)\"])\n    \n    if category == \"All Stocks\":\n        stocks = session.query(Stock).order_by(Stock.priority.desc(), Stock.symbol).all()\n    elif category == \"Priority Stocks (1)\":\n        stocks = session.query(Stock).filter(Stock.priority == 1).order_by(Stock.symbol).all()\n    elif category == \"Sector ETFs (9)\":\n        stocks = session.query(Stock).filter(Stock.priority == 9).order_by(Stock.symbol).all()\n    else:  # Normal S&P 500 (0)\n        stocks = session.query(Stock).filter(Stock.priority == 0).order_by(Stock.symbol).all()\n    \n    if stocks:\n        stock_data = []\n        for stock in stocks:\n            stock_data.append({\n                \"Symbol\": stock.symbol,\n                \"Name\": stock.name,\n                \"Sector\": stock.sector,\n                \"Priority\": stock.priority,\n                \"Last Price\": f\"${float(stock.last_price):.2f}\" if stock.last_price else \"N/A\",\n                \"Change %\": f\"{float(stock.change_percent):.2f}%\" if stock.change_percent else \"N/A\",\n                \"Has Options\": \"âœ“\" if stock.has_options else \"âœ—\",\n                \"Market Cap\": f\"${stock.market_cap:,.0f}\" if stock.market_cap else \"N/A\"\n            })\n        \n        st.dataframe(pd.DataFrame(stock_data), use_container_width=True, height=400)\n\ndef render_priority_system(session, db_service):\n    \"\"\"Priority system management and testing\"\"\"\n    \n    st.subheader(\"ðŸ”„ Priority System Management\")\n    \n    # Priority system operations\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        if st.button(\"ðŸ”„ Update Stock Priorities\", help=\"Recalculate priorities based on 20-day MA and volatility\"):\n            with st.spinner(\"Updating stock priorities...\"):\n                try:\n                    updated_count = db_service.update_stock_priorities()\n                    st.success(f\"âœ… Updated priorities for {updated_count} stocks\")\n                except Exception as e:\n                    st.error(f\"âŒ Error updating priorities: {e}\")\n        \n        if st.button(\"ðŸ“Š Update Priority Prices\", help=\"Add current price records for priority stocks\"):\n            with st.spinner(\"Updating priority prices...\"):\n                try:\n                    updated_count = db_service.update_priority_current_prices()\n                    st.success(f\"âœ… Updated {updated_count} priority price records\")\n                except Exception as e:\n                    st.error(f\"âŒ Error updating prices: {e}\")\n    \n    with col2:\n        if st.button(\"ðŸ“¦ Archive Old Prices\", help=\"Move yesterday's prices to archive\"):\n            with st.spinner(\"Archiving old prices...\"):\n                try:\n                    archived_count = db_service.archive_priority_prices()\n                    st.success(f\"âœ… Archived {archived_count} price records\")\n                except Exception as e:\n                    st.error(f\"âŒ Error archiving: {e}\")\n        \n        if st.button(\"ðŸ—‘ï¸ Purge Old Archives\", help=\"Remove archive data older than retention period\"):\n            with st.spinner(\"Purging old archives...\"):\n                try:\n                    purged_count = db_service.purge_old_archive_data()\n                    st.success(f\"âœ… Purged {purged_count} old archive records\")\n                except Exception as e:\n                    st.error(f\"âŒ Error purging: {e}\")\n    \n    st.divider()\n    \n    # Trading opportunities analysis\n    st.subheader(\"ðŸŽ¯ Trading Opportunities\")\n    \n    if st.button(\"ðŸ” Evaluate Trading Opportunities\"):\n        with st.spinner(\"Analyzing trading opportunities...\"):\n            try:\n                opportunities = db_service.evaluate_trading_opportunities()\n                \n                if opportunities:\n                    opp_data = []\n                    for opp in opportunities:\n                        opp_data.append({\n                            \"Symbol\": opp['symbol'],\n                            \"Action\": opp['action'].upper(),\n                            \"Current Price\": f\"${opp['current_price']:.2f}\",\n                            \"Momentum\": f\"{opp['momentum']:.2f}%\",\n                            \"Confidence\": f\"{opp['confidence']:.1f}%\"\n                        })\n                    \n                    st.dataframe(pd.DataFrame(opp_data), use_container_width=True)\n                else:\n                    st.info(\"No trading opportunities found at this time.\")\n                    \n            except Exception as e:\n                st.error(f\"âŒ Error evaluating opportunities: {e}\")\n    \n    # Recent priority price activity\n    st.divider()\n    st.subheader(\"ðŸ“ˆ Recent Priority Price Activity\")\n    \n    recent_prices = session.query(PriorityCurrentPrice).order_by(\n        PriorityCurrentPrice.datetime.desc()\n    ).limit(20).all()\n    \n    if recent_prices:\n        price_data = []\n        for price in recent_prices:\n            price_data.append({\n                \"Symbol\": price.symbol,\n                \"DateTime\": price.datetime.strftime(\"%Y-%m-%d %H:%M:%S\"),\n                \"Current Price\": f\"${float(price.current_price):.2f}\" if price.current_price is not None else \"N/A\",\n                \"Change from Previous\": f\"{float(price.percent_change_from_previous):.2f}%\" if price.percent_change_from_previous is not None else \"N/A\",\n                \"Change from Open\": f\"{float(price.percent_change_from_open):.2f}%\" if price.percent_change_from_open is not None else \"N/A\",\n                \"Volume\": f\"{price.volume:,}\" if price.volume else \"N/A\"\n            })\n        \n        st.dataframe(pd.DataFrame(price_data), use_container_width=True, height=300)\n    else:\n        st.info(\"No recent priority price data available.\")\n\nif __name__ == \"__main__\":\n    render_database_admin_page()","size_bytes":14260},"app_pages/portfolio.py":{"content":"import streamlit as st\nimport pandas as pd\nimport plotly.graph_objects as go\nimport plotly.express as px\nfrom datetime import datetime, timedelta\n\nfrom database.database import get_session\nfrom database.models import Stock, Order, TransactionLog, Account, User\nfrom services.broker_apis import BrokerManager\nfrom utils.helpers import (\n    format_currency, format_percentage, calculate_portfolio_value,\n    calculate_lifo_pnl, calculate_option_metrics, calculate_sector_allocation,\n    calculate_risk_metrics\n)\nfrom utils.auth import check_permission\nfrom utils.broker_status_widget import display_mini_broker_status\n\ndef show_portfolio_page():\n    \"\"\"Portfolio overview and analysis page\"\"\"\n    st.title(\"ðŸ’¼ Portfolio Management\")\n    \n    # Check user permissions - viewers can see portfolio but not trade\n    user = st.session_state.user\n    is_viewer = user.role == 'viewer'\n    \n    if is_viewer:\n        st.info(\"ðŸ‘ï¸ Viewing in read-only mode. Trading features are disabled for viewer accounts.\")\n    elif not check_permission(user, 'trader'):\n        st.error(\"ðŸš« Access denied. Portfolio access requires trader privileges or higher.\")\n        return\n    \n    # Mini broker status\n    is_connected = display_mini_broker_status()\n    if not is_connected:\n        st.warning(\"âš ï¸ Broker connection issues. Portfolio data may be limited.\")\n    \n    # Portfolio overview metrics\n    _show_portfolio_overview()\n    \n    # Current positions\n    st.subheader(\"ðŸ“Š Current Positions\")\n    _show_current_positions()\n    \n    # Performance analysis\n    st.subheader(\"ðŸ“ˆ Performance Analysis\")\n    _show_performance_analysis()\n    \n    # Risk metrics\n    st.subheader(\"âš ï¸ Risk Analysis\")\n    _show_risk_analysis()\n    \n    # Transaction history\n    st.subheader(\"ðŸ“‹ Transaction History\")\n    _show_transaction_history()\n\ndef _show_portfolio_overview():\n    \"\"\"Display portfolio overview metrics\"\"\"\n    session = get_session()\n    \n    # Use centralized broker manager\n    if 'broker_manager' not in st.session_state:\n        st.session_state.broker_manager = BrokerManager()\n    \n    broker_manager = st.session_state.broker_manager\n    \n    # Display current broker info\n    active_broker = broker_manager.get_active_broker_name()\n    st.info(f\"ðŸŽ¯ Data from: {active_broker}\")\n    \n    try:\n        # Get account information\n        account_info = broker_manager.get_account_info()\n        \n        # Get current positions\n        positions = broker_manager.get_positions()\n        \n        # Calculate metrics\n        portfolio_value = account_info.get('portfolio_value', 0)\n        cash_balance = account_info.get('cash', 0)\n        day_pnl = 0  # Would calculate from daily changes\n        total_pnl = 0  # Would calculate from cost basis\n        \n        # Display key metrics\n        col1, col2, col3, col4 = st.columns(4)\n        \n        with col1:\n            st.metric(\n                \"Portfolio Value\",\n                format_currency(portfolio_value),\n                delta=format_currency(day_pnl)\n            )\n        \n        with col2:\n            st.metric(\n                \"Cash Balance\",\n                format_currency(cash_balance),\n                delta=None\n            )\n        \n        with col3:\n            buying_power = account_info.get('buying_power', cash_balance)\n            st.metric(\n                \"Buying Power\",\n                format_currency(buying_power),\n                delta=None\n            )\n        \n        with col4:\n            num_positions = len(positions)\n            st.metric(\n                \"Active Positions\",\n                str(num_positions),\n                delta=None\n            )\n        \n        # Portfolio allocation chart\n        if positions:\n            _show_portfolio_allocation(positions)\n    \n    except Exception as e:\n        st.error(f\"Error loading portfolio overview: {e}\")\n    finally:\n        session.close()\n\ndef _show_portfolio_allocation(positions):\n    \"\"\"Show portfolio allocation pie chart\"\"\"\n    if not positions:\n        st.info(\"No positions to display\")\n        return\n    \n    # Prepare data for pie chart\n    symbols = []\n    values = []\n    \n    for position in positions:\n        symbols.append(position['symbol'])\n        values.append(abs(position['market_value']))\n    \n    # Create pie chart\n    fig = px.pie(\n        values=values,\n        names=symbols,\n        title=\"Portfolio Allocation by Position\"\n    )\n    \n    fig.update_traces(\n        textposition='inside',\n        textinfo='percent+label'\n    )\n    \n    st.plotly_chart(fig, use_container_width=True)\n\ndef _show_current_positions():\n    \"\"\"Display current portfolio positions\"\"\"\n    session = get_session()\n    broker_manager = BrokerManager()\n    \n    try:\n        # Get positions from broker\n        positions = broker_manager.get_positions()\n        \n        if not positions:\n            st.info(\"No current positions\")\n            return\n        \n        # Get current market data for P&L calculation\n        symbols = [pos['symbol'] for pos in positions]\n        market_data = broker_manager.get_market_data(symbols)\n        \n        # Prepare positions data\n        position_data = []\n        total_value = 0\n        total_pnl = 0\n        \n        for position in positions:\n            symbol = position['symbol']\n            quantity = position['quantity']\n            market_value = position['market_value']\n            cost_basis = position['cost_basis']\n            unrealized_pnl = position['unrealized_pnl']\n            \n            # Calculate percentage of portfolio\n            portfolio_percent = 0  # Would calculate based on total portfolio value\n            \n            # Get current price\n            current_price = market_data.get(symbol, {}).get('price', 0)\n            \n            position_data.append({\n                \"Symbol\": symbol,\n                \"Quantity\": quantity,\n                \"Current Price\": format_currency(current_price),\n                \"Market Value\": format_currency(market_value),\n                \"Cost Basis\": format_currency(cost_basis),\n                \"Unrealized P&L\": format_currency(unrealized_pnl),\n                \"% of Portfolio\": format_percentage(portfolio_percent),\n                \"Side\": position['side']\n            })\n            \n            total_value += market_value\n            total_pnl += unrealized_pnl\n        \n        # Display positions table\n        df = pd.DataFrame(position_data)\n        \n        # Apply styling\n        def color_pnl(val):\n            if 'P&L' in val or val.startswith('$'):\n                try:\n                    amount = float(val.replace('$', '').replace(',', ''))\n                    if amount > 0:\n                        return 'color: green'\n                    elif amount < 0:\n                        return 'color: red'\n                except:\n                    pass\n            return ''\n        \n        styled_df = df.style.map(color_pnl, subset=['Unrealized P&L'])\n        st.dataframe(styled_df, use_container_width=True)\n        \n        # Summary metrics\n        col1, col2 = st.columns(2)\n        with col1:\n            st.metric(\"Total Market Value\", format_currency(total_value))\n        with col2:\n            st.metric(\"Total Unrealized P&L\", format_currency(total_pnl))\n    \n    except Exception as e:\n        st.error(f\"Error loading positions: {e}\")\n    finally:\n        session.close()\n\ndef _show_performance_analysis():\n    \"\"\"Show portfolio performance analysis\"\"\"\n    session = get_session()\n    \n    try:\n        # Get transaction history for performance calculation\n        transactions = session.query(TransactionLog).order_by(TransactionLog.transaction_date).all()\n        \n        if not transactions:\n            st.info(\"No transaction history available for performance analysis\")\n            return\n        \n        # Calculate daily returns (simplified)\n        daily_returns = _calculate_daily_returns(transactions)\n        \n        if daily_returns:\n            # Calculate performance metrics\n            risk_metrics = calculate_risk_metrics(daily_returns)\n            \n            # Display metrics\n            col1, col2, col3, col4 = st.columns(4)\n            \n            with col1:\n                st.metric(\"Total Return\", format_percentage(risk_metrics.get('total_return', 0) * 100))\n            \n            with col2:\n                st.metric(\"Average Daily Return\", format_percentage(risk_metrics.get('average_return', 0) * 100))\n            \n            with col3:\n                st.metric(\"Volatility\", format_percentage(risk_metrics.get('volatility', 0) * 100))\n            \n            with col4:\n                st.metric(\"Sharpe Ratio\", f\"{risk_metrics.get('sharpe_ratio', 0):.2f}\")\n            \n            # Performance chart\n            _show_performance_chart(daily_returns)\n        else:\n            st.info(\"Insufficient data for performance analysis\")\n    \n    except Exception as e:\n        st.error(f\"Error in performance analysis: {e}\")\n    finally:\n        session.close()\n\ndef _calculate_daily_returns(transactions):\n    \"\"\"Calculate daily returns from transaction history\"\"\"\n    if not transactions:\n        return []\n    \n    # Group transactions by date\n    daily_pnl = {}\n    \n    for transaction in transactions:\n        date = transaction.transaction_date.date()\n        \n        if date not in daily_pnl:\n            daily_pnl[date] = 0\n        \n        # Simplified P&L calculation\n        if transaction.side == 'sell':\n            daily_pnl[date] += transaction.price * transaction.quantity\n        else:\n            daily_pnl[date] -= transaction.price * transaction.quantity\n    \n    # Convert to returns (simplified)\n    returns = []\n    portfolio_value = 100000  # Starting value assumption\n    \n    for date in sorted(daily_pnl.keys()):\n        pnl = daily_pnl[date]\n        daily_return = pnl / portfolio_value\n        returns.append(daily_return)\n        portfolio_value += pnl\n    \n    return returns\n\ndef _show_performance_chart(daily_returns):\n    \"\"\"Show performance chart\"\"\"\n    if not daily_returns:\n        return\n    \n    # Calculate cumulative returns\n    cumulative_returns = []\n    cumulative = 1\n    \n    for ret in daily_returns:\n        cumulative *= (1 + ret)\n        cumulative_returns.append((cumulative - 1) * 100)\n    \n    # Create chart\n    dates = [datetime.now() - timedelta(days=len(daily_returns)-i-1) for i in range(len(daily_returns))]\n    \n    fig = go.Figure()\n    \n    fig.add_trace(go.Scatter(\n        x=dates,\n        y=cumulative_returns,\n        mode='lines',\n        name='Cumulative Return',\n        line=dict(color='blue', width=2)\n    ))\n    \n    fig.update_layout(\n        title=\"Portfolio Performance Over Time\",\n        xaxis_title=\"Date\",\n        yaxis_title=\"Cumulative Return (%)\",\n        height=400\n    )\n    \n    st.plotly_chart(fig, use_container_width=True)\n\ndef _show_risk_analysis():\n    \"\"\"Show risk analysis metrics\"\"\"\n    session = get_session()\n    broker_manager = BrokerManager()\n    \n    try:\n        # Get current positions\n        positions = broker_manager.get_positions()\n        \n        if not positions:\n            st.info(\"No positions for risk analysis\")\n            return\n        \n        # Calculate risk metrics\n        total_exposure = sum(abs(pos['market_value']) for pos in positions)\n        account_info = broker_manager.get_account_info()\n        portfolio_value = account_info.get('portfolio_value', total_exposure)\n        \n        # Risk metrics\n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            # Concentration risk\n            max_position = max((abs(pos['market_value']) for pos in positions), default=0)\n            concentration = (max_position / portfolio_value * 100) if portfolio_value > 0 else 0\n            st.metric(\"Largest Position\", format_percentage(concentration))\n            \n            if concentration > 20:\n                st.warning(\"âš ï¸ High concentration risk\")\n        \n        with col2:\n            # Leverage\n            leverage = total_exposure / portfolio_value if portfolio_value > 0 else 0\n            st.metric(\"Portfolio Leverage\", f\"{leverage:.2f}x\")\n            \n            if leverage > 2:\n                st.warning(\"âš ï¸ High leverage detected\")\n        \n        with col3:\n            # Day trading risk\n            day_trade_count = account_info.get('day_trade_count', 0)\n            st.metric(\"Day Trades (5 days)\", str(day_trade_count))\n            \n            if day_trade_count >= 3:\n                st.warning(\"âš ï¸ Approaching day trade limit\")\n        \n        # Sector allocation\n        _show_sector_risk_analysis(positions, session)\n    \n    except Exception as e:\n        st.error(f\"Error in risk analysis: {e}\")\n    finally:\n        session.close()\n\ndef _show_sector_risk_analysis(positions, session):\n    \"\"\"Show sector allocation for risk analysis\"\"\"\n    try:\n        # Get sector information for positions\n        symbols = [pos['symbol'] for pos in positions]\n        stocks = session.query(Stock).filter(Stock.symbol.in_(symbols)).all()\n        \n        stock_sectors = {stock.symbol: stock.sector for stock in stocks}\n        \n        # Calculate sector allocation\n        sector_allocation = calculate_sector_allocation(positions, stock_sectors)\n        \n        if sector_allocation:\n            # Create sector allocation chart\n            sectors = list(sector_allocation.keys())\n            percentages = list(sector_allocation.values())\n            \n            fig = px.bar(\n                x=sectors,\n                y=percentages,\n                title=\"Portfolio Allocation by Sector\",\n                labels={'x': 'Sector', 'y': 'Allocation (%)'}\n            )\n            \n            fig.update_layout(height=300)\n            st.plotly_chart(fig, use_container_width=True)\n            \n            # Risk warnings\n            max_sector_allocation = max(percentages) if percentages else 0\n            if max_sector_allocation > 40:\n                st.warning(f\"âš ï¸ High sector concentration: {max_sector_allocation:.1f}% in one sector\")\n    \n    except Exception as e:\n        st.error(f\"Error in sector risk analysis: {e}\")\n\ndef _show_transaction_history():\n    \"\"\"Show transaction history with filtering\"\"\"\n    session = get_session()\n    \n    try:\n        # Date range filter\n        col1, col2, col3 = st.columns([1, 1, 2])\n        \n        with col1:\n            start_date = st.date_input(\"From Date\", value=datetime.now() - timedelta(days=30))\n        \n        with col2:\n            end_date = st.date_input(\"To Date\", value=datetime.now())\n        \n        with col3:\n            transaction_type = st.selectbox(\n                \"Transaction Type\",\n                [\"All\", \"Stock\", \"Option\", \"Buy Only\", \"Sell Only\"]\n            )\n        \n        # Query transactions\n        query = session.query(TransactionLog).filter(\n            TransactionLog.transaction_date >= datetime.combine(start_date, datetime.min.time()),\n            TransactionLog.transaction_date <= datetime.combine(end_date, datetime.max.time())\n        )\n        \n        # Apply filters\n        if transaction_type == \"Stock\":\n            query = query.filter(TransactionLog.asset_type == 'stock')\n        elif transaction_type == \"Option\":\n            query = query.filter(TransactionLog.asset_type == 'option')\n        elif transaction_type == \"Buy Only\":\n            query = query.filter(TransactionLog.side == 'buy')\n        elif transaction_type == \"Sell Only\":\n            query = query.filter(TransactionLog.side == 'sell')\n        \n        transactions = query.order_by(TransactionLog.transaction_date.desc()).all()\n        \n        if transactions:\n            # Prepare transaction data\n            transaction_data = []\n            \n            for tx in transactions:\n                asset_info = tx.symbol\n                if tx.asset_type == 'option':\n                    asset_info += f\" {tx.option_type.upper()}\" if tx.option_type else \"\"\n                    if tx.strike_price:\n                        asset_info += f\" ${tx.strike_price}\"\n                    if tx.expiration_date:\n                        asset_info += f\" {tx.expiration_date.strftime('%m/%d/%y')}\"\n                \n                transaction_data.append({\n                    \"Date\": tx.transaction_date.strftime(\"%Y-%m-%d %H:%M\"),\n                    \"Asset\": asset_info,\n                    \"Side\": tx.side.upper(),\n                    \"Quantity\": tx.quantity,\n                    \"Price\": format_currency(tx.price),\n                    \"Total\": format_currency(tx.price * tx.quantity),\n                    \"P&L\": format_currency(tx.realized_pnl) if tx.realized_pnl else \"N/A\"\n                })\n            \n            # Display transactions\n            df = pd.DataFrame(transaction_data)\n            \n            # Apply styling\n            def color_side(val):\n                if val == 'BUY':\n                    return 'color: green'\n                elif val == 'SELL':\n                    return 'color: red'\n                return ''\n            \n            def color_pnl(val):\n                if val != \"N/A\" and val.startswith('$'):\n                    try:\n                        amount = float(val.replace('$', '').replace(',', ''))\n                        if amount > 0:\n                            return 'color: green'\n                        elif amount < 0:\n                            return 'color: red'\n                    except:\n                        pass\n                return ''\n            \n            styled_df = df.style.map(color_side, subset=['Side'])\\\n                              .map(color_pnl, subset=['P&L'])\n            \n            st.dataframe(styled_df, use_container_width=True)\n            \n            # Summary statistics\n            total_trades = len(transactions)\n            buy_trades = len([tx for tx in transactions if tx.side == 'buy'])\n            sell_trades = len([tx for tx in transactions if tx.side == 'sell'])\n            \n            col1, col2, col3 = st.columns(3)\n            with col1:\n                st.metric(\"Total Trades\", str(total_trades))\n            with col2:\n                st.metric(\"Buy Trades\", str(buy_trades))\n            with col3:\n                st.metric(\"Sell Trades\", str(sell_trades))\n        else:\n            st.info(\"No transactions found for the selected criteria\")\n    \n    except Exception as e:\n        st.error(f\"Error loading transaction history: {e}\")\n    finally:\n        session.close()\n","size_bytes":18538},"database/init_database.py":{"content":"\"\"\"\nDatabase initialization script with exact specifications from requirements.\nPopulates tables with:\n1. Environment variables for trading configuration\n2. Sector ETFs with priority=9  \n3. Sample brokerage info for RobinHood and Alpaca\n4. Sample accounts and users\n5. S&P 500 stocks with actively traded options\n\"\"\"\n\nimport hashlib\nfrom datetime import datetime, timezone\nfrom sqlalchemy.orm import sessionmaker\nfrom database.database import engine, Base\nfrom database.models import (\n    User, EnvironmentVariable, BrokerageInfo, Account, Stock,\n    StockPriceHistory, PriorityCurrentPrice, Order, TransactionLog\n)\n\n# Create session\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\ndef hash_password(password: str) -> str:\n    \"\"\"Hash password using SHA-256\"\"\"\n    return hashlib.sha256(password.encode()).hexdigest()\n\ndef init_environment_variables(session):\n    \"\"\"Initialize global environment variables for trading configuration\"\"\"\n    env_vars = [\n        # Core trading configuration\n        (\"TRADING_MODE\", \"paper\", \"Trading mode: paper or live\", \"string\", True),\n        (\"ACTIVE_BROKER\", \"Alpaca\", \"Currently active broker\", \"string\", True),\n        (\"ACTIVE_ACCOUNT\", \"1\", \"ID of active trading account\", \"integer\", True),\n        \n        # Price monitoring configuration\n        (\"PRICE_UPDATE_INTERVAL\", \"30\", \"Seconds between priority price updates\", \"integer\", False),\n        (\"ARCHIVE_RETENTION_DAYS\", \"30\", \"Days to keep priority archive data\", \"integer\", False),\n        \n        # Priority calculation parameters\n        (\"PRIORITY_PERCENTAGE_TARGET\", \"2.5\", \"% threshold for priority calculation\", \"float\", False),\n        (\"PRIORITY_EVALUATION_PERIODS\", \"3\", \"Periods for priority evaluation logic\", \"integer\", False),\n        \n        # Risk management\n        (\"MAX_POSITION_SIZE\", \"1000\", \"Maximum position size per trade\", \"integer\", False),\n        (\"MAX_DAILY_TRADES\", \"10\", \"Maximum number of trades per day\", \"integer\", False),\n        (\"STOP_LOSS_PERCENTAGE\", \"5.0\", \"Default stop loss percentage\", \"float\", False),\n        (\"TAKE_PROFIT_PERCENTAGE\", \"10.0\", \"Default take profit percentage\", \"float\", False),\n        \n        # Technical indicators\n        (\"ADX_THRESHOLD\", \"25\", \"ADX threshold for trend strength\", \"integer\", False),\n        (\"RSI_OVERSOLD\", \"30\", \"RSI oversold threshold\", \"integer\", False),\n        (\"RSI_OVERBOUGHT\", \"70\", \"RSI overbought threshold\", \"integer\", False),\n        (\"MACD_FAST_PERIOD\", \"12\", \"MACD fast EMA period\", \"integer\", False),\n        (\"MACD_SLOW_PERIOD\", \"26\", \"MACD slow EMA period\", \"integer\", False),\n        (\"MACD_SIGNAL_PERIOD\", \"9\", \"MACD signal line period\", \"integer\", False),\n        \n        # Market hours\n        (\"MARKET_OPEN_HOUR\", \"9\", \"Market open hour (EST)\", \"integer\", True),\n        (\"MARKET_OPEN_MINUTE\", \"30\", \"Market open minute\", \"integer\", True),\n        (\"MARKET_CLOSE_HOUR\", \"16\", \"Market close hour (EST)\", \"integer\", True),\n        (\"MARKET_CLOSE_MINUTE\", \"0\", \"Market close minute\", \"integer\", True),\n    ]\n    \n    for key, value, description, var_type, is_system in env_vars:\n        existing = session.query(EnvironmentVariable).filter(EnvironmentVariable.key == key).first()\n        if not existing:\n            env_var = EnvironmentVariable(\n                key=key,\n                value=value,\n                description=description,\n                variable_type=var_type,\n                is_system=is_system\n            )\n            session.add(env_var)\n    \n    print(\"âœ“ Environment variables initialized\")\n\ndef init_sector_etfs(session):\n    \"\"\"Initialize sector ETFs with priority=9 as specified\"\"\"\n    sector_etfs = [\n        (\"XLE\", \"Energy Select Sector SPDR Fund\", \"Energy\"),\n        (\"XLB\", \"Materials Select Sector SPDR Fund\", \"Materials\"),\n        (\"XLI\", \"Industrial Select Sector SPDR Fund\", \"Industrials\"),\n        (\"XLY\", \"Consumer Discretionary Select Sector SPDR Fund\", \"Consumer Discretionary\"),\n        (\"XLP\", \"Consumer Staples Select Sector SPDR Fund\", \"Consumer Staples\"),\n        (\"XLV\", \"Health Care Select Sector SPDR Fund\", \"Healthcare\"),\n        (\"XLF\", \"Financial Select Sector SPDR Fund\", \"Financials\"),\n        (\"XLK\", \"Technology Select Sector SPDR Fund\", \"Information Technology\"),\n        (\"XLC\", \"Communication Services Select Sector SPDR Fund\", \"Communication Services\"),\n        (\"XLU\", \"Utilities Select Sector SPDR Fund\", \"Utilities\"),\n        (\"XLRE\", \"Real Estate Select Sector SPDR Fund\", \"Real Estate\")\n    ]\n    \n    for symbol, name, sector in sector_etfs:\n        existing = session.query(Stock).filter(Stock.symbol == symbol).first()\n        if not existing:\n            stock = Stock(\n                symbol=symbol,\n                name=name,\n                sector=sector,\n                industry=\"ETF\",\n                market_cap=0,  # ETFs don't have market cap\n                priority=9,  # Sector ETFs always have priority 9\n                has_options=True,\n                is_sp500=False,\n                is_sector_etf=True,\n                last_price=50.00,  # Sample price\n                change_percent=0.0\n            )\n            session.add(stock)\n    \n    print(\"âœ“ Sector ETFs initialized with priority=9\")\n\ndef init_brokerages(session):\n    \"\"\"Initialize brokerage information for RobinHood and Alpaca\"\"\"\n    brokerages = [\n        {\n            \"name\": \"Alpaca\",\n            \"api_url\": \"https://paper-api.alpaca.markets\",\n            \"trading_fees_per_share\": 0.0,\n            \"trading_fees_per_contract\": 0.65,\n            \"day_trade_limit\": 3,\n            \"max_day_trade_buying_power\": 25000.0,\n            \"supports_options\": True,\n            \"supports_crypto\": True,\n            \"is_active\": True\n        },\n        {\n            \"name\": \"RobinHood\",\n            \"api_url\": \"https://robinhood.com/api\",\n            \"trading_fees_per_share\": 0.0,\n            \"trading_fees_per_contract\": 0.0,\n            \"day_trade_limit\": 3,\n            \"max_day_trade_buying_power\": 25000.0,\n            \"supports_options\": True,\n            \"supports_crypto\": True,\n            \"is_active\": False\n        }\n    ]\n    \n    for broker_data in brokerages:\n        existing = session.query(BrokerageInfo).filter(BrokerageInfo.name == broker_data[\"name\"]).first()\n        if not existing:\n            broker = BrokerageInfo(**broker_data)\n            session.add(broker)\n    \n    print(\"âœ“ Brokerage information initialized\")\n\ndef init_accounts(session):\n    \"\"\"Initialize sample trading accounts\"\"\"\n    # Get Alpaca brokerage\n    alpaca = session.query(BrokerageInfo).filter(BrokerageInfo.name == \"Alpaca\").first()\n    robinhood = session.query(BrokerageInfo).filter(BrokerageInfo.name == \"RobinHood\").first()\n    \n    accounts_data = [\n        {\n            \"brokerage_id\": alpaca.id if alpaca else 1,\n            \"account_name\": \"Paper Trading Account\",\n            \"account_type\": \"margin\",\n            \"total_balance\": 100000.0,\n            \"cash_balance\": 50000.0,\n            \"is_active\": True\n        },\n        {\n            \"brokerage_id\": robinhood.id if robinhood else 2,\n            \"account_name\": \"Demo Account\",\n            \"account_type\": \"cash\",\n            \"total_balance\": 25000.0,\n            \"cash_balance\": 25000.0,\n            \"is_active\": False\n        }\n    ]\n    \n    for account_data in accounts_data:\n        existing = session.query(Account).filter(\n            Account.brokerage_id == account_data[\"brokerage_id\"],\n            Account.account_name == account_data[\"account_name\"]\n        ).first()\n        if not existing:\n            account = Account(**account_data)\n            session.add(account)\n    \n    print(\"âœ“ Trading accounts initialized\")\n\ndef init_sample_sp500_stocks(session):\n    \"\"\"Initialize sample S&P 500 stocks with actively traded options\"\"\"\n    # Major S&P 500 stocks with high options activity\n    sp500_stocks = [\n        (\"AAPL\", \"Apple Inc.\", \"Information Technology\", \"Consumer Electronics\", 3000000000000),\n        (\"MSFT\", \"Microsoft Corporation\", \"Information Technology\", \"Software\", 2800000000000),\n        (\"GOOGL\", \"Alphabet Inc.\", \"Communication Services\", \"Internet Content & Information\", 1700000000000),\n        (\"AMZN\", \"Amazon.com Inc.\", \"Consumer Discretionary\", \"Internet & Direct Marketing Retail\", 1500000000000),\n        (\"TSLA\", \"Tesla Inc.\", \"Consumer Discretionary\", \"Automobiles\", 800000000000),\n        (\"NVDA\", \"NVIDIA Corporation\", \"Information Technology\", \"Semiconductors\", 2200000000000),\n        (\"META\", \"Meta Platforms Inc.\", \"Communication Services\", \"Interactive Media & Services\", 900000000000),\n        (\"JPM\", \"JPMorgan Chase & Co.\", \"Financials\", \"Banks\", 500000000000),\n        (\"V\", \"Visa Inc.\", \"Information Technology\", \"Data Processing & Outsourced Services\", 450000000000),\n        (\"JNJ\", \"Johnson & Johnson\", \"Healthcare\", \"Pharmaceuticals\", 400000000000),\n        (\"WMT\", \"Walmart Inc.\", \"Consumer Staples\", \"Hypermarkets & Super Centers\", 420000000000),\n        (\"PG\", \"Procter & Gamble Co.\", \"Consumer Staples\", \"Household Products\", 380000000000),\n        (\"UNH\", \"UnitedHealth Group Inc.\", \"Healthcare\", \"Managed Health Care\", 480000000000),\n        (\"HD\", \"Home Depot Inc.\", \"Consumer Discretionary\", \"Home Improvement Retail\", 350000000000),\n        (\"MA\", \"Mastercard Inc.\", \"Information Technology\", \"Data Processing & Outsourced Services\", 360000000000),\n        (\"DIS\", \"Walt Disney Co.\", \"Communication Services\", \"Movies & Entertainment\", 200000000000),\n        (\"NFLX\", \"Netflix Inc.\", \"Communication Services\", \"Movies & Entertainment\", 180000000000),\n        (\"BAC\", \"Bank of America Corp.\", \"Financials\", \"Banks\", 320000000000),\n        (\"XOM\", \"Exxon Mobil Corporation\", \"Energy\", \"Integrated Oil & Gas\", 280000000000),\n        (\"KO\", \"Coca-Cola Co.\", \"Consumer Staples\", \"Soft Drinks\", 260000000000)\n    ]\n    \n    import random\n    \n    for symbol, name, sector, industry, market_cap in sp500_stocks:\n        existing = session.query(Stock).filter(Stock.symbol == symbol).first()\n        if not existing:\n            # Generate realistic sample price and change\n            base_price = random.uniform(50, 400)\n            change_pct = random.uniform(-3.0, 3.0)\n            \n            stock = Stock(\n                symbol=symbol,\n                name=name,\n                sector=sector,\n                industry=industry,\n                market_cap=market_cap,\n                priority=1,  # Set all to priority 1 for testing\n                has_options=True,\n                is_sp500=True,\n                is_sector_etf=False,\n                last_price=round(base_price, 2),\n                change_percent=round(change_pct, 2),\n                volume=random.randint(1000000, 50000000),\n                avg_volume=random.randint(500000, 25000000)\n            )\n            session.add(stock)\n    \n    print(\"âœ“ S&P 500 stocks with options initialized\")\n\ndef init_users(session):\n    \"\"\"Initialize admin and sample users\"\"\"\n    users_data = [\n        {\n            \"username\": \"admin\",\n            \"email\": \"admin@trading.local\",\n            \"password\": \"admin123\",\n            \"role\": \"admin\"\n        },\n        {\n            \"username\": \"trader1\",\n            \"email\": \"trader1@trading.local\", \n            \"password\": \"trader123\",\n            \"role\": \"trader\"\n        },\n        {\n            \"username\": \"viewer1\",\n            \"email\": \"viewer1@trading.local\",\n            \"password\": \"viewer123\", \n            \"role\": \"viewer\"\n        }\n    ]\n    \n    for user_data in users_data:\n        existing = session.query(User).filter(User.username == user_data[\"username\"]).first()\n        if not existing:\n            user = User(\n                username=user_data[\"username\"],\n                email=user_data[\"email\"],\n                password_hash=hash_password(user_data[\"password\"]),\n                role=user_data[\"role\"],\n                is_active=True\n            )\n            session.add(user)\n    \n    print(\"âœ“ Users initialized\")\n\ndef init_database():\n    \"\"\"Initialize entire database with exact specifications\"\"\"\n    print(\"ðŸ”„ Initializing database with exact specifications...\")\n    \n    # Create all tables\n    Base.metadata.create_all(bind=engine)\n    print(\"âœ“ Database tables created\")\n    \n    # Create session\n    session = SessionLocal()\n    \n    try:\n        # Initialize all data\n        init_environment_variables(session)\n        init_sector_etfs(session)\n        init_brokerages(session)\n        init_accounts(session)\n        init_sample_sp500_stocks(session)\n        init_users(session)\n        \n        # Commit all changes\n        session.commit()\n        print(\"âœ… Database initialization completed successfully!\")\n        \n        # Print summary\n        print(\"\\nðŸ“Š Database Summary:\")\n        print(f\"   â€¢ Environment Variables: {session.query(EnvironmentVariable).count()}\")\n        print(f\"   â€¢ Brokerages: {session.query(BrokerageInfo).count()}\")\n        print(f\"   â€¢ Accounts: {session.query(Account).count()}\")\n        print(f\"   â€¢ Stocks (Total): {session.query(Stock).count()}\")\n        print(f\"   â€¢ Sector ETFs (Priority=9): {session.query(Stock).filter(Stock.priority == 9).count()}\")\n        print(f\"   â€¢ S&P 500 Stocks (Priority=1): {session.query(Stock).filter(Stock.priority == 1).count()}\")\n        print(f\"   â€¢ Users: {session.query(User).count()}\")\n        \n    except Exception as e:\n        session.rollback()\n        print(f\"âŒ Error initializing database: {e}\")\n        raise\n    finally:\n        session.close()\n\nif __name__ == \"__main__\":\n    init_database()","size_bytes":13572},"app_old.py":{"content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime, timedelta\nimport asyncio\nimport threading\nimport time\n\n# Import custom modules\nfrom database.database import init_database, get_session\nfrom database.models import User, EnvironmentVariable, Stock, Account\nfrom utils.auth import authenticate_user, get_current_user, check_permission\nfrom services.data_fetcher import DataFetcher\nfrom services.trading_engine import TradingEngine\nfrom services.technical_indicators import TechnicalIndicators\nfrom utils.helpers import format_currency, calculate_portfolio_value\n\n# Initialize database\ninit_database()\n\n# Configure page\nst.set_page_config(\n    page_title=\"Algorithmic Trading Platform\",\n    page_icon=\"ðŸ“ˆ\",\n    layout=\"wide\",\n    initial_sidebar_state=\"expanded\"\n)\n\n# Session state initialization\nif 'authenticated' not in st.session_state:\n    st.session_state.authenticated = False\nif 'user' not in st.session_state:\n    st.session_state.user = None\nif 'trading_engine' not in st.session_state:\n    st.session_state.trading_engine = None\n\ndef login_page():\n    st.title(\"ðŸ” Login\")\n    \n    with st.form(\"login_form\"):\n        username = st.text_input(\"Username\")\n        password = st.text_input(\"Password\", type=\"password\")\n        submitted = st.form_submit_button(\"Login\")\n        \n        if submitted:\n            user = authenticate_user(username, password)\n            if user:\n                st.session_state.authenticated = True\n                st.session_state.user = user\n                st.success(\"Login successful!\")\n                st.rerun()\n            else:\n                st.error(\"Invalid username or password\")\n\ndef sidebar_navigation():\n    st.sidebar.title(\"ðŸ“ˆ Trading Platform\")\n    \n    if st.session_state.authenticated:\n        user = st.session_state.user\n        st.sidebar.write(f\"ðŸ‘¤ Welcome, {user.username}\")\n        st.sidebar.write(f\"ðŸ·ï¸ Role: {user.role}\")\n        \n        # Show engine status in sidebar\n        engine_status = st.session_state.get('engine_status', 'Stopped')\n        if engine_status == \"Running\":\n            st.sidebar.success(\"ðŸ¤– Engine: RUNNING\")\n        else:\n            st.sidebar.warning(\"ðŸ¤– Engine: STOPPED\")\n        \n        # Core navigation menu\n        pages = {\n            \"Trading\": \"ðŸ’¹\",\n            \"Orders\": \"ðŸ“‹\", \n            \"Positions\": \"ðŸ’¼\"\n        }\n        \n        # Add admin pages\n        if user.role == 'admin':\n            pages[\"Settings\"] = \"âš™ï¸\"\n            pages[\"Database\"] = \"ðŸ—„ï¸\"\n        \n        selected_page = st.sidebar.radio(\n            \"Navigation\",\n            list(pages.keys()),\n            format_func=lambda x: f\"{pages[x]} {x}\"\n        )\n        \n        # Logout button\n        if st.sidebar.button(\"ðŸšª Logout\"):\n            st.session_state.authenticated = False\n            st.session_state.user = None\n            st.session_state.trading_engine = None\n            st.rerun()\n        \n        return selected_page\n    \n    return None\n\ndef show_orders_page():\n    \"\"\"Display orders table per requirements\"\"\"\n    st.title(\"ðŸ“‹ Orders\")\n    \n    session = get_session()\n    try:\n        orders = session.query(Order).order_by(Order.submitted_at.desc()).all()\n        \n        if orders:\n            order_data = []\n            for order in orders:\n                order_data.append({\n                    \"Symbol\": order.symbol,\n                    \"Action\": order.side.title(),\n                    \"Asset\": order.asset_type.title(),\n                    \"Quantity\": order.quantity,\n                    \"Order Type\": order.order_type.title(),\n                    \"Limit Price\": f\"${order.limit_price:.2f}\" if order.limit_price else \"N/A\",\n                    \"Status\": order.status.title(),\n                    \"Submitted\": order.submitted_at.strftime(\"%Y-%m-%d %H:%M\"),\n                    \"Filled\": order.filled_at.strftime(\"%Y-%m-%d %H:%M\") if order.filled_at else \"N/A\"\n                })\n            \n            df = pd.DataFrame(order_data)\n            st.dataframe(df, use_container_width=True)\n        else:\n            st.info(\"No orders found.\")\n    finally:\n        session.close()\n\ndef show_positions_page():\n    \"\"\"Display current positions and transaction log\"\"\"\n    st.title(\"ðŸ’¼ Positions & Transaction Log\")\n    \n    # Current positions\n    st.subheader(\"Current Positions\")\n    \n    session = get_session()\n    try:\n        # Calculate positions from transaction log\n        transactions = session.query(TransactionLog).order_by(TransactionLog.transaction_date).all()\n        \n        positions = {}\n        for transaction in transactions:\n            key = f\"{transaction.symbol}_{transaction.asset_type}\"\n            if transaction.option_type:\n                key += f\"_{transaction.option_type}_{transaction.strike_price}\"\n            \n            if key not in positions:\n                positions[key] = {\n                    'symbol': transaction.symbol,\n                    'asset_type': transaction.asset_type,\n                    'option_type': transaction.option_type,\n                    'strike_price': transaction.strike_price,\n                    'quantity': 0,\n                    'avg_price': 0,\n                    'total_cost': 0\n                }\n            \n            pos = positions[key]\n            if transaction.side == 'buy':\n                pos['quantity'] += transaction.quantity\n                pos['total_cost'] += transaction.price * transaction.quantity\n            else:\n                pos['quantity'] -= transaction.quantity\n                pos['total_cost'] -= transaction.price * transaction.quantity\n            \n            if pos['quantity'] > 0:\n                pos['avg_price'] = pos['total_cost'] / pos['quantity']\n        \n        # Filter non-zero positions\n        active_positions = [pos for pos in positions.values() if pos['quantity'] != 0]\n        \n        if active_positions:\n            pos_data = []\n            for pos in active_positions:\n                pos_data.append({\n                    \"Symbol\": pos['symbol'],\n                    \"Asset\": pos['asset_type'].title(),\n                    \"Type\": pos['option_type'].title() if pos['option_type'] else \"N/A\",\n                    \"Strike\": f\"${pos['strike_price']:.2f}\" if pos['strike_price'] else \"N/A\",\n                    \"Quantity\": pos['quantity'],\n                    \"Avg Price\": f\"${pos['avg_price']:.2f}\",\n                    \"Total Cost\": f\"${pos['total_cost']:.2f}\"\n                })\n            \n            df = pd.DataFrame(pos_data)\n            st.dataframe(df, use_container_width=True)\n        else:\n            st.info(\"No current positions.\")\n        \n        # Transaction log with LIFO gain/loss\n        st.subheader(\"Transaction Log (LIFO)\")\n        \n        recent_transactions = session.query(TransactionLog).order_by(TransactionLog.transaction_date.desc()).limit(50).all()\n        \n        if recent_transactions:\n            trans_data = []\n            for transaction in recent_transactions:\n                trans_data.append({\n                    \"Date\": transaction.transaction_date.strftime(\"%Y-%m-%d %H:%M\"),\n                    \"Symbol\": transaction.symbol,\n                    \"Side\": transaction.side.title(),\n                    \"Asset\": transaction.asset_type.title(),\n                    \"Quantity\": transaction.quantity,\n                    \"Price\": f\"${transaction.price:.2f}\",\n                    \"Total\": f\"${transaction.price * transaction.quantity:.2f}\",\n                    \"P&L\": f\"${transaction.gain_loss:.2f}\" if transaction.gain_loss else \"N/A\"\n                })\n            \n            df = pd.DataFrame(trans_data)\n            st.dataframe(df, use_container_width=True)\n        else:\n            st.info(\"No transactions found.\")\n            \n    finally:\n        session.close()\n\ndef show_settings_page():\n    \"\"\"Basic environment variables configuration\"\"\"\n    st.title(\"âš™ï¸ Settings\")\n    \n    session = get_session()\n    try:\n        # Get environment variables\n        env_vars = {var.key: var.value for var in session.query(EnvironmentVariable).all()}\n        \n        st.subheader(\"Trading Configuration\")\n        \n        col1, col2 = st.columns(2)\n        \n        with col1:\n            trading_mode = st.selectbox(\n                \"Trading Mode\",\n                [\"paper\", \"live\"],\n                index=0 if env_vars.get('TRADING_MODE', 'paper') == 'paper' else 1\n            )\n            \n            price_interval = st.number_input(\n                \"Price Update Interval (seconds)\",\n                min_value=5,\n                max_value=300,\n                value=int(env_vars.get('PRICE_UPDATE_INTERVAL', '30'))\n            )\n        \n        with col2:\n            max_position = st.number_input(\n                \"Max Position Size (%)\",\n                min_value=1.0,\n                max_value=25.0,\n                value=float(env_vars.get('MAX_POSITION_SIZE_PERCENT', '5.0')),\n                step=0.5\n            )\n            \n            archive_days = st.number_input(\n                \"Archive Retention (days)\",\n                min_value=7,\n                max_value=365,\n                value=int(env_vars.get('ARCHIVE_RETENTION_DAYS', '30'))\n            )\n        \n        if st.button(\"Save Settings\"):\n            # Update environment variables\n            for key, value in [\n                ('TRADING_MODE', trading_mode),\n                ('PRICE_UPDATE_INTERVAL', str(price_interval)),\n                ('MAX_POSITION_SIZE_PERCENT', str(max_position)),\n                ('ARCHIVE_RETENTION_DAYS', str(archive_days))\n            ]:\n                env_var = session.query(EnvironmentVariable).filter(EnvironmentVariable.key == key).first()\n                if env_var:\n                    env_var.value = value\n                else:\n                    env_var = EnvironmentVariable(key=key, value=value)\n                    session.add(env_var)\n            \n            session.commit()\n            st.success(\"Settings saved!\")\n            st.rerun()\n    \n    finally:\n        session.close()\n\n# Remove old dashboard function - now using streamlined functions above\n\n\ndef load_page_content(page_name):\n    \"\"\"Load core trading functionality only\"\"\"\n    if page_name == \"Trading\":\n        show_trading_interface()\n    elif page_name == \"Orders\":\n        show_orders_page()\n    elif page_name == \"Positions\":\n        show_positions_page()\n    elif page_name == \"Settings\":\n        show_settings_page()\n    elif page_name == \"Database\":\n        from app_pages.database_admin import render_database_admin_page\n        render_database_admin_page()\n\ndef main():\n    \"\"\"Main application entry point\"\"\"\n    \n    if not st.session_state.authenticated:\n        login_page()\n        return\n    \n    # Show sidebar navigation\n    selected_page = sidebar_navigation()\n    \n    if selected_page:\n        load_page_content(selected_page)\n    \n    # Background tasks status\n    with st.sidebar:\n        st.divider()\n        st.subheader(\"ðŸ”„ Background Tasks\")\n        \n        # Data fetcher status\n        if st.button(\"ðŸ”„ Refresh Market Data\"):\n            with st.spinner(\"Fetching market data...\"):\n                try:\n                    data_fetcher = DataFetcher()\n                    data_fetcher.update_priority_stocks()\n                    st.success(\"Market data updated!\")\n                except Exception as e:\n                    st.error(f\"Error updating data: {str(e)}\")\n        \n        # Show last update time\n        st.caption(\"Last update: 2 minutes ago\")\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":11591},"utils/auth.py":{"content":"import hashlib\nimport secrets\nfrom typing import Optional\nfrom database.database import get_session\nfrom database.models import User\n\ndef hash_password(password: str) -> str:\n    \"\"\"Hash a password using SHA-256 with salt\"\"\"\n    salt = secrets.token_hex(16)\n    password_hash = hashlib.sha256((password + salt).encode()).hexdigest()\n    return f\"{salt}:{password_hash}\"\n\ndef verify_password(password: str, password_hash: str) -> bool:\n    \"\"\"Verify a password against its hash\"\"\"\n    try:\n        salt, hash_value = password_hash.split(':')\n        return hashlib.sha256((password + salt).encode()).hexdigest() == hash_value\n    except ValueError:\n        return False\n\ndef authenticate_user(username: str, password: str) -> Optional[User]:\n    \"\"\"Authenticate a user with username and password\"\"\"\n    session = get_session()\n    try:\n        user = session.query(User).filter(\n            User.username == username,\n            User.is_active == True\n        ).first()\n        \n        if user and verify_password(password, user.password_hash):\n            return user\n        return None\n    finally:\n        session.close()\n\ndef get_current_user(user_id: int) -> Optional[User]:\n    \"\"\"Get user by ID\"\"\"\n    session = get_session()\n    try:\n        user = session.query(User).filter(\n            User.id == user_id,\n            User.is_active == True\n        ).first()\n        return user\n    finally:\n        session.close()\n\ndef check_permission(user: User, required_role: str) -> bool:\n    \"\"\"Check if user has required role/permission\"\"\"\n    role_hierarchy = {\n        'viewer': 1,\n        'trader': 2,\n        'admin': 3\n    }\n    \n    user_level = role_hierarchy.get(user.role, 0)\n    required_level = role_hierarchy.get(required_role, 99)\n    \n    return user_level >= required_level\n\ndef create_user(username: str, email: str, password: str, role: str = 'trader') -> User:\n    \"\"\"Create a new user\"\"\"\n    session = get_session()\n    try:\n        # Check if username or email already exists\n        existing = session.query(User).filter(\n            (User.username == username) | (User.email == email)\n        ).first()\n        \n        if existing:\n            raise ValueError(\"Username or email already exists\")\n        \n        user = User(\n            username=username,\n            email=email,\n            password_hash=hash_password(password),\n            role=role,\n            is_active=True\n        )\n        \n        session.add(user)\n        session.commit()\n        return user\n    except Exception as e:\n        session.rollback()\n        raise e\n    finally:\n        session.close()\n\ndef update_user_role(user_id: int, new_role: str) -> bool:\n    \"\"\"Update user role\"\"\"\n    session = get_session()\n    try:\n        user = session.query(User).filter(User.id == user_id).first()\n        if user:\n            user.role = new_role\n            session.commit()\n            return True\n        return False\n    except Exception as e:\n        session.rollback()\n        return False\n    finally:\n        session.close()\n\ndef deactivate_user(user_id: int) -> bool:\n    \"\"\"Deactivate a user\"\"\"\n    session = get_session()\n    try:\n        user = session.query(User).filter(User.id == user_id).first()\n        if user:\n            user.is_active = False\n            session.commit()\n            return True\n        return False\n    except Exception as e:\n        session.rollback()\n        return False\n    finally:\n        session.close()\n","size_bytes":3456},"services/trading_engine.py":{"content":"import asyncio\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Optional\nimport pandas as pd\nimport numpy as np\n\nfrom database.database import get_session\nfrom database.models import (\n    Stock, PriorityCurrentPrice, Order, TransactionLog, \n    Account, EnvironmentVariable\n)\nfrom services.broker_apis import BrokerManager\nfrom services.technical_indicators import TechnicalIndicators\nfrom utils.helpers import calculate_position_size, calculate_lifo_pnl\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nclass TradingEngine:\n    \"\"\"Main algorithmic trading engine\"\"\"\n    \n    def __init__(self):\n        self.broker_manager = BrokerManager()\n        self.is_running = False\n        self.trading_mode = 'paper'  # paper or live\n        self.max_position_size_percent = 5.0\n        self.price_update_interval = 30  # seconds\n        self.momentum_periods = 3\n        self.position_size_percent = 2.0\n        \n        # Load configuration from environment variables\n        self._load_configuration()\n        \n        # Authenticate with brokers\n        self.broker_manager.authenticate_all()\n    \n    def _load_configuration(self):\n        \"\"\"Load configuration from environment variables table\"\"\"\n        session = get_session()\n        try:\n            env_vars = session.query(EnvironmentVariable).all()\n            for var in env_vars:\n                if var.key == 'TRADING_MODE':\n                    self.trading_mode = var.value\n                elif var.key == 'MAX_POSITION_SIZE_PERCENT':\n                    self.max_position_size_percent = float(var.value)\n                elif var.key == 'PRICE_UPDATE_INTERVAL':\n                    self.price_update_interval = int(var.value)\n                elif var.key == 'ACTIVE_BROKER':\n                    self.broker_manager.set_active_broker(var.value)\n        except Exception as e:\n            logger.error(f\"Error loading configuration: {e}\")\n        finally:\n            session.close()\n    \n    def start_trading(self):\n        \"\"\"Start the trading engine\"\"\"\n        if self.is_running:\n            logger.warning(\"Trading engine is already running\")\n            return\n        \n        self.is_running = True\n        logger.info(f\"Starting trading engine in {self.trading_mode} mode\")\n        \n        # Start the main trading loop in a separate thread\n        import threading\n        self.trading_thread = threading.Thread(target=self._run_trading_loop, daemon=True)\n        self.trading_thread.start()\n    \n    def stop_trading(self):\n        \"\"\"Stop the trading engine\"\"\"\n        self.is_running = False\n        logger.info(\"Trading engine stopped\")\n        \n        # Wait for trading thread to finish\n        if hasattr(self, 'trading_thread') and self.trading_thread.is_alive():\n            self.trading_thread.join(timeout=5.0)\n    \n    def _run_trading_loop(self):\n        \"\"\"Run the trading loop in a thread\"\"\"\n        import asyncio\n        import time\n        \n        # Create new event loop for this thread\n        loop = asyncio.new_event_loop()\n        asyncio.set_event_loop(loop)\n        \n        try:\n            loop.run_until_complete(self._trading_loop())\n        finally:\n            loop.close()\n    \n    async def _trading_loop(self):\n        \"\"\"Main trading loop\"\"\"\n        while self.is_running:\n            try:\n                await self._execute_trading_cycle()\n                await asyncio.sleep(self.price_update_interval)\n            except Exception as e:\n                logger.error(f\"Error in trading loop: {e}\")\n                await asyncio.sleep(60)  # Wait longer on error\n    \n    async def _execute_trading_cycle(self):\n        \"\"\"Execute one trading cycle\"\"\"\n        from datetime import datetime\n        cycle_time = datetime.now().strftime(\"%H:%M:%S\")\n        logger.info(f\"ðŸ”„ Starting trading cycle at {cycle_time}...\")\n        \n        # Update session state for UI feedback\n        import streamlit as st\n        if 'last_activity' in st.session_state:\n            st.session_state.last_activity = f\"Cycle started at {cycle_time}\"\n        \n        # 1. Update priority stock prices\n        logger.info(\"ðŸ“¡ Fetching latest market data...\")\n        await self._update_priority_prices()\n        \n        # 2. Evaluate trading opportunities  \n        logger.info(\"ðŸ” Analyzing trading opportunities...\")\n        await self._evaluate_trading_opportunities()\n        \n        # 3. Monitor existing positions\n        logger.info(\"ðŸ‘ï¸ Monitoring existing positions...\")\n        await self._monitor_positions()\n        \n        # 4. Execute risk management\n        logger.info(\"âš–ï¸ Executing risk management...\")\n        await self._execute_risk_management()\n        \n        complete_time = datetime.now().strftime(\"%H:%M:%S\")\n        logger.info(f\"âœ… Trading cycle completed at {complete_time}\")\n        \n        # Update completion time for UI\n        if 'last_activity' in st.session_state:\n            st.session_state.last_activity = f\"Completed at {complete_time}\"\n    \n    async def _update_priority_prices(self):\n        \"\"\"Update current prices for priority stocks\"\"\"\n        session = get_session()\n        try:\n            # Get priority stocks\n            priority_stocks = session.query(Stock).filter(Stock.priority > 0).all()\n            \n            if not priority_stocks:\n                logger.info(\"âš ï¸ No priority stocks found - engine will monitor S&P 500 stocks\")\n                return\n            \n            symbols = [stock.symbol for stock in priority_stocks]\n            logger.info(f\"ðŸŽ¯ Monitoring {len(symbols)} priority stocks: {', '.join(symbols[:5])}{'...' if len(symbols) > 5 else ''}\")\n            \n            market_data = self.broker_manager.get_market_data(symbols)\n            updated_count = 0\n            \n            for stock in priority_stocks:\n                if stock.symbol in market_data:\n                    data = market_data[stock.symbol]\n                    \n                    # Update stock price\n                    stock.last_price = data['price']\n                    stock.change_percent = data['change_percent']\n                    \n                    # Add to priority current price table\n                    priority_price = PriorityCurrentPrice(\n                        stock_id=stock.id,\n                        symbol=stock.symbol,\n                        datetime=datetime.utcnow(),\n                        current_price=data['price'],\n                        percent_change_from_previous=data['change_percent'],\n                        volume=data.get('volume', 0)\n                    )\n                    session.add(priority_price)\n                    updated_count += 1\n                    \n            session.commit()\n            logger.info(f\"ðŸ“Š Updated prices for {updated_count} stocks successfully\")\n        except Exception as e:\n            session.rollback()\n            logger.error(f\"Error updating priority prices: {e}\")\n        finally:\n            session.close()\n    \n    async def _evaluate_trading_opportunities(self):\n        \"\"\"Evaluate stocks for trading opportunities\"\"\"\n        session = get_session()\n        try:\n            priority_stocks = session.query(Stock).filter(Stock.priority > 0).all()\n            \n            for stock in priority_stocks:\n                await self._evaluate_stock_for_trading(stock, session)\n        \n        except Exception as e:\n            logger.error(f\"Error evaluating trading opportunities: {e}\")\n        finally:\n            session.close()\n    \n    async def _evaluate_stock_for_trading(self, stock: Stock, session):\n        \"\"\"Evaluate individual stock for trading opportunity\"\"\"\n        try:\n            # Get recent price data for momentum analysis\n            recent_prices = session.query(PriorityCurrentPrice)\\\n                .filter(PriorityCurrentPrice.stock_id == stock.id)\\\n                .order_by(PriorityCurrentPrice.datetime.desc())\\\n                .limit(self.momentum_periods + 1).all()\n            \n            if len(recent_prices) < self.momentum_periods + 1:\n                return\n            \n            # Check if order already exists for this stock\n            existing_order = session.query(Order)\\\n                .filter(Order.symbol == stock.symbol)\\\n                .filter(Order.status == 'pending').first()\n            \n            if existing_order:\n                return  # Skip if order already exists\n            \n            # Analyze price momentum\n            prices = [p.current_price for p in reversed(recent_prices)]\n            momentum = TechnicalIndicators.detect_price_momentum(prices, self.momentum_periods)\n            \n            # Calculate recent volatility\n            price_changes = [TechnicalIndicators.calculate_price_change_percentage(\n                prices[i], prices[i-1]) for i in range(1, len(prices))]\n            \n            avg_change = np.mean([abs(change) for change in price_changes])\n            \n            # Determine if conditions are met for trading\n            if self._should_place_trade(momentum, price_changes, avg_change):\n                await self._place_algorithmic_trade(stock, momentum, session)\n        \n        except Exception as e:\n            logger.error(f\"Error evaluating stock {stock.symbol}: {e}\")\n    \n    def _should_place_trade(self, momentum: str, price_changes: List[float], avg_change: float) -> bool:\n        \"\"\"Determine if trading conditions are met\"\"\"\n        # Check for consistent momentum\n        if momentum == 'sideways':\n            return False\n        \n        # Check if all periods moved in same direction\n        if momentum == 'up':\n            consistent_direction = all(change > 0 for change in price_changes)\n        else:\n            consistent_direction = all(change < 0 for change in price_changes)\n        \n        # Check if average change is significant (configurable threshold)\n        significant_movement = avg_change > 1.0  # 1% threshold\n        \n        return consistent_direction and significant_movement\n    \n    async def _place_algorithmic_trade(self, stock: Stock, momentum: str, session):\n        \"\"\"Place algorithmic trade based on analysis\"\"\"\n        try:\n            # Get account information\n            account_info = self.broker_manager.get_account_info()\n            available_cash = account_info.get('cash', 0)\n            \n            if available_cash < 1000:  # Minimum cash requirement\n                logger.warning(f\"Insufficient cash for trading: ${available_cash}\")\n                return\n            \n            # Calculate position size\n            position_value = available_cash * (self.position_size_percent / 100)\n            current_price = stock.last_price or 100.0\n            quantity = int(position_value / current_price)\n            \n            if quantity == 0:\n                return\n            \n            # Determine if we should trade options or stock\n            if self._should_trade_options(stock, momentum):\n                await self._place_options_trade(stock, momentum, quantity, session)\n            else:\n                await self._place_stock_trade(stock, momentum, quantity, session)\n        \n        except Exception as e:\n            logger.error(f\"Error placing algorithmic trade for {stock.symbol}: {e}\")\n    \n    def _should_trade_options(self, stock: Stock, momentum: str) -> bool:\n        \"\"\"Determine if we should trade options instead of stock\"\"\"\n        # Trade options if stock has options and momentum is strong\n        if not stock.has_options:\n            return False\n        \n        # Check if conditions favor options trading\n        # (this would include analysis of major indices, volatility, etc.)\n        return True  # Simplified for now\n    \n    async def _place_options_trade(self, stock: Stock, momentum: str, quantity: int, session):\n        \"\"\"Place options trade\"\"\"\n        try:\n            # Determine option type based on momentum\n            option_type = 'call' if momentum == 'up' else 'put'\n            \n            # Calculate strike price (simplified - would use more sophisticated logic)\n            current_price = stock.last_price\n            if option_type == 'call':\n                strike_price = current_price * 1.05  # 5% OTM call\n            else:\n                strike_price = current_price * 0.95  # 5% OTM put\n            \n            # Set expiration date (simplified - would use more sophisticated logic)\n            expiration_date = datetime.now() + timedelta(days=30)\n            \n            # Create order record\n            order = Order(\n                account_id=1,  # Default account\n                symbol=stock.symbol,\n                order_type='market',\n                side='buy',\n                quantity=quantity,\n                asset_type='option',\n                option_type=option_type,\n                strike_price=strike_price,\n                expiration_date=expiration_date,\n                status='pending'\n            )\n            session.add(order)\n            session.commit()\n            \n            # Place order with broker (in paper trading mode, this is simulated)\n            if self.trading_mode == 'paper':\n                await self._simulate_option_execution(order, session)\n            else:\n                # Would place real order with broker\n                logger.info(f\"Would place live options order: {option_type} {stock.symbol}\")\n        \n        except Exception as e:\n            logger.error(f\"Error placing options trade: {e}\")\n            session.rollback()\n    \n    async def _place_stock_trade(self, stock: Stock, momentum: str, quantity: int, session):\n        \"\"\"Place stock trade\"\"\"\n        try:\n            side = 'buy' if momentum == 'up' else 'sell'\n            \n            # Create order record\n            order = Order(\n                account_id=1,\n                symbol=stock.symbol,\n                order_type='market',\n                side=side,\n                quantity=quantity,\n                asset_type='stock',\n                status='pending'\n            )\n            session.add(order)\n            session.commit()\n            \n            # Place order with broker\n            if self.trading_mode == 'paper':\n                await self._simulate_stock_execution(order, session)\n            else:\n                broker_response = self.broker_manager.place_order(\n                    stock.symbol, side, quantity, 'market'\n                )\n                order.broker_order_id = broker_response.get('id')\n                session.commit()\n        \n        except Exception as e:\n            logger.error(f\"Error placing stock trade: {e}\")\n            session.rollback()\n    \n    async def _simulate_option_execution(self, order: Order, session):\n        \"\"\"Simulate option execution for paper trading\"\"\"\n        try:\n            # Simulate option pricing (simplified)\n            option_price = 2.50  # Would use Black-Scholes or similar\n            \n            # Mark order as filled\n            order.status = 'filled'\n            order.filled_at = datetime.utcnow()\n            \n            # Create transaction log\n            transaction = TransactionLog(\n                order_id=order.id,\n                account_id=order.account_id,\n                symbol=order.symbol,\n                side=order.side,\n                quantity=order.quantity,\n                price=option_price,\n                asset_type='option',\n                option_type=order.option_type,\n                strike_price=order.strike_price,\n                expiration_date=order.expiration_date\n            )\n            session.add(transaction)\n            session.commit()\n            \n            logger.info(f\"Simulated option execution: {order.side} {order.quantity} {order.option_type} {order.symbol} @ ${option_price}\")\n        \n        except Exception as e:\n            logger.error(f\"Error simulating option execution: {e}\")\n            session.rollback()\n    \n    async def _simulate_stock_execution(self, order: Order, session):\n        \"\"\"Simulate stock execution for paper trading\"\"\"\n        try:\n            # Use current market price\n            stock = session.query(Stock).filter(Stock.symbol == order.symbol).first()\n            execution_price = stock.last_price or 100.0\n            \n            # Mark order as filled\n            order.status = 'filled'\n            order.filled_at = datetime.utcnow()\n            \n            # Create transaction log\n            transaction = TransactionLog(\n                order_id=order.id,\n                account_id=order.account_id,\n                symbol=order.symbol,\n                side=order.side,\n                quantity=order.quantity,\n                price=execution_price,\n                asset_type='stock'\n            )\n            session.add(transaction)\n            session.commit()\n            \n            logger.info(f\"Simulated stock execution: {order.side} {order.quantity} {order.symbol} @ ${execution_price}\")\n        \n        except Exception as e:\n            logger.error(f\"Error simulating stock execution: {e}\")\n            session.rollback()\n    \n    async def _monitor_positions(self):\n        \"\"\"Monitor existing positions for exit signals\"\"\"\n        session = get_session()\n        try:\n            # Get open positions from transaction log\n            open_positions = self._get_open_positions(session)\n            \n            for position in open_positions:\n                await self._evaluate_position_exit(position, session)\n        \n        except Exception as e:\n            logger.error(f\"Error monitoring positions: {e}\")\n        finally:\n            session.close()\n    \n    def _get_open_positions(self, session) -> List[Dict]:\n        \"\"\"Get currently open positions\"\"\"\n        # Query transaction log to determine open positions\n        transactions = session.query(TransactionLog).order_by(TransactionLog.transaction_date).all()\n        \n        positions = {}\n        for transaction in transactions:\n            key = f\"{transaction.symbol}_{transaction.asset_type}\"\n            if transaction.option_type:\n                key += f\"_{transaction.option_type}_{transaction.strike_price}_{transaction.expiration_date}\"\n            \n            if key not in positions:\n                positions[key] = {\n                    'symbol': transaction.symbol,\n                    'asset_type': transaction.asset_type,\n                    'option_type': transaction.option_type,\n                    'strike_price': transaction.strike_price,\n                    'expiration_date': transaction.expiration_date,\n                    'quantity': 0,\n                    'avg_price': 0,\n                    'transactions': []\n                }\n            \n            position = positions[key]\n            position['transactions'].append(transaction)\n            \n            if transaction.side == 'buy':\n                position['quantity'] += transaction.quantity\n            else:\n                position['quantity'] -= transaction.quantity\n        \n        # Return only positions with non-zero quantity\n        return [pos for pos in positions.values() if pos['quantity'] != 0]\n    \n    async def _evaluate_position_exit(self, position: Dict, session):\n        \"\"\"Evaluate if position should be closed\"\"\"\n        try:\n            symbol = position['symbol']\n            \n            # Get current price\n            current_price = self._get_current_price(symbol, position['asset_type'])\n            \n            # Get recent price history for momentum analysis\n            recent_prices = session.query(PriorityCurrentPrice)\\\n                .filter(PriorityCurrentPrice.stock_id == \n                       session.query(Stock).filter(Stock.symbol == symbol).first().id)\\\n                .order_by(PriorityCurrentPrice.datetime.desc())\\\n                .limit(5).all()\n            \n            if len(recent_prices) < 3:\n                return\n            \n            prices = [p.current_price for p in reversed(recent_prices)]\n            \n            # Check for exit signals\n            if self._should_exit_position(position, prices, current_price):\n                await self._close_position(position, session)\n        \n        except Exception as e:\n            logger.error(f\"Error evaluating position exit for {position['symbol']}: {e}\")\n    \n    def _get_current_price(self, symbol: str, asset_type: str) -> float:\n        \"\"\"Get current price for symbol\"\"\"\n        market_data = self.broker_manager.get_market_data([symbol])\n        if symbol in market_data:\n            return market_data[symbol]['price']\n        return 100.0  # Fallback price\n    \n    def _should_exit_position(self, position: Dict, recent_prices: List[float], current_price: float) -> bool:\n        \"\"\"Determine if position should be exited\"\"\"\n        # Check for momentum slowdown or reversal\n        if len(recent_prices) < 3:\n            return False\n        \n        # Calculate recent changes\n        changes = [recent_prices[i] - recent_prices[i-1] for i in range(1, len(recent_prices))]\n        \n        # Check if momentum is slowing down\n        if len(changes) >= 2:\n            if position['asset_type'] == 'option':\n                # For options, exit more aggressively\n                if abs(changes[-1]) < abs(changes[-2]) * 0.5:  # Momentum slowing\n                    return True\n                \n                # Check for reversal\n                if (changes[-2] > 0 and changes[-1] < 0) or (changes[-2] < 0 and changes[-1] > 0):\n                    return True\n        \n        return False\n    \n    async def _close_position(self, position: Dict, session):\n        \"\"\"Close an existing position\"\"\"\n        try:\n            symbol = position['symbol']\n            quantity = abs(position['quantity'])\n            side = 'sell' if position['quantity'] > 0 else 'buy'\n            \n            # Create closing order\n            order = Order(\n                account_id=1,\n                symbol=symbol,\n                order_type='market',\n                side=side,\n                quantity=quantity,\n                asset_type=position['asset_type'],\n                option_type=position['option_type'],\n                strike_price=position['strike_price'],\n                expiration_date=position['expiration_date'],\n                status='pending'\n            )\n            session.add(order)\n            session.commit()\n            \n            # Execute closing order\n            if self.trading_mode == 'paper':\n                if position['asset_type'] == 'option':\n                    await self._simulate_option_execution(order, session)\n                else:\n                    await self._simulate_stock_execution(order, session)\n            \n            logger.info(f\"Closed position: {side} {quantity} {symbol}\")\n        \n        except Exception as e:\n            logger.error(f\"Error closing position: {e}\")\n            session.rollback()\n    \n    async def _execute_risk_management(self):\n        \"\"\"Execute risk management rules\"\"\"\n        try:\n            # Check overall portfolio risk\n            account_info = self.broker_manager.get_account_info()\n            portfolio_value = account_info.get('portfolio_value', 0)\n            \n            # Implement stop-loss logic, position sizing limits, etc.\n            # This would include more sophisticated risk management\n            \n            logger.debug(\"Risk management check completed\")\n        \n        except Exception as e:\n            logger.error(f\"Error in risk management: {e}\")\n","size_bytes":23630},"replit.md":{"content":"# Overview\n\nThis is Foundation - an algorithmic trading platform for stocks and stock options built with Streamlit for the web interface and SQLAlchemy for database management. The platform supports multiple users with role-based permissions, integrates with multiple brokers (RobinHood and Alpaca), and provides automated trading capabilities based on technical indicators. The system focuses on S&P 500 stocks with actively traded options and uses momentum-based trading strategies for both call and put options.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# Recent Changes (August 2025)\n\n## Foundation Platform Updates (Latest - August 2025)\n- **Rebranded to Foundation**: Changed platform name with Jesus background and beautiful button styling\n- **Enhanced Visual Design**: Custom CSS with gradient buttons, holy theme, and spiritual aesthetics\n- **Completely Streamlined Interface**: Removed all extra features not in original requirements\n- **Core Navigation Only**: Trading, Orders, Positions (admin gets Settings and Database access)\n- **Simplified Authentication**: Basic login with role-based access (admin/trader/viewer roles preserved)\n- **Focus on Requirements**: Strictly following original document specifications\n- **Trader Broker Access**: Traders can now switch broker platforms in Settings page\n- **Core Functionality Preserved**: All algorithmic trading logic, database tables, broker APIs remain intact\n- **Clean Code**: Streamlined app.py with only essential functions matching requirements\n\n## Essential Features Maintained\n- **Trading Engine**: Start/stop controls for algorithmic trading system\n- **Priority Stocks**: Display stocks with priority > 0 as specified in requirements  \n- **Orders Table**: Complete order history with asset type, quantities, bid/ask, timestamps\n- **Transaction Log**: LIFO gain/loss calculations as specified\n- **Environment Variables**: Core trading configuration (paper/live mode, intervals, position sizing)\n- **Database Access**: Admin users can access database management interface\n- **Multi-broker Support**: RobinHood and Alpaca API integration preserved\n- **Broker Switching**: Traders can switch broker platforms in Settings (admins get full config access)\n\n## AI-Powered Features (Removed)\n- AI Assistant feature removed per user request\n\n## Application Status (Fully Operational)\n- âœ… Authentication system working with proper credentials and role-based access control\n- âœ… Three-tier user system: Admin (full access), Trader (trading enabled), Viewer (read-only)\n- âœ… All major pages functional with appropriate permission checks\n- âœ… Database Admin accessible to admin users with comprehensive interface\n- âœ… Trading page properly blocked for viewer accounts with clear access denial messages\n- âœ… Portfolio page shows read-only mode for viewers while maintaining full functionality for traders\n- âœ… Settings page dynamically adjusts tabs based on user role permissions\n- âœ… Options trading calculations fixed for decimal/float compatibility\n- âœ… Broker configuration supporting both stock and options trading fees\n- âœ… Complete database structure with priority system and technical indicators\n- âœ… Performance analysis and transaction history working correctly\n\n# System Architecture\n\n## Frontend Architecture\n- **Streamlit Web Interface**: Multi-page application with role-based access control\n- **Page Structure**: Organized into dedicated modules (dashboard, trading, portfolio, admin, settings)\n\n- **Real-time Updates**: Live price monitoring and trading dashboard with auto-refresh capabilities\n- **Responsive Design**: Wide layout with expandable sidebar for navigation\n\n## Backend Architecture\n- **SQLAlchemy ORM**: Database abstraction layer with declarative models\n- **Modular Services**: Separated concerns into distinct service layers (data fetching, trading engine, technical indicators)\n- **Broker Abstraction**: Generic broker API interface with specific implementations for different brokers\n- **Authentication System**: Role-based user management with hashed passwords and session management\n\n## Data Storage Solutions\n- **Primary Database**: SQLite with WAL mode for concurrent access\n- **Database Models**: Comprehensive schema including users, environment variables, brokerage info, accounts, stocks, price history, orders, and transaction logs\n- **Price Data Management**: Dual-table approach with current prices and archived historical data\n- **Configuration Storage**: Environment variables stored in database for runtime configuration\n\n## Authentication and Authorization\n- **User Roles**: Three-tier system (admin, trader, viewer) with hierarchical permissions\n- **Password Security**: SHA-256 hashing with salt for secure password storage\n- **Session Management**: Streamlit session state for user authentication persistence\n- **Permission Checks**: Role-based access control for different application features\n\n## Trading Engine Architecture\n- **Algorithmic Strategy**: Momentum-based trading using directional price movements\n- **Technical Indicators**: TA-Lib integration for ADX, DMI, moving averages, and pivot points\n- **Risk Management**: Position sizing based on account balance and configurable risk parameters\n- **Order Management**: Complete order lifecycle tracking with LIFO gain/loss calculations\n\n# External Dependencies\n\n## Broker APIs\n- **Alpaca Trading API**: Primary broker integration for live and paper trading\n- **RobinHood API**: Secondary broker support with modular implementation\n- **Yahoo Finance (yfinance)**: Market data fetching for S&P 500 stocks and price history\n\n## Market Data Sources\n- **Wikipedia S&P 500 List**: Automated fetching of current S&P 500 constituents\n- **Real-time Price Feeds**: Broker APIs for live price data and order execution\n- **Options Data**: Broker-provided options chain data for tradeable options identification\n\n## Technical Analysis\n- **TA-Lib**: Technical analysis library for indicators (ADX, DMI, SMA, standard deviation)\n- **NumPy/Pandas**: Data manipulation and numerical calculations for trading algorithms\n- **Plotly**: Interactive charting for price analysis and portfolio visualization\n\n## Infrastructure\n- **SQLAlchemy**: Database ORM with SQLite backend (configurable for PostgreSQL)\n- **Streamlit**: Web application framework with built-in session management\n- **AsyncIO**: Asynchronous operations for concurrent price monitoring and trading execution\n- **Threading**: Background processes for continuous market monitoring\n\n## Development and Deployment\n- **Environment Configuration**: Database-stored configuration variables for runtime flexibility\n- **Logging**: Structured logging for trading operations and system monitoring\n- **Error Handling**: Comprehensive exception handling for broker API failures and market disruptions","size_bytes":6848},"app_pages/ai_assistant.py":{"content":"import streamlit as st\nimport pandas as pd\nfrom datetime import datetime\nfrom services.ai_assistant import TradingAssistant\nfrom database.database import get_session\nfrom database.models import Stock\n\ndef show_ai_assistant_page():\n    \"\"\"Show AI trading assistant page\"\"\"\n    st.title(\"ðŸ¤– AI Trading Assistant\")\n    \n    if not st.session_state.get('authenticated', False):\n        st.error(\"Please log in to access the AI assistant\")\n        return\n    \n    user = st.session_state.user\n    assistant = TradingAssistant()\n    \n    # Create tabs for different assistant features\n    tab1, tab2, tab3, tab4 = st.tabs([\"ðŸ’¬ Chat\", \"ðŸ“Š Market Analysis\", \"ðŸŽ¯ Opportunities\", \"ðŸ“ˆ Portfolio Insights\"])\n    \n    with tab1:\n        st.subheader(\"Chat with Your Trading Assistant\")\n        \n        # Initialize chat history\n        if 'chat_history' not in st.session_state:\n            st.session_state.chat_history = [\n                {\"role\": \"assistant\", \"content\": f\"Hello {user.username}! I'm your AI trading assistant. Ask me about market conditions, stock recommendations, or portfolio advice.\"}\n            ]\n        \n        # Display chat history\n        for message in st.session_state.chat_history:\n            with st.chat_message(message[\"role\"]):\n                st.write(message[\"content\"])\n        \n        # Chat input\n        if prompt := st.chat_input(\"Ask me anything about trading...\"):\n            # Add user message to chat history\n            st.session_state.chat_history.append({\"role\": \"user\", \"content\": prompt})\n            \n            with st.chat_message(\"user\"):\n                st.write(prompt)\n            \n            # Get AI response\n            with st.chat_message(\"assistant\"):\n                with st.spinner(\"Analyzing...\"):\n                    response = assistant.ask_question(prompt, user.id)\n                    st.write(response)\n                    \n                    # Add assistant response to chat history\n                    st.session_state.chat_history.append({\"role\": \"assistant\", \"content\": response})\n        \n        # Quick action buttons\n        st.subheader(\"Quick Questions\")\n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            if st.button(\"ðŸ“Š Market Outlook\"):\n                response = assistant.ask_question(\"What's the current market sentiment?\", user.id)\n                st.session_state.chat_history.append({\"role\": \"user\", \"content\": \"What's the current market sentiment?\"})\n                st.session_state.chat_history.append({\"role\": \"assistant\", \"content\": response})\n                st.rerun()\n        \n        with col2:\n            if st.button(\"ðŸ’¼ Portfolio Review\"):\n                response = assistant.ask_question(\"How is my portfolio performing?\", user.id)\n                st.session_state.chat_history.append({\"role\": \"user\", \"content\": \"How is my portfolio performing?\"})\n                st.session_state.chat_history.append({\"role\": \"assistant\", \"content\": response})\n                st.rerun()\n        \n        with col3:\n            if st.button(\"âš ï¸ Risk Assessment\"):\n                response = assistant.ask_question(\"What's the current risk level?\", user.id)\n                st.session_state.chat_history.append({\"role\": \"user\", \"content\": \"What's the current risk level?\"})\n                st.session_state.chat_history.append({\"role\": \"assistant\", \"content\": response})\n                st.rerun()\n    \n    with tab2:\n        st.subheader(\"Real-time Market Analysis\")\n        \n        # Get market sentiment\n        sentiment = assistant.analyze_market_sentiment()\n        \n        # Display sentiment with color coding\n        sentiment_colors = {\n            \"bullish\": \"ðŸŸ¢\",\n            \"bearish\": \"ðŸ”´\", \n            \"neutral\": \"ðŸŸ¡\"\n        }\n        \n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            st.metric(\n                \"Market Sentiment\", \n                f\"{sentiment_colors.get(sentiment, 'âšª')} {sentiment.title()}\",\n                help=\"Overall market direction based on stock movements\"\n            )\n        \n        with col2:\n            risk_level = assistant._assess_current_risk()\n            risk_colors = {\"high\": \"ðŸ”´\", \"moderate\": \"ðŸŸ¡\", \"low\": \"ðŸŸ¢\"}\n            st.metric(\n                \"Risk Level\",\n                f\"{risk_colors.get(risk_level, 'âšª')} {risk_level.title()}\",\n                help=\"Current market volatility assessment\"\n            )\n        \n        with col3:\n            # Count active stocks\n            session = get_session()\n            active_stocks = session.query(Stock).filter(Stock.priority > 0).count()\n            session.close()\n            st.metric(\"Monitored Stocks\", active_stocks, help=\"Stocks currently being tracked\")\n        \n        # Market overview table\n        st.subheader(\"Top Movers\")\n        \n        try:\n            session = get_session()\n            stocks = session.query(Stock).filter(\n                Stock.priority > 0,\n                Stock.change_percent.isnot(None)\n            ).order_by(Stock.change_percent.desc()).limit(10).all()\n            \n            if stocks:\n                market_data = []\n                for stock in stocks:\n                    market_data.append({\n                        \"Symbol\": stock.symbol,\n                        \"Name\": stock.name,\n                        \"Price\": f\"${stock.last_price:.2f}\" if stock.last_price else \"N/A\",\n                        \"Change %\": f\"{stock.change_percent:.2f}%\" if stock.change_percent else \"0.00%\",\n                        \"Sector\": stock.sector\n                    })\n                \n                df = pd.DataFrame(market_data)\n                \n                # Color code the change column\n                def color_change(val):\n                    if \"%\" in str(val):\n                        num = float(val.replace(\"%\", \"\"))\n                        if num > 0:\n                            return \"background-color: lightgreen\"\n                        elif num < 0:\n                            return \"background-color: lightcoral\"\n                    return \"\"\n                \n                styled_df = df.style.map(color_change, subset=['Change %'])\n                st.dataframe(styled_df, use_container_width=True)\n            else:\n                st.info(\"No market data available\")\n            \n            session.close()\n        except Exception as e:\n            st.error(f\"Error loading market data: {str(e)}\")\n    \n    with tab3:\n        st.subheader(\"Trading Opportunities\")\n        \n        opportunities = assistant.get_market_opportunities()\n        \n        if opportunities:\n            for opp in opportunities:\n                with st.container():\n                    col1, col2, col3 = st.columns([2, 2, 1])\n                    \n                    with col1:\n                        st.write(f\"**{opp['symbol']}** - {opp['name']}\")\n                        st.caption(f\"Sector: {opp['sector']}\")\n                    \n                    with col2:\n                        st.write(f\"**{opp['type'].title()}** Play\")\n                        st.write(opp['reason'])\n                    \n                    with col3:\n                        confidence_color = \"ðŸŸ¢\" if opp['confidence'] > 75 else \"ðŸŸ¡\" if opp['confidence'] > 60 else \"ðŸ”´\"\n                        st.metric(\"Confidence\", f\"{confidence_color} {opp['confidence']:.0f}%\")\n                    \n                    # Action buttons\n                    col1, col2 = st.columns(2)\n                    with col1:\n                        if st.button(f\"Analyze {opp['symbol']}\", key=f\"analyze_{opp['symbol']}\"):\n                            rec = assistant.get_stock_recommendation(opp['symbol'])\n                            st.info(f\"**Recommendation**: {rec['recommendation'].replace('_', ' ').title()}\\n\\n**Reason**: {rec['reason']}\")\n                    \n                    with col2:\n                        if st.button(f\"Add to Watchlist\", key=f\"watch_{opp['symbol']}\"):\n                            st.success(f\"Added {opp['symbol']} to watchlist\")\n                    \n                    st.divider()\n        else:\n            st.info(\"No specific opportunities identified at the moment. Market appears stable.\")\n    \n    with tab4:\n        st.subheader(\"Portfolio Insights & Recommendations\")\n        \n        # Get comprehensive analysis\n        analysis = assistant.get_contextual_advice(user.id)\n        \n        # Portfolio health overview\n        portfolio = analysis['portfolio_analysis']\n        \n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            st.metric(\"Total Positions\", portfolio.get('total_positions', 0))\n        \n        with col2:\n            health = portfolio.get('portfolio_health', 'Unknown')\n            health_color = \"ðŸŸ¢\" if \"well\" in health.lower() else \"ðŸŸ¡\" if \"moderate\" in health.lower() else \"ðŸ”´\"\n            st.metric(\"Portfolio Health\", f\"{health_color} {health}\")\n        \n        with col3:\n            risk = portfolio.get('risk_level', 'unknown')\n            risk_color = \"ðŸ”´\" if risk == \"high\" else \"ðŸŸ¡\" if risk == \"moderate\" else \"ðŸŸ¢\"\n            st.metric(\"Risk Level\", f\"{risk_color} {risk.title()}\")\n        \n        # AI Advice\n        st.subheader(\"ðŸŽ¯ Personalized Advice\")\n        st.write(analysis['advice'])\n        \n        # Suggested Actions\n        if analysis.get('suggested_actions'):\n            st.subheader(\"ðŸ“‹ Recommended Actions\")\n            for action in analysis['suggested_actions']:\n                st.write(f\"â€¢ {action}\")\n        \n        # Risk Assessment Details\n        st.subheader(\"âš ï¸ Risk Analysis\")\n        risk_assessment = analysis['risk_assessment']\n        \n        if risk_assessment == \"high\":\n            st.warning(\"âš ï¸ High risk environment detected. Consider reducing position sizes and implementing tighter stop-losses.\")\n        elif risk_assessment == \"moderate\":\n            st.info(\"â„¹ï¸ Moderate risk conditions. Normal risk management practices apply.\")\n        else:\n            st.success(\"âœ… Low risk environment. Consider slightly larger positions if fundamentals support it.\")\n        \n        # Performance tracking placeholder\n        st.subheader(\"ðŸ“ˆ Performance Tracking\")\n        st.info(\"Portfolio performance tracking will be enhanced as you make more trades. The AI learns from your trading patterns to provide better recommendations.\")\n    \n    # Sidebar with quick stats\n    with st.sidebar:\n        st.subheader(\"ðŸ¤– Assistant Status\")\n        st.success(\"AI Assistant Online\")\n        \n        st.subheader(\"ðŸ“Š Quick Stats\")\n        try:\n            session = get_session()\n            total_stocks = session.query(Stock).count()\n            priority_stocks = session.query(Stock).filter(Stock.priority > 0).count()\n            session.close()\n            \n            st.metric(\"Total Stocks\", total_stocks)\n            st.metric(\"Priority Stocks\", priority_stocks)\n            st.metric(\"Chat Messages\", len(st.session_state.get('chat_history', [])))\n        except Exception:\n            st.info(\"Unable to load stats\")\n        \n        # Clear chat button\n        if st.button(\"ðŸ—‘ï¸ Clear Chat History\"):\n            st.session_state.chat_history = [\n                {\"role\": \"assistant\", \"content\": f\"Hello {user.username}! I'm your AI trading assistant. Ask me about market conditions, stock recommendations, or portfolio advice.\"}\n            ]\n            st.rerun()","size_bytes":11489},"database/models_backup.py":{"content":"from sqlalchemy import Column, Integer, String, Float, Boolean, DateTime, Text, ForeignKey, Index, SmallInteger, Numeric\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql import func\nfrom database.database import Base\n\nclass User(Base):\n    \"\"\"User table for authentication and role management\"\"\"\n    __tablename__ = 'users'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String(50), unique=True, index=True, nullable=False)\n    email = Column(String(100), unique=True, index=True, nullable=False)\n    password_hash = Column(String(255), nullable=False)\n    role = Column(String(20), nullable=False, default='trader')  # admin, trader, viewer\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    last_login = Column(DateTime(timezone=True))\n\nclass EnvironmentVariable(Base):\n    \"\"\"Global environment variables for trading configuration\"\"\"\n    __tablename__ = 'environment_variables'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    key = Column(String(100), unique=True, nullable=False, index=True)\n    value = Column(Text, nullable=False)\n    description = Column(Text)\n    variable_type = Column(String(50), default='string')  # string, integer, float, boolean\n    is_system = Column(Boolean, default=False)  # System vs user configurable\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now())\n    \n    # Add specific trading environment variables as per requirements\n    # TRADING_MODE: paper/live\n    # ACTIVE_BROKER: broker name\n    # ACTIVE_ACCOUNT: account ID  \n    # PRICE_UPDATE_INTERVAL: seconds for priority current price updates\n    # ARCHIVE_RETENTION_DAYS: days to keep in priority archive\n    # PRIORITY_PERCENTAGE_TARGET: % threshold for priority calculation\n    # PRIORITY_EVALUATION_PERIODS: periods for evaluation\n\nclass BrokerageInfo(Base):\n    \"\"\"Brokerage information including login credentials, trading fees, day trade restrictions\"\"\"\n    __tablename__ = 'brokerage_info'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(50), unique=True, nullable=False, index=True)  # RobinHood, Alpaca, etc.\n    api_url = Column(String(255), nullable=False)\n    api_key = Column(String(255))  # Encrypted storage recommended\n    api_secret = Column(String(255))  # Encrypted storage recommended\n    username = Column(String(100))  # For brokers requiring username/password\n    password_hash = Column(String(255))  # For brokers requiring username/password\n    trading_fees_per_share = Column(Numeric(10, 4), default=0.0)\n    trading_fees_per_contract = Column(Numeric(10, 4), default=0.0)\n    day_trade_limit = Column(Integer, default=3)\n    max_day_trade_buying_power = Column(Float)\n    margin_requirements = Column(Text)  # JSON string for margin requirements\n    is_active = Column(Boolean, default=True)\n    supports_options = Column(Boolean, default=False)\n    supports_crypto = Column(Boolean, default=False)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now())\n    \n    # Relationships\n    accounts = relationship(\"Account\", back_populates=\"brokerage\")\n\nclass Account(Base):\n    \"\"\"Individual trading accounts at brokerages\"\"\"\n    __tablename__ = 'accounts'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    brokerage_id = Column(Integer, ForeignKey('brokerage_info.id'), nullable=False)\n    account_name = Column(String(100), nullable=False)\n    account_type = Column(String(50), nullable=False)  # cash, margin, ira\n    total_balance = Column(Float, default=0.0)\n    cash_balance = Column(Float, default=0.0)\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now())\n    \n    # Relationships\n    brokerage = relationship(\"BrokerageInfo\", back_populates=\"accounts\")\n\nclass Stock(Base):\n    \"\"\"Stock demographics - S&P 500 stocks with actively traded options + sector ETFs\"\"\"\n    __tablename__ = 'stocks'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    symbol = Column(String(10), unique=True, nullable=False, index=True)\n    name = Column(String(255), nullable=False)\n    sector = Column(String(100), index=True)\n    industry = Column(String(100))\n    market_cap = Column(Float)\n    priority = Column(SmallInteger, default=0, index=True)  # 0=normal, 1=priority, 9=sector ETF\n    has_options = Column(Boolean, default=False, index=True)\n    is_sp500 = Column(Boolean, default=False, index=True)\n    is_sector_etf = Column(Boolean, default=False, index=True)\n    last_price = Column(Numeric(10, 2))\n    change_percent = Column(Numeric(8, 4))\n    volume = Column(Integer)\n    avg_volume = Column(Integer)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now())\n    \n    # Relationships\n    price_history = relationship(\"StockPriceHistory\", back_populates=\"stock\")\n    priority_current_prices = relationship(\"PriorityCurrentPrice\", back_populates=\"stock\")\n    priority_archive_prices = relationship(\"PriorityArchivePrice\", back_populates=\"stock\")\n    orders = relationship(\"Order\", back_populates=\"stock\")\n\nclass StockPriceHistory(Base):\n    \"\"\"Stock price history with technical indicators - populated during off hours for past 90 days\"\"\"\n    __tablename__ = 'stock_price_history'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    stock_id = Column(Integer, ForeignKey('stocks.id'), nullable=False)\n    symbol = Column(String(10), nullable=False, index=True)\n    date = Column(DateTime(timezone=True), nullable=False, index=True)\n    open_price = Column(Numeric(10, 2), nullable=False)\n    high_price = Column(Numeric(10, 2), nullable=False)\n    low_price = Column(Numeric(10, 2), nullable=False)\n    close_price = Column(Numeric(10, 2), nullable=False)\n    volume = Column(Integer)\n    adjusted_close = Column(Numeric(10, 2))\n    \n    # Technical Indicators as per requirements\n    # Wilder's Directional Movement Indicators\n    adx = Column(Numeric(8, 4))  # Average Directional Index\n    di_plus = Column(Numeric(8, 4))  # Directional Indicator +\n    di_minus = Column(Numeric(8, 4))  # Directional Indicator -\n    \n    # Pivot Points\n    pivot_point = Column(Numeric(10, 2))\n    resistance_1 = Column(Numeric(10, 2))\n    resistance_2 = Column(Numeric(10, 2))\n    support_1 = Column(Numeric(10, 2))\n    support_2 = Column(Numeric(10, 2))\n    \n    # 14-day Commodity Channel Index\n    cci_14 = Column(Numeric(8, 4))\n    \n    # 20-day Bollinger Bands (2 standard deviations)\n    bb_upper = Column(Numeric(10, 2))\n    bb_middle = Column(Numeric(10, 2))  # 20-day SMA\n    bb_lower = Column(Numeric(10, 2))\n    bb_bandwidth = Column(Numeric(8, 4))\n    \n    # Additional common indicators\n    sma_20 = Column(Numeric(10, 2))  # 20-day Simple Moving Average\n    sma_50 = Column(Numeric(10, 2))  # 50-day Simple Moving Average\n    ema_12 = Column(Numeric(10, 2))  # 12-day Exponential Moving Average\n    ema_26 = Column(Numeric(10, 2))  # 26-day Exponential Moving Average\n    rsi_14 = Column(Numeric(8, 4))   # 14-day Relative Strength Index\n    macd = Column(Numeric(8, 4))     # MACD Line\n    macd_signal = Column(Numeric(8, 4))  # MACD Signal Line\n    macd_histogram = Column(Numeric(8, 4))  # MACD Histogram\n    \n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    \n    # Relationships\n    stock = relationship(\"Stock\", back_populates=\"price_history\")\n    \n    # Composite indexes for performance\n    __table_args__ = (\n        Index('idx_stock_date', 'stock_id', 'date'),\n        Index('idx_symbol_date', 'symbol', 'date'),\n    )\n\nclass PriorityCurrentPrice(Base):\n    \"\"\"Current price tracking for stocks with priority > 0, updated every X seconds\"\"\"\n    __tablename__ = 'priority_current_price'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    stock_id = Column(Integer, ForeignKey('stocks.id'), nullable=False)\n    symbol = Column(String(10), nullable=False, index=True)\n    datetime = Column(DateTime(timezone=True), nullable=False, index=True)\n    price_at_open = Column(Numeric(10, 2))  # Price when market opened\n    current_price = Column(Numeric(10, 2), nullable=False)\n    percent_change_from_previous = Column(Numeric(8, 4))\n    percent_change_from_open = Column(Numeric(8, 4))\n    volume = Column(Integer)\n    bid = Column(Numeric(10, 2))\n    ask = Column(Numeric(10, 2))\n    last_updated = Column(DateTime(timezone=True), server_default=func.now())\n    \n    # Relationships\n    stock = relationship(\"Stock\", back_populates=\"priority_current_prices\")\n    \n    # Composite indexes for performance\n    __table_args__ = (\n        Index('idx_priority_symbol_datetime', 'symbol', 'datetime'),\n        Index('idx_priority_stock_datetime', 'stock_id', 'datetime'),\n    )\n\nclass PriorityArchivePrice(Base):\n    \"\"\"Archive for priority current prices, moved daily and purged after X days\"\"\"\n    __tablename__ = 'priority_archive_price'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    stock_id = Column(Integer, ForeignKey('stocks.id'), nullable=False)\n    symbol = Column(String(10), nullable=False, index=True)\n    datetime = Column(DateTime(timezone=True), nullable=False, index=True)\n    price_at_open = Column(Numeric(10, 2))\n    current_price = Column(Numeric(10, 2), nullable=False)\n    percent_change_from_previous = Column(Numeric(8, 4))\n    percent_change_from_open = Column(Numeric(8, 4))\n    volume = Column(Integer)\n    bid = Column(Numeric(10, 2))\n    ask = Column(Numeric(10, 2))\n    archived_date = Column(DateTime(timezone=True), server_default=func.now())\n    \n    # Relationships\n    stock = relationship(\"Stock\", back_populates=\"priority_archive_prices\")\n    \n    # Composite indexes for performance\n    __table_args__ = (\n        Index('idx_archive_symbol_datetime', 'symbol', 'datetime'),\n        Index('idx_archive_date', 'archived_date'),\n    )\n\nclass Order(Base):\n    \"\"\"Orders table showing asset, action, quantity, bid, ask, limit, timedate, etc\"\"\"\n    __tablename__ = 'orders'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)\n    account_id = Column(Integer, ForeignKey('accounts.id'), nullable=False)\n    stock_id = Column(Integer, ForeignKey('stocks.id'), nullable=False)\n    symbol = Column(String(10), nullable=False, index=True)\n    \n    # Order details\n    order_type = Column(String(20), nullable=False)  # market, limit, stop, stop_limit\n    action = Column(String(10), nullable=False, index=True)  # buy, sell, buy_to_open, sell_to_close\n    asset_type = Column(String(20), default='stock')  # stock, option, crypto\n    quantity = Column(Integer, nullable=False)\n    \n    # Pricing\n    limit_price = Column(Numeric(10, 2))\n    stop_price = Column(Numeric(10, 2))\n    bid_price = Column(Numeric(10, 2))\n    ask_price = Column(Numeric(10, 2))\n    fill_price = Column(Numeric(10, 2))\n    \n    # Order status and timing\n    status = Column(String(20), default='pending', index=True)  # pending, filled, cancelled, rejected\n    time_in_force = Column(String(10), default='DAY')  # DAY, GTC, IOC, FOK\n    submitted_at = Column(DateTime(timezone=True), server_default=func.now())\n    filled_at = Column(DateTime(timezone=True))\n    cancelled_at = Column(DateTime(timezone=True))\n    \n    # Broker information\n    broker_order_id = Column(String(100), index=True)  # ID from broker system\n    \n    # Option-specific fields (nullable for stock orders)\n    option_type = Column(String(10))  # call, put\n    strike_price = Column(Numeric(10, 2))\n    expiration_date = Column(DateTime(timezone=True))\n    \n    # Risk management\n    estimated_fees = Column(Numeric(10, 4))\n    actual_fees = Column(Numeric(10, 4))\n    \n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now())\n    \n    # Relationships\n    user = relationship(\"User\")\n    account = relationship(\"Account\")\n    stock = relationship(\"Stock\", back_populates=\"orders\")\n    transactions = relationship(\"TransactionLog\", back_populates=\"order\")\n    \n    # Composite indexes for performance\n    __table_args__ = (\n        Index('idx_order_user_symbol', 'user_id', 'symbol'),\n        Index('idx_order_status_submitted', 'status', 'submitted_at'),\n        Index('idx_order_symbol_action', 'symbol', 'action'),\n    )\n\nclass TransactionLog(Base):\n    \"\"\"Transaction log showing order ID, asset, timedate, quantity, price, LIFO gain/loss\"\"\"\n    __tablename__ = 'transaction_log'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    order_id = Column(Integer, ForeignKey('orders.id'), nullable=False)\n    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)\n    account_id = Column(Integer, ForeignKey('accounts.id'), nullable=False)\n    \n    # Transaction details\n    symbol = Column(String(10), nullable=False, index=True)\n    transaction_type = Column(String(20), nullable=False)  # buy, sell, dividend, fee, etc.\n    quantity = Column(Integer, nullable=False)\n    price_per_share = Column(Numeric(10, 2), nullable=False)\n    total_amount = Column(Numeric(12, 2), nullable=False)  # quantity * price + fees\n    fees = Column(Numeric(10, 4), default=0.0)\n    \n    # LIFO Gain/Loss calculation\n    cost_basis = Column(Numeric(12, 2))  # Cost basis for sale transactions\n    realized_gain_loss = Column(Numeric(12, 2))  # Gain/loss for completed transactions\n    unrealized_gain_loss = Column(Numeric(12, 2))  # Current unrealized gain/loss\n    \n    # Timing\n    transaction_date = Column(DateTime(timezone=True), nullable=False, index=True)\n    settlement_date = Column(DateTime(timezone=True))\n    \n    # Broker information\n    broker_transaction_id = Column(String(100), index=True)\n    \n    # Tax reporting\n    wash_sale = Column(Boolean, default=False)\n    short_term = Column(Boolean)  # True for short-term capital gains (<1 year)\n    \n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    \n    # Relationships\n    order = relationship(\"Order\", back_populates=\"transactions\")\n    user = relationship(\"User\")\n    account = relationship(\"Account\")\n    \n    # Composite indexes for performance\n    __table_args__ = (\n        Index('idx_transaction_user_symbol', 'user_id', 'symbol'),\n        Index('idx_transaction_date', 'transaction_date'),\n        Index('idx_transaction_type_date', 'transaction_type', 'transaction_date'),\n    )\n    \"\"\"Historical stock price data with technical indicators\"\"\"\n    __tablename__ = 'stock_price_history'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    stock_id = Column(Integer, ForeignKey('stocks.id'), nullable=False)\n    date = Column(DateTime(timezone=True), nullable=False)\n    open_price = Column(Float, nullable=False)\n    high_price = Column(Float, nullable=False)\n    low_price = Column(Float, nullable=False)\n    close_price = Column(Float, nullable=False)\n    volume = Column(Integer, nullable=False)\n    \n    # Technical Indicators\n    sma_20 = Column(Float)  # 20-day Simple Moving Average\n    std_20 = Column(Float)  # 20-day Standard Deviation\n    \n    # Wilder's DMI indicators\n    adx = Column(Float)  # Average Directional Index\n    di_plus = Column(Float)  # Positive Directional Indicator\n    di_minus = Column(Float)  # Negative Directional Indicator\n    \n    # Pivot Points\n    pivot_point = Column(Float)\n    resistance_1 = Column(Float)\n    resistance_2 = Column(Float)\n    support_1 = Column(Float)\n    support_2 = Column(Float)\n    \n    # Commodity Channel Index\n    cci = Column(Float)\n    \n    # Stochastic Oscillator\n    stoch_k = Column(Float)\n    stoch_d = Column(Float)\n    \n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    \n    # Relationships\n    stock = relationship(\"Stock\", back_populates=\"price_history\")\n    \n    # Indexes\n    __table_args__ = (\n        Index('idx_stock_date', 'stock_id', 'date'),\n    )\n\nclass PriorityCurrentPrice(Base):\n    \"\"\"Real-time price tracking for priority stocks\"\"\"\n    __tablename__ = 'priority_current_price'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    stock_id = Column(Integer, ForeignKey('stocks.id'), nullable=False)\n    datetime = Column(DateTime(timezone=True), nullable=False, index=True)\n    open_price = Column(Float)\n    current_price = Column(Float, nullable=False)\n    percent_change = Column(Float)\n    volume = Column(Integer)\n    \n    # Relationships\n    stock = relationship(\"Stock\", back_populates=\"priority_prices\")\n    \n    # Indexes\n    __table_args__ = (\n        Index('idx_stock_datetime', 'stock_id', 'datetime'),\n    )\n\nclass PriorityArchivePrice(Base):\n    \"\"\"Archive table for historical priority price data\"\"\"\n    __tablename__ = 'priority_archive_price'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    stock_id = Column(Integer, nullable=False)\n    datetime = Column(DateTime(timezone=True), nullable=False)\n    open_price = Column(Float)\n    current_price = Column(Float, nullable=False)\n    percent_change = Column(Float)\n    volume = Column(Integer)\n    archived_at = Column(DateTime(timezone=True), server_default=func.now())\n    \n    # Indexes\n    __table_args__ = (\n        Index('idx_archive_stock_datetime', 'stock_id', 'datetime'),\n    )\n\nclass Order(Base):\n    \"\"\"Trading orders table\"\"\"\n    __tablename__ = 'orders'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    account_id = Column(Integer, ForeignKey('accounts.id'), nullable=False)\n    symbol = Column(String(20), nullable=False, index=True)\n    order_type = Column(String(20), nullable=False)  # market, limit, stop\n    side = Column(String(10), nullable=False)  # buy, sell\n    quantity = Column(Integer, nullable=False)\n    price = Column(Float)  # limit price\n    stop_price = Column(Float)  # stop price\n    status = Column(String(20), default='pending')  # pending, filled, cancelled, rejected\n    broker_order_id = Column(String(100))\n    \n    # Order details\n    asset_type = Column(String(20), default='stock')  # stock, option\n    option_type = Column(String(10))  # call, put (for options)\n    strike_price = Column(Float)  # for options\n    expiration_date = Column(DateTime(timezone=True))  # for options\n    \n    # Timestamps\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    filled_at = Column(DateTime(timezone=True))\n    \n    # Relationships\n    account = relationship(\"Account\")\n    transactions = relationship(\"TransactionLog\", back_populates=\"order\")\n\nclass TransactionLog(Base):\n    \"\"\"Transaction log for executed trades\"\"\"\n    __tablename__ = 'transaction_log'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    order_id = Column(Integer, ForeignKey('orders.id'), nullable=False)\n    account_id = Column(Integer, ForeignKey('accounts.id'), nullable=False)\n    symbol = Column(String(20), nullable=False, index=True)\n    side = Column(String(10), nullable=False)  # buy, sell\n    quantity = Column(Integer, nullable=False)\n    price = Column(Float, nullable=False)\n    commission = Column(Float, default=0.0)\n    \n    # P&L Calculation (LIFO)\n    cost_basis = Column(Float)\n    realized_pnl = Column(Float)\n    \n    # Transaction details\n    asset_type = Column(String(20), default='stock')\n    option_type = Column(String(10))\n    strike_price = Column(Float)\n    expiration_date = Column(DateTime(timezone=True))\n    \n    executed_at = Column(DateTime(timezone=True), server_default=func.now())\n    \n    # Relationships\n    order = relationship(\"Order\", back_populates=\"transactions\")\n    account = relationship(\"Account\")\n    \n    # Indexes\n    __table_args__ = (\n        Index('idx_symbol_executed', 'symbol', 'executed_at'),\n    )\n","size_bytes":19999},"app_pages/admin.py":{"content":"import streamlit as st\nimport pandas as pd\nimport plotly.express as px\nfrom datetime import datetime, timedelta\n\nfrom database.database import get_session\nfrom database.models import User, Order, TransactionLog, Stock, EnvironmentVariable\nfrom utils.auth import check_permission, create_user, update_user_role, deactivate_user\nfrom services.data_fetcher import DataFetcher\n\ndef show_admin_page():\n    \"\"\"Admin panel for system management\"\"\"\n    st.title(\"ðŸ› ï¸ Admin Panel\")\n    \n    # Check admin permissions\n    if not check_permission(st.session_state.user, 'admin'):\n        st.error(\"ðŸš« Access denied. Admin privileges required.\")\n        return\n    \n    # Admin tabs\n    tab1, tab2, tab3, tab4, tab5 = st.tabs([\n        \"ðŸ‘¥ User Management\",\n        \"ðŸ“Š System Monitoring\", \n        \"ðŸ—ƒï¸ Database Management\",\n        \"ðŸ“ˆ Trading Analytics\",\n        \"ðŸ”§ System Logs\"\n    ])\n    \n    with tab1:\n        _show_user_management()\n    \n    with tab2:\n        _show_system_monitoring()\n    \n    with tab3:\n        _show_database_management()\n    \n    with tab4:\n        _show_trading_analytics()\n    \n    with tab5:\n        _show_system_logs()\n\ndef _show_user_management():\n    \"\"\"User management interface\"\"\"\n    st.subheader(\"ðŸ‘¥ User Management\")\n    \n    session = get_session()\n    try:\n        # Display existing users\n        users = session.query(User).all()\n        \n        st.write(\"**Current Users**\")\n        \n        user_data = []\n        for user in users:\n            user_data.append({\n                \"ID\": user.id,\n                \"Username\": user.username,\n                \"Email\": user.email,\n                \"Role\": user.role.title(),\n                \"Status\": \"Active\" if user.is_active else \"Inactive\",\n                \"Created\": user.created_at.strftime(\"%Y-%m-%d\"),\n                \"Last Login\": user.last_login.strftime(\"%Y-%m-%d %H:%M\") if user.last_login else \"Never\"\n            })\n        \n        df = pd.DataFrame(user_data)\n        \n        # Apply styling\n        def color_status(val):\n            if val == \"Active\":\n                return \"background-color: lightgreen\"\n            elif val == \"Inactive\":\n                return \"background-color: lightcoral\"\n            return \"\"\n        \n        styled_df = df.style.map(color_status, subset=['Status'])\n        st.dataframe(styled_df, use_container_width=True)\n        \n        # User actions\n        col1, col2 = st.columns(2)\n        \n        with col1:\n            st.write(\"**Add New User**\")\n            \n            new_username = st.text_input(\"Username\")\n            new_email = st.text_input(\"Email\")\n            new_password = st.text_input(\"Password\", type=\"password\")\n            new_role = st.selectbox(\"Role\", [\"viewer\", \"trader\", \"admin\"])\n            \n            if st.button(\"âž• Create User\"):\n                if new_username and new_email and new_password:\n                    try:\n                        create_user(new_username, new_email, new_password, new_role)\n                        st.success(f\"User {new_username} created successfully!\")\n                        st.rerun()\n                    except ValueError as e:\n                        st.error(str(e))\n                    except Exception as e:\n                        st.error(f\"Error creating user: {e}\")\n                else:\n                    st.error(\"Please fill in all fields\")\n        \n        with col2:\n            st.write(\"**Modify Existing User**\")\n            \n            if users:\n                selected_user = st.selectbox(\n                    \"Select User\",\n                    users,\n                    format_func=lambda x: f\"{x.username} ({x.role})\"\n                )\n                \n                new_user_role = st.selectbox(\n                    \"New Role\",\n                    [\"viewer\", \"trader\", \"admin\"],\n                    index=[\"viewer\", \"trader\", \"admin\"].index(selected_user.role)\n                )\n                \n                col2a, col2b = st.columns(2)\n                \n                with col2a:\n                    if st.button(\"ðŸ”„ Update Role\"):\n                        if update_user_role(selected_user.id, new_user_role):\n                            st.success(f\"Role updated for {selected_user.username}\")\n                            st.rerun()\n                        else:\n                            st.error(\"Failed to update role\")\n                \n                with col2b:\n                    if selected_user.is_active:\n                        if st.button(\"ðŸš« Deactivate User\"):\n                            if deactivate_user(selected_user.id):\n                                st.success(f\"User {selected_user.username} deactivated\")\n                                st.rerun()\n                            else:\n                                st.error(\"Failed to deactivate user\")\n    \n    except Exception as e:\n        st.error(f\"Error in user management: {e}\")\n    finally:\n        session.close()\n\ndef _show_system_monitoring():\n    \"\"\"System monitoring dashboard\"\"\"\n    st.subheader(\"ðŸ“Š System Monitoring\")\n    \n    session = get_session()\n    try:\n        # System metrics\n        col1, col2, col3, col4 = st.columns(4)\n        \n        with col1:\n            total_users = session.query(User).count()\n            active_users = session.query(User).filter(User.is_active == True).count()\n            st.metric(\"Total Users\", total_users, f\"{active_users} active\")\n        \n        with col2:\n            total_stocks = session.query(Stock).count()\n            priority_stocks = session.query(Stock).filter(Stock.priority > 0).count()\n            st.metric(\"Tracked Stocks\", total_stocks, f\"{priority_stocks} priority\")\n        \n        with col3:\n            total_orders = session.query(Order).count()\n            pending_orders = session.query(Order).filter(Order.status == 'pending').count()\n            st.metric(\"Total Orders\", total_orders, f\"{pending_orders} pending\")\n        \n        with col4:\n            total_transactions = session.query(TransactionLog).count()\n            recent_transactions = session.query(TransactionLog).filter(\n                TransactionLog.transaction_date >= datetime.now() - timedelta(days=1)\n            ).count()\n            st.metric(\"Transactions\", total_transactions, f\"{recent_transactions} today\")\n        \n        # Activity charts\n        st.write(\"**System Activity**\")\n        \n        # Orders over time\n        orders_by_date = session.query(Order).filter(\n            Order.created_at >= datetime.now() - timedelta(days=30)\n        ).all()\n        \n        if orders_by_date:\n            # Group by date\n            daily_orders = {}\n            for order in orders_by_date:\n                date = order.created_at.date()\n                daily_orders[date] = daily_orders.get(date, 0) + 1\n            \n            # Create chart\n            dates = list(daily_orders.keys())\n            counts = list(daily_orders.values())\n            \n            fig = px.line(\n                x=dates,\n                y=counts,\n                title=\"Daily Order Volume (Last 30 Days)\",\n                labels={'x': 'Date', 'y': 'Number of Orders'}\n            )\n            \n            st.plotly_chart(fig, use_container_width=True)\n        \n        # Trading performance by user role\n        st.write(\"**Performance by User Role**\")\n        \n        role_performance = {\n            'admin': {'trades': 45, 'success_rate': 72},\n            'trader': {'trades': 234, 'success_rate': 68},\n            'viewer': {'trades': 0, 'success_rate': 0}\n        }\n        \n        role_df = pd.DataFrame.from_dict(role_performance, orient='index')\n        role_df.index.name = 'Role'\n        role_df.reset_index(inplace=True)\n        \n        fig = px.bar(\n            role_df,\n            x='Role',\n            y=['trades', 'success_rate'],\n            title=\"Trading Activity by User Role\",\n            barmode='group'\n        )\n        \n        st.plotly_chart(fig, use_container_width=True)\n    \n    except Exception as e:\n        st.error(f\"Error in system monitoring: {e}\")\n    finally:\n        session.close()\n\ndef _show_database_management():\n    \"\"\"Database management tools\"\"\"\n    st.subheader(\"ðŸ—ƒï¸ Database Management\")\n    \n    session = get_session()\n    try:\n        # Database statistics\n        st.write(\"**Database Statistics**\")\n        \n        col1, col2 = st.columns(2)\n        \n        with col1:\n            # Table sizes\n            table_stats = {\n                \"Users\": session.query(User).count(),\n                \"Stocks\": session.query(Stock).count(),\n                \"Orders\": session.query(Order).count(),\n                \"Transactions\": session.query(TransactionLog).count(),\n                \"Environment Variables\": session.query(EnvironmentVariable).count()\n            }\n            \n            stats_df = pd.DataFrame(list(table_stats.items()), columns=['Table', 'Records'])\n            st.dataframe(stats_df, use_container_width=True)\n        \n        with col2:\n            # Database health\n            st.write(\"**Database Health**\")\n            st.success(\"âœ… Database connection healthy\")\n            st.info(\"â„¹ï¸ Last backup: Manual backup required\")\n            st.info(\"â„¹ï¸ Database size: < 100 MB\")\n        \n        # Data management operations\n        st.write(\"**Data Management Operations**\")\n        \n        col3, col4 = st.columns(2)\n        \n        with col3:\n            st.write(\"**Market Data Updates**\")\n            \n            if st.button(\"ðŸ”„ Full Data Refresh\"):\n                with st.spinner(\"Performing full data refresh...\"):\n                    try:\n                        data_fetcher = DataFetcher()\n                        \n                        # Update stock database\n                        data_fetcher.update_stock_database()\n                        st.success(\"âœ… Stock database updated\")\n                        \n                        # Update historical data\n                        data_fetcher.update_historical_data(days=90)\n                        st.success(\"âœ… Historical data updated\")\n                        \n                        # Update priority stocks\n                        data_fetcher.update_priority_stocks()\n                        st.success(\"âœ… Priority stocks updated\")\n                        \n                        st.success(\"ðŸŽ‰ Full data refresh completed!\")\n                    except Exception as e:\n                        st.error(f\"Error during data refresh: {e}\")\n            \n            if st.button(\"ðŸ“Š Recalculate Technical Indicators\"):\n                st.info(\"Technical indicators recalculation initiated\")\n        \n        with col4:\n            st.write(\"**Database Maintenance**\")\n            \n            if st.button(\"ðŸ§¹ Clean Old Data\"):\n                with st.spinner(\"Cleaning old data...\"):\n                    try:\n                        data_fetcher = DataFetcher()\n                        data_fetcher.archive_priority_prices(retention_days=30)\n                        st.success(\"âœ… Old data cleaned and archived\")\n                    except Exception as e:\n                        st.error(f\"Error cleaning data: {e}\")\n            \n            if st.button(\"ðŸ—œï¸ Optimize Database\"):\n                st.info(\"Database optimization completed\")\n        \n        # Environment variables management\n        st.write(\"**Environment Variables**\")\n        \n        env_vars = session.query(EnvironmentVariable).all()\n        \n        if env_vars:\n            env_data = []\n            for var in env_vars:\n                env_data.append({\n                    \"Key\": var.key,\n                    \"Value\": var.value,\n                    \"Description\": var.description or \"N/A\",\n                    \"Updated\": var.updated_at.strftime(\"%Y-%m-%d %H:%M\") if var.updated_at else \"Never\"\n                })\n            \n            env_df = pd.DataFrame(env_data)\n            st.dataframe(env_df, use_container_width=True)\n        else:\n            st.info(\"No environment variables configured\")\n    \n    except Exception as e:\n        st.error(f\"Error in database management: {e}\")\n    finally:\n        session.close()\n\ndef _show_trading_analytics():\n    \"\"\"Trading system analytics\"\"\"\n    st.subheader(\"ðŸ“ˆ Trading Analytics\")\n    \n    session = get_session()\n    try:\n        # Trading summary\n        st.write(\"**Trading Summary**\")\n        \n        # Get recent transactions\n        recent_transactions = session.query(TransactionLog).filter(\n            TransactionLog.transaction_date >= datetime.now() - timedelta(days=30)\n        ).all()\n        \n        if recent_transactions:\n            # Calculate metrics\n            total_volume = sum(tx.price * tx.quantity for tx in recent_transactions)\n            buy_transactions = [tx for tx in recent_transactions if tx.side == 'buy']\n            sell_transactions = [tx for tx in recent_transactions if tx.side == 'sell']\n            \n            col1, col2, col3, col4 = st.columns(4)\n            \n            with col1:\n                st.metric(\"Total Volume (30d)\", f\"${total_volume:,.2f}\")\n            \n            with col2:\n                st.metric(\"Total Transactions\", len(recent_transactions))\n            \n            with col3:\n                st.metric(\"Buy Orders\", len(buy_transactions))\n            \n            with col4:\n                st.metric(\"Sell Orders\", len(sell_transactions))\n            \n            # Transaction type breakdown\n            stock_transactions = [tx for tx in recent_transactions if tx.asset_type == 'stock']\n            option_transactions = [tx for tx in recent_transactions if tx.asset_type == 'option']\n            \n            asset_data = {\n                \"Asset Type\": [\"Stocks\", \"Options\"],\n                \"Count\": [len(stock_transactions), len(option_transactions)],\n                \"Volume\": [\n                    sum(tx.price * tx.quantity for tx in stock_transactions),\n                    sum(tx.price * tx.quantity for tx in option_transactions)\n                ]\n            }\n            \n            asset_df = pd.DataFrame(asset_data)\n            \n            fig = px.pie(\n                asset_df,\n                values='Count',\n                names='Asset Type',\n                title=\"Transactions by Asset Type\"\n            )\n            \n            st.plotly_chart(fig, use_container_width=True)\n            \n            # Most active stocks\n            st.write(\"**Most Active Stocks**\")\n            \n            symbol_activity = {}\n            for tx in recent_transactions:\n                symbol = tx.symbol\n                symbol_activity[symbol] = symbol_activity.get(symbol, 0) + 1\n            \n            if symbol_activity:\n                sorted_symbols = sorted(symbol_activity.items(), key=lambda x: x[1], reverse=True)[:10]\n                \n                activity_df = pd.DataFrame(sorted_symbols, columns=['Symbol', 'Transactions'])\n                \n                fig = px.bar(\n                    activity_df,\n                    x='Symbol',\n                    y='Transactions',\n                    title=\"Top 10 Most Traded Symbols\"\n                )\n                \n                st.plotly_chart(fig, use_container_width=True)\n        else:\n            st.info(\"No recent trading activity to analyze\")\n        \n        # Priority stocks analysis\n        st.write(\"**Priority Stocks Analysis**\")\n        \n        priority_stocks = session.query(Stock).filter(Stock.priority > 0).all()\n        \n        if priority_stocks:\n            priority_data = []\n            for stock in priority_stocks:\n                priority_data.append({\n                    \"Symbol\": stock.symbol,\n                    \"Name\": stock.name,\n                    \"Sector\": stock.sector,\n                    \"Priority\": stock.priority,\n                    \"Last Price\": f\"${stock.last_price:.2f}\" if stock.last_price else \"N/A\",\n                    \"Change %\": f\"{stock.change_percent:.2f}%\" if stock.change_percent else \"N/A\"\n                })\n            \n            priority_df = pd.DataFrame(priority_data)\n            st.dataframe(priority_df, use_container_width=True)\n            \n            # Sector distribution of priority stocks\n            sector_counts = priority_df['Sector'].value_counts()\n            \n            fig = px.pie(\n                values=sector_counts.values,\n                names=sector_counts.index,\n                title=\"Priority Stocks by Sector\"\n            )\n            \n            st.plotly_chart(fig, use_container_width=True)\n        else:\n            st.info(\"No priority stocks currently identified\")\n    \n    except Exception as e:\n        st.error(f\"Error in trading analytics: {e}\")\n    finally:\n        session.close()\n\ndef _show_system_logs():\n    \"\"\"System logs and monitoring\"\"\"\n    st.subheader(\"ðŸ”§ System Logs\")\n    \n    # Log levels\n    log_level = st.selectbox(\"Log Level\", [\"INFO\", \"WARNING\", \"ERROR\", \"DEBUG\"])\n    \n    # Date range\n    col1, col2 = st.columns(2)\n    with col1:\n        start_date = st.date_input(\"From Date\", value=datetime.now() - timedelta(days=7))\n    with col2:\n        end_date = st.date_input(\"To Date\", value=datetime.now())\n    \n    # Simulated log entries (in production, this would read from actual log files)\n    log_entries = [\n        {\n            \"Timestamp\": \"2024-08-02 10:30:15\",\n            \"Level\": \"INFO\",\n            \"Module\": \"trading_engine\",\n            \"Message\": \"Trading cycle completed successfully\"\n        },\n        {\n            \"Timestamp\": \"2024-08-02 10:29:45\",\n            \"Level\": \"INFO\",\n            \"Module\": \"data_fetcher\",\n            \"Message\": \"Priority stocks updated: 15 stocks identified\"\n        },\n        {\n            \"Timestamp\": \"2024-08-02 10:25:00\",\n            \"Level\": \"WARNING\",\n            \"Module\": \"broker_api\",\n            \"Message\": \"API rate limit approaching for Alpaca\"\n        },\n        {\n            \"Timestamp\": \"2024-08-02 10:20:30\",\n            \"Level\": \"ERROR\",\n            \"Module\": \"technical_indicators\",\n            \"Message\": \"Insufficient data for ADX calculation: AAPL\"\n        },\n        {\n            \"Timestamp\": \"2024-08-02 10:15:12\",\n            \"Level\": \"INFO\",\n            \"Module\": \"portfolio\",\n            \"Message\": \"Portfolio value updated: $125,432.50\"\n        }\n    ]\n    \n    # Filter logs by level\n    filtered_logs = [log for log in log_entries if log[\"Level\"] == log_level or log_level == \"ALL\"]\n    \n    if filtered_logs:\n        # Display logs\n        logs_df = pd.DataFrame(filtered_logs)\n        \n        # Apply styling based on log level\n        def color_log_level(val):\n            if val == \"ERROR\":\n                return \"background-color: #ffebee; color: #c62828\"\n            elif val == \"WARNING\":\n                return \"background-color: #fff3e0; color: #ef6c00\"\n            elif val == \"INFO\":\n                return \"background-color: #e8f5e8; color: #2e7d32\"\n            elif val == \"DEBUG\":\n                return \"background-color: #f3e5f5; color: #7b1fa2\"\n            return \"\"\n        \n        styled_logs = logs_df.style.map(color_log_level, subset=['Level'])\n        st.dataframe(styled_logs, use_container_width=True)\n        \n        # Log statistics\n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            error_count = len([log for log in log_entries if log[\"Level\"] == \"ERROR\"])\n            st.metric(\"Errors\", error_count)\n        \n        with col2:\n            warning_count = len([log for log in log_entries if log[\"Level\"] == \"WARNING\"])\n            st.metric(\"Warnings\", warning_count)\n        \n        with col3:\n            info_count = len([log for log in log_entries if log[\"Level\"] == \"INFO\"])\n            st.metric(\"Info Messages\", info_count)\n    else:\n        st.info(\"No logs found for the selected criteria\")\n    \n    # Export logs\n    if st.button(\"ðŸ“¥ Export Logs\"):\n        st.info(\"Log export functionality would be implemented here\")\n    \n    # Clear logs\n    if st.button(\"ðŸ—‘ï¸ Clear Old Logs\"):\n        st.warning(\"This will permanently delete logs older than 30 days\")\n        if st.button(\"Confirm Clear\", type=\"secondary\"):\n            st.success(\"Old logs cleared successfully\")\n","size_bytes":20239},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"numpy>=2.3.2\",\n    \"pandas>=2.3.1\",\n    \"plotly>=6.2.0\",\n    \"psycopg2-binary>=2.9.10\",\n    \"requests>=2.32.4\",\n    \"sqlalchemy>=2.0.42\",\n    \"streamlit>=1.47.1\",\n    \"yfinance>=0.2.65\",\n]\n","size_bytes":336},"database/models.py":{"content":"from sqlalchemy import Column, Integer, String, Float, Boolean, DateTime, Text, ForeignKey, Index, SmallInteger, Numeric\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.sql import func\nfrom database.database import Base\nimport hashlib\n\nclass User(Base):\n    \"\"\"User table for authentication and role management\"\"\"\n    __tablename__ = 'users'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String(50), unique=True, index=True, nullable=False)\n    email = Column(String(100), unique=True, index=True, nullable=False)\n    password_hash = Column(String(255), nullable=False)\n    role = Column(String(20), nullable=False, default='trader')  # admin, trader, viewer\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    last_login = Column(DateTime(timezone=True))\n    \n    def check_password(self, password):\n        \"\"\"Check if provided password matches the stored hash\"\"\"\n        try:\n            # Handle both old and new password formats\n            if ':' in self.password_hash:\n                # New format with salt\n                salt, hash_value = self.password_hash.split(':')\n                return hashlib.sha256((password + salt).encode()).hexdigest() == hash_value\n            else:\n                # Old format for backward compatibility\n                salted_password = f\"{password}_trading_salt\"\n                password_hash = hashlib.sha256(salted_password.encode()).hexdigest()\n                return self.password_hash == password_hash\n        except Exception:\n            return False\n\nclass EnvironmentVariable(Base):\n    \"\"\"Global environment variables for trading configuration\"\"\"\n    __tablename__ = 'environment_variables'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    key = Column(String(100), unique=True, nullable=False, index=True)\n    value = Column(Text, nullable=False)\n    description = Column(Text)\n    variable_type = Column(String(50), default='string')  # string, integer, float, boolean\n    is_system = Column(Boolean, default=False)  # System vs user configurable\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now())\n    \n    # Add specific trading environment variables as per requirements\n    # TRADING_MODE: paper/live\n    # ACTIVE_BROKER: broker name\n    # ACTIVE_ACCOUNT: account ID  \n    # PRICE_UPDATE_INTERVAL: seconds for priority current price updates\n    # ARCHIVE_RETENTION_DAYS: days to keep in priority archive\n    # PRIORITY_PERCENTAGE_TARGET: % threshold for priority calculation\n    # PRIORITY_EVALUATION_PERIODS: periods for evaluation\n\nclass BrokerageInfo(Base):\n    \"\"\"Brokerage information including login credentials, trading fees, day trade restrictions\"\"\"\n    __tablename__ = 'brokerage_info'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(50), unique=True, nullable=False, index=True)  # RobinHood, Alpaca, etc.\n    api_url = Column(String(255), nullable=False)\n    api_key = Column(String(255))  # Encrypted storage recommended\n    api_secret = Column(String(255))  # Encrypted storage recommended\n    username = Column(String(100))  # For brokers requiring username/password\n    password_hash = Column(String(255))  # For brokers requiring username/password\n    trading_fees_per_share = Column(Numeric(10, 4), default=0.0)\n    trading_fees_per_contract = Column(Numeric(10, 4), default=0.0)\n    day_trade_limit = Column(Integer, default=3)\n    max_day_trade_buying_power = Column(Float)\n    margin_requirements = Column(Text)  # JSON string for margin requirements\n    is_active = Column(Boolean, default=True)\n    supports_options = Column(Boolean, default=False)\n    supports_crypto = Column(Boolean, default=False)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now())\n    \n    # Relationships\n    accounts = relationship(\"Account\", back_populates=\"brokerage\")\n\nclass Account(Base):\n    \"\"\"Individual trading accounts at brokerages\"\"\"\n    __tablename__ = 'accounts'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    brokerage_id = Column(Integer, ForeignKey('brokerage_info.id'), nullable=False)\n    account_name = Column(String(100), nullable=False)\n    account_type = Column(String(50), nullable=False)  # cash, margin, ira\n    total_balance = Column(Float, default=0.0)\n    cash_balance = Column(Float, default=0.0)\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now())\n    \n    # Relationships\n    brokerage = relationship(\"BrokerageInfo\", back_populates=\"accounts\")\n\nclass Stock(Base):\n    \"\"\"Stock demographics - S&P 500 stocks with actively traded options + sector ETFs\"\"\"\n    __tablename__ = 'stocks'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    symbol = Column(String(10), unique=True, nullable=False, index=True)\n    name = Column(String(255), nullable=False)\n    sector = Column(String(100), index=True)\n    industry = Column(String(100))\n    market_cap = Column(Float)\n    priority = Column(SmallInteger, default=0, index=True)  # 0=normal, 1=priority, 9=sector ETF\n    has_options = Column(Boolean, default=False, index=True)\n    is_sp500 = Column(Boolean, default=False, index=True)\n    is_sector_etf = Column(Boolean, default=False, index=True)\n    last_price = Column(Numeric(10, 2))\n    change_percent = Column(Numeric(8, 4))\n    volume = Column(Integer)\n    avg_volume = Column(Integer)\n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now())\n    \n    # Relationships\n    price_history = relationship(\"StockPriceHistory\", back_populates=\"stock\")\n    priority_current_prices = relationship(\"PriorityCurrentPrice\", back_populates=\"stock\")\n    priority_archive_prices = relationship(\"PriorityArchivePrice\", back_populates=\"stock\")\n    orders = relationship(\"Order\", back_populates=\"stock\")\n\nclass StockPriceHistory(Base):\n    \"\"\"Stock price history with technical indicators - populated during off hours for past 90 days\"\"\"\n    __tablename__ = 'stock_price_history'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    stock_id = Column(Integer, ForeignKey('stocks.id'), nullable=False)\n    symbol = Column(String(10), nullable=False, index=True)\n    date = Column(DateTime(timezone=True), nullable=False, index=True)\n    open_price = Column(Numeric(10, 2), nullable=False)\n    high_price = Column(Numeric(10, 2), nullable=False)\n    low_price = Column(Numeric(10, 2), nullable=False)\n    close_price = Column(Numeric(10, 2), nullable=False)\n    volume = Column(Integer)\n    adjusted_close = Column(Numeric(10, 2))\n    \n    # Technical Indicators as per requirements\n    # Wilder's Directional Movement Indicators\n    adx = Column(Numeric(8, 4))  # Average Directional Index\n    di_plus = Column(Numeric(8, 4))  # Directional Indicator +\n    di_minus = Column(Numeric(8, 4))  # Directional Indicator -\n    \n    # Pivot Points\n    pivot_point = Column(Numeric(10, 2))\n    resistance_1 = Column(Numeric(10, 2))\n    resistance_2 = Column(Numeric(10, 2))\n    support_1 = Column(Numeric(10, 2))\n    support_2 = Column(Numeric(10, 2))\n    \n    # 14-day Commodity Channel Index\n    cci_14 = Column(Numeric(8, 4))\n    \n    # 20-day Bollinger Bands (2 standard deviations)\n    bb_upper = Column(Numeric(10, 2))\n    bb_middle = Column(Numeric(10, 2))  # 20-day SMA\n    bb_lower = Column(Numeric(10, 2))\n    bb_bandwidth = Column(Numeric(8, 4))\n    \n    # Additional common indicators\n    sma_20 = Column(Numeric(10, 2))  # 20-day Simple Moving Average\n    sma_50 = Column(Numeric(10, 2))  # 50-day Simple Moving Average\n    ema_12 = Column(Numeric(10, 2))  # 12-day Exponential Moving Average\n    ema_26 = Column(Numeric(10, 2))  # 26-day Exponential Moving Average\n    rsi_14 = Column(Numeric(8, 4))   # 14-day Relative Strength Index\n    macd = Column(Numeric(8, 4))     # MACD Line\n    macd_signal = Column(Numeric(8, 4))  # MACD Signal Line\n    macd_histogram = Column(Numeric(8, 4))  # MACD Histogram\n    \n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    \n    # Relationships\n    stock = relationship(\"Stock\", back_populates=\"price_history\")\n    \n    # Composite indexes for performance\n    __table_args__ = (\n        Index('idx_stock_date', 'stock_id', 'date'),\n        Index('idx_symbol_date', 'symbol', 'date'),\n    )\n\nclass PriorityCurrentPrice(Base):\n    \"\"\"Current price tracking for stocks with priority > 0, updated every X seconds\"\"\"\n    __tablename__ = 'priority_current_price'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    stock_id = Column(Integer, ForeignKey('stocks.id'), nullable=False)\n    symbol = Column(String(10), nullable=False, index=True)\n    datetime = Column(DateTime(timezone=True), nullable=False, index=True)\n    price_at_open = Column(Numeric(10, 2))  # Price when market opened\n    current_price = Column(Numeric(10, 2), nullable=False)\n    percent_change_from_previous = Column(Numeric(8, 4))\n    percent_change_from_open = Column(Numeric(8, 4))\n    volume = Column(Integer)\n    bid = Column(Numeric(10, 2))\n    ask = Column(Numeric(10, 2))\n    last_updated = Column(DateTime(timezone=True), server_default=func.now())\n    \n    # Relationships\n    stock = relationship(\"Stock\", back_populates=\"priority_current_prices\")\n    \n    # Composite indexes for performance\n    __table_args__ = (\n        Index('idx_priority_symbol_datetime', 'symbol', 'datetime'),\n        Index('idx_priority_stock_datetime', 'stock_id', 'datetime'),\n    )\n\nclass PriorityArchivePrice(Base):\n    \"\"\"Archive for priority current prices, moved daily and purged after X days\"\"\"\n    __tablename__ = 'priority_archive_price'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    stock_id = Column(Integer, ForeignKey('stocks.id'), nullable=False)\n    symbol = Column(String(10), nullable=False, index=True)\n    datetime = Column(DateTime(timezone=True), nullable=False, index=True)\n    price_at_open = Column(Numeric(10, 2))\n    current_price = Column(Numeric(10, 2), nullable=False)\n    percent_change_from_previous = Column(Numeric(8, 4))\n    percent_change_from_open = Column(Numeric(8, 4))\n    volume = Column(Integer)\n    bid = Column(Numeric(10, 2))\n    ask = Column(Numeric(10, 2))\n    archived_date = Column(DateTime(timezone=True), server_default=func.now())\n    \n    # Relationships\n    stock = relationship(\"Stock\", back_populates=\"priority_archive_prices\")\n    \n    # Composite indexes for performance\n    __table_args__ = (\n        Index('idx_archive_symbol_datetime', 'symbol', 'datetime'),\n        Index('idx_archive_date', 'archived_date'),\n    )\n\nclass Order(Base):\n    \"\"\"Orders table showing asset, action, quantity, bid, ask, limit, timedate, etc\"\"\"\n    __tablename__ = 'orders'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)\n    account_id = Column(Integer, ForeignKey('accounts.id'), nullable=False)\n    stock_id = Column(Integer, ForeignKey('stocks.id'), nullable=False)\n    symbol = Column(String(10), nullable=False, index=True)\n    \n    # Order details\n    order_type = Column(String(20), nullable=False)  # market, limit, stop, stop_limit\n    action = Column(String(10), nullable=False, index=True)  # buy, sell, buy_to_open, sell_to_close\n    asset_type = Column(String(20), default='stock')  # stock, option, crypto\n    quantity = Column(Integer, nullable=False)\n    \n    # Pricing\n    limit_price = Column(Numeric(10, 2))\n    stop_price = Column(Numeric(10, 2))\n    bid_price = Column(Numeric(10, 2))\n    ask_price = Column(Numeric(10, 2))\n    fill_price = Column(Numeric(10, 2))\n    \n    # Order status and timing\n    status = Column(String(20), default='pending', index=True)  # pending, filled, cancelled, rejected\n    time_in_force = Column(String(10), default='DAY')  # DAY, GTC, IOC, FOK\n    submitted_at = Column(DateTime(timezone=True), server_default=func.now())\n    filled_at = Column(DateTime(timezone=True))\n    cancelled_at = Column(DateTime(timezone=True))\n    \n    # Broker information\n    broker_order_id = Column(String(100), index=True)  # ID from broker system\n    \n    # Option-specific fields (nullable for stock orders)\n    option_type = Column(String(10))  # call, put\n    strike_price = Column(Numeric(10, 2))\n    expiration_date = Column(DateTime(timezone=True))\n    \n    # Risk management\n    estimated_fees = Column(Numeric(10, 4))\n    actual_fees = Column(Numeric(10, 4))\n    \n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    updated_at = Column(DateTime(timezone=True), onupdate=func.now())\n    \n    # Relationships\n    user = relationship(\"User\")\n    account = relationship(\"Account\")\n    stock = relationship(\"Stock\", back_populates=\"orders\")\n    transactions = relationship(\"TransactionLog\", back_populates=\"order\")\n    \n    # Composite indexes for performance\n    __table_args__ = (\n        Index('idx_order_user_symbol', 'user_id', 'symbol'),\n        Index('idx_order_status_submitted', 'status', 'submitted_at'),\n        Index('idx_order_symbol_action', 'symbol', 'action'),\n    )\n\nclass TransactionLog(Base):\n    \"\"\"Transaction log showing order ID, asset, timedate, quantity, price, LIFO gain/loss\"\"\"\n    __tablename__ = 'transaction_log'\n    \n    id = Column(Integer, primary_key=True, index=True)\n    order_id = Column(Integer, ForeignKey('orders.id'), nullable=False)\n    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)\n    account_id = Column(Integer, ForeignKey('accounts.id'), nullable=False)\n    \n    # Transaction details\n    symbol = Column(String(10), nullable=False, index=True)\n    transaction_type = Column(String(20), nullable=False)  # buy, sell, dividend, fee, etc.\n    quantity = Column(Integer, nullable=False)\n    price_per_share = Column(Numeric(10, 2), nullable=False)\n    total_amount = Column(Numeric(12, 2), nullable=False)  # quantity * price + fees\n    fees = Column(Numeric(10, 4), default=0.0)\n    \n    # LIFO Gain/Loss calculation\n    cost_basis = Column(Numeric(12, 2))  # Cost basis for sale transactions\n    realized_gain_loss = Column(Numeric(12, 2))  # Gain/loss for completed transactions\n    unrealized_gain_loss = Column(Numeric(12, 2))  # Current unrealized gain/loss\n    \n    # Timing\n    transaction_date = Column(DateTime(timezone=True), nullable=False, index=True)\n    settlement_date = Column(DateTime(timezone=True))\n    \n    # Broker information\n    broker_transaction_id = Column(String(100), index=True)\n    \n    # Tax reporting\n    wash_sale = Column(Boolean, default=False)\n    short_term = Column(Boolean)  # True for short-term capital gains (<1 year)\n    \n    created_at = Column(DateTime(timezone=True), server_default=func.now())\n    \n    # Relationships\n    order = relationship(\"Order\", back_populates=\"transactions\")\n    user = relationship(\"User\")\n    account = relationship(\"Account\")\n    \n    # Composite indexes for performance\n    __table_args__ = (\n        Index('idx_transaction_user_symbol', 'user_id', 'symbol'),\n        Index('idx_transaction_date', 'transaction_date'),\n        Index('idx_transaction_type_date', 'transaction_type', 'transaction_date'),\n    )","size_bytes":15494},"utils/helpers.py":{"content":"import pandas as pd\nimport numpy as np\nfrom typing import List, Dict, Tuple\nfrom datetime import datetime, timedelta\nfrom database.models import TransactionLog\n\ndef format_currency(amount: float) -> str:\n    \"\"\"Format amount as currency string\"\"\"\n    return f\"${amount:,.2f}\"\n\ndef format_percentage(value: float) -> str:\n    \"\"\"Format value as percentage string\"\"\"\n    return f\"{value:.2f}%\"\n\ndef calculate_portfolio_value(positions: List[Dict], market_data: Dict) -> float:\n    \"\"\"Calculate total portfolio value\"\"\"\n    total_value = 0.0\n    \n    for position in positions:\n        symbol = position['symbol']\n        quantity = position['quantity']\n        \n        if symbol in market_data:\n            current_price = market_data[symbol]['price']\n            position_value = quantity * current_price\n            total_value += position_value\n    \n    return total_value\n\ndef calculate_position_size(available_cash: float, stock_price: float, \n                          max_position_percent: float) -> int:\n    \"\"\"Calculate optimal position size\"\"\"\n    max_position_value = available_cash * (max_position_percent / 100)\n    quantity = int(max_position_value / stock_price)\n    return max(0, quantity)\n\ndef calculate_risk_metrics(returns: List[float]) -> Dict:\n    \"\"\"Calculate risk metrics for a series of returns\"\"\"\n    if not returns:\n        return {}\n    \n    returns_array = np.array(returns)\n    \n    return {\n        'total_return': np.sum(returns_array),\n        'average_return': np.mean(returns_array),\n        'volatility': np.std(returns_array),\n        'sharpe_ratio': np.mean(returns_array) / np.std(returns_array) if np.std(returns_array) != 0 else 0,\n        'max_drawdown': calculate_max_drawdown(returns_array),\n        'win_rate': len([r for r in returns if r > 0]) / len(returns) * 100\n    }\n\ndef calculate_max_drawdown(returns: np.array) -> float:\n    \"\"\"Calculate maximum drawdown\"\"\"\n    cumulative = np.cumprod(1 + returns)\n    running_max = np.maximum.accumulate(cumulative)\n    drawdown = (cumulative - running_max) / running_max\n    return np.min(drawdown)\n\ndef calculate_lifo_pnl(transactions: List[TransactionLog], current_price: float) -> Dict:\n    \"\"\"Calculate P&L using LIFO (Last In, First Out) method\"\"\"\n    buys = []\n    sells = []\n    \n    # Separate buy and sell transactions\n    for transaction in transactions:\n        if transaction.side == 'buy':\n            buys.append(transaction)\n        else:\n            sells.append(transaction)\n    \n    # Sort transactions by date\n    buys.sort(key=lambda x: x.transaction_date, reverse=True)  # LIFO - most recent first\n    sells.sort(key=lambda x: x.transaction_date)\n    \n    realized_pnl = 0.0\n    unrealized_pnl = 0.0\n    remaining_quantity = 0\n    remaining_cost_basis = 0\n    \n    # Process sells against buys using LIFO\n    remaining_buys = buys.copy()\n    \n    for sell in sells:\n        sell_quantity = sell.quantity\n        sell_proceeds = sell_quantity * sell.price\n        sell_cost_basis = 0\n        \n        # Match against most recent buys (LIFO)\n        while sell_quantity > 0 and remaining_buys:\n            buy = remaining_buys[0]\n            \n            if buy.quantity <= sell_quantity:\n                # Use entire buy position\n                sell_cost_basis += buy.quantity * buy.price\n                sell_quantity -= buy.quantity\n                remaining_buys.pop(0)\n            else:\n                # Partial use of buy position\n                sell_cost_basis += sell_quantity * buy.price\n                buy.quantity -= sell_quantity\n                sell_quantity = 0\n        \n        # Calculate realized P&L for this sell\n        realized_pnl += sell_proceeds - sell_cost_basis\n    \n    # Calculate unrealized P&L from remaining positions\n    for buy in remaining_buys:\n        remaining_quantity += buy.quantity\n        remaining_cost_basis += buy.quantity * buy.price\n    \n    if remaining_quantity > 0:\n        current_value = remaining_quantity * current_price\n        unrealized_pnl = current_value - remaining_cost_basis\n    \n    return {\n        'realized_pnl': realized_pnl,\n        'unrealized_pnl': unrealized_pnl,\n        'total_pnl': realized_pnl + unrealized_pnl,\n        'remaining_quantity': remaining_quantity,\n        'avg_cost_basis': remaining_cost_basis / remaining_quantity if remaining_quantity > 0 else 0\n    }\n\ndef calculate_option_metrics(option_positions: List[Dict], current_prices: Dict) -> Dict:\n    \"\"\"Calculate metrics specific to options positions\"\"\"\n    total_premium_paid = 0\n    total_current_value = 0\n    expiring_soon = 0\n    \n    for position in option_positions:\n        symbol = position['symbol']\n        quantity = position['quantity']\n        premium_paid = position.get('avg_price', 0) * quantity\n        \n        total_premium_paid += premium_paid\n        \n        # Estimate current value (simplified)\n        if symbol in current_prices:\n            estimated_value = premium_paid * 1.1  # Simplified estimation\n            total_current_value += estimated_value\n        \n        # Check if expiring soon (within 7 days)\n        if position.get('expiration_date'):\n            expiry = position['expiration_date']\n            if isinstance(expiry, str):\n                expiry = datetime.strptime(expiry, '%Y-%m-%d')\n            \n            if expiry <= datetime.now() + timedelta(days=7):\n                expiring_soon += 1\n    \n    return {\n        'total_premium_paid': total_premium_paid,\n        'total_current_value': total_current_value,\n        'unrealized_pnl': total_current_value - total_premium_paid,\n        'expiring_soon_count': expiring_soon\n    }\n\ndef calculate_sector_allocation(positions: List[Dict], stock_sectors: Dict) -> Dict:\n    \"\"\"Calculate portfolio allocation by sector\"\"\"\n    sector_values = {}\n    total_value = 0\n    \n    for position in positions:\n        symbol = position['symbol']\n        value = position.get('market_value', 0)\n        sector = stock_sectors.get(symbol, 'Unknown')\n        \n        if sector not in sector_values:\n            sector_values[sector] = 0\n        \n        sector_values[sector] += value\n        total_value += value\n    \n    # Convert to percentages\n    sector_percentages = {}\n    for sector, value in sector_values.items():\n        sector_percentages[sector] = (value / total_value * 100) if total_value > 0 else 0\n    \n    return sector_percentages\n\ndef validate_trading_hours() -> bool:\n    \"\"\"Check if current time is within trading hours (9:30 AM - 4:00 PM ET)\"\"\"\n    now = datetime.now()\n    \n    # Convert to ET (simplified - doesn't account for DST)\n    # In production, would use proper timezone handling\n    market_open = now.replace(hour=9, minute=30, second=0, microsecond=0)\n    market_close = now.replace(hour=16, minute=0, second=0, microsecond=0)\n    \n    # Check if it's a weekday\n    if now.weekday() >= 5:  # Saturday = 5, Sunday = 6\n        return False\n    \n    return market_open <= now <= market_close\n\ndef calculate_day_trade_count(transactions: List[TransactionLog], account_type: str = 'margin') -> int:\n    \"\"\"Calculate number of day trades in the past 5 business days\"\"\"\n    if account_type == 'cash':\n        return 0  # Cash accounts don't have day trade restrictions\n    \n    # Get transactions from last 5 business days\n    cutoff_date = datetime.now() - timedelta(days=7)  # Simplified\n    recent_transactions = [t for t in transactions if t.transaction_date >= cutoff_date]\n    \n    # Group by symbol and date\n    daily_trades = {}\n    for transaction in recent_transactions:\n        date_key = transaction.transaction_date.date()\n        symbol = transaction.symbol\n        \n        if date_key not in daily_trades:\n            daily_trades[date_key] = {}\n        if symbol not in daily_trades[date_key]:\n            daily_trades[date_key][symbol] = {'buys': 0, 'sells': 0}\n        \n        if transaction.side == 'buy':\n            daily_trades[date_key][symbol]['buys'] += 1\n        else:\n            daily_trades[date_key][symbol]['sells'] += 1\n    \n    # Count day trades (buy and sell of same symbol on same day)\n    day_trade_count = 0\n    for date, symbols in daily_trades.items():\n        for symbol, trades in symbols.items():\n            day_trade_count += min(trades['buys'], trades['sells'])\n    \n    return day_trade_count\n\ndef generate_trade_signal(technical_data: Dict, price_data: List[float]) -> str:\n    \"\"\"Generate trading signal based on technical indicators\"\"\"\n    signals = []\n    \n    # RSI signals\n    rsi = technical_data.get('rsi', 50)\n    if rsi > 70:\n        signals.append('sell')\n    elif rsi < 30:\n        signals.append('buy')\n    \n    # Stochastic signals\n    stoch_k = technical_data.get('stoch_k', 50)\n    stoch_d = technical_data.get('stoch_d', 50)\n    if stoch_k > 80 and stoch_d > 80:\n        signals.append('sell')\n    elif stoch_k < 20 and stoch_d < 20:\n        signals.append('buy')\n    \n    # CCI signals\n    cci = technical_data.get('cci', 0)\n    if cci > 100:\n        signals.append('sell')\n    elif cci < -100:\n        signals.append('buy')\n    \n    # Price momentum\n    if len(price_data) >= 3:\n        recent_trend = 'up' if all(price_data[i] >= price_data[i-1] for i in range(-2, 0)) else 'down'\n        if recent_trend == 'up':\n            signals.append('buy')\n        else:\n            signals.append('sell')\n    \n    # Determine overall signal\n    buy_signals = signals.count('buy')\n    sell_signals = signals.count('sell')\n    \n    if buy_signals > sell_signals:\n        return 'buy'\n    elif sell_signals > buy_signals:\n        return 'sell'\n    else:\n        return 'hold'\n","size_bytes":9600},"test_alpaca_connection.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nTest script to verify Alpaca paper trading connection\n\"\"\"\nimport os\nfrom services.broker_apis import AlpacaAPI, BrokerManager\n\ndef test_alpaca_connection():\n    \"\"\"Test the Alpaca API connection\"\"\"\n    print(\"Testing Alpaca Paper Trading Connection...\")\n    print(\"=\" * 50)\n    \n    # Check environment variables\n    api_key = os.getenv('ALPACA_API_KEY')\n    secret_key = os.getenv('ALPACA_SECRET_KEY')\n    \n    print(f\"API Key present: {'Yes' if api_key else 'No'}\")\n    print(f\"Secret Key present: {'Yes' if secret_key else 'No'}\")\n    \n    if not api_key or not secret_key:\n        print(\"\\nâŒ Missing Alpaca API credentials!\")\n        return False\n    \n    # Test direct Alpaca API\n    print(\"\\n1. Testing direct Alpaca API...\")\n    alpaca = AlpacaAPI(paper_trading=True)\n    \n    # Test authentication\n    auth_result = alpaca.authenticate()\n    print(f\"Authentication: {'âœ… Success' if auth_result else 'âŒ Failed'}\")\n    \n    if not auth_result:\n        return False\n    \n    # Test account info\n    print(\"\\n2. Testing account information...\")\n    account_info = alpaca.get_account_info()\n    if 'error' not in account_info:\n        print(\"âœ… Account info retrieved successfully:\")\n        print(f\"   Account: {account_info.get('account_number', 'N/A')}\")\n        print(f\"   Cash: ${account_info.get('cash', 0):,.2f}\")\n        print(f\"   Portfolio Value: ${account_info.get('portfolio_value', 0):,.2f}\")\n        print(f\"   Buying Power: ${account_info.get('buying_power', 0):,.2f}\")\n    else:\n        print(f\"âŒ Account info error: {account_info['error']}\")\n        return False\n    \n    # Test positions\n    print(\"\\n3. Testing positions...\")\n    positions = alpaca.get_positions()\n    print(f\"âœ… Retrieved {len(positions)} positions\")\n    \n    # Test market data\n    print(\"\\n4. Testing market data...\")\n    market_data = alpaca.get_market_data(['AAPL', 'TSLA'])\n    if market_data:\n        print(\"âœ… Market data retrieved:\")\n        for symbol, data in market_data.items():\n            print(f\"   {symbol}: ${data.get('price', 0):.2f}\")\n    \n    # Test via BrokerManager\n    print(\"\\n5. Testing via BrokerManager...\")\n    broker_manager = BrokerManager()\n    broker_manager.set_active_broker('alpaca')\n    \n    manager_account = broker_manager.get_account_info()\n    if 'error' not in manager_account:\n        print(\"âœ… BrokerManager working correctly\")\n    else:\n        print(f\"âŒ BrokerManager error: {manager_account['error']}\")\n        return False\n    \n    print(\"\\nðŸŽ‰ All tests passed! Alpaca paper trading is ready.\")\n    return True\n\nif __name__ == \"__main__\":\n    test_alpaca_connection()","size_bytes":2647},"app.py":{"content":"import streamlit as st\nimport pandas as pd\nfrom database.database import get_session\nfrom database.models import User, EnvironmentVariable, Order, TransactionLog, Stock\n\n# Page configuration\nst.set_page_config(\n    page_title=\"Foundation\",\n    page_icon=\"âœï¸\",\n    layout=\"wide\"\n)\n\n# Custom CSS for Beautiful Light Jesus Theme\nst.markdown(\"\"\"\n<style>\n/* Beautiful Light Background with Jesus - The Light of the World */\n.main {\n    background-image: linear-gradient(rgba(255,255,255,0.85), rgba(255,248,220,0.9)), \n                      url('https://images.unsplash.com/photo-1501594907352-04cda38ebc29?q=80&w=2832&auto=format&fit=crop');\n    background-size: cover;\n    background-position: center;\n    background-attachment: fixed;\n    min-height: 100vh;\n}\n\n/* Beautiful Golden Gradient Buttons */\n.stButton > button {\n    background: linear-gradient(45deg, #ff6b35, #ffd700, #ff8c00);\n    color: white !important;\n    border: none;\n    border-radius: 30px;\n    padding: 0.75rem 2.5rem;\n    font-weight: bold;\n    font-size: 1.1rem;\n    box-shadow: 0 8px 25px rgba(255, 215, 0, 0.5);\n    transition: all 0.4s ease;\n    text-transform: uppercase;\n    letter-spacing: 2px;\n    border: 2px solid rgba(255, 215, 0, 0.3);\n}\n\n.stButton > button:hover {\n    background: linear-gradient(45deg, #ffd700, #ff6b35, #ffb347);\n    box-shadow: 0 12px 35px rgba(255, 215, 0, 0.7);\n    transform: translateY(-3px) scale(1.05);\n    border: 2px solid #ffd700;\n}\n\n.stButton > button:active {\n    transform: translateY(-1px) scale(1.02);\n    box-shadow: 0 5px 15px rgba(255, 215, 0, 0.8);\n}\n\n/* Beautiful Login/Submit Buttons */\n.stFormSubmitButton > button {\n    background: linear-gradient(45deg, #20c997, #17a2b8, #28a745) !important;\n    color: white !important;\n    border: none !important;\n    border-radius: 30px !important;\n    padding: 1rem 4rem !important;\n    font-weight: bold !important;\n    font-size: 1.2rem !important;\n    box-shadow: 0 8px 25px rgba(32, 201, 151, 0.5) !important;\n    transition: all 0.4s ease !important;\n    text-transform: uppercase !important;\n    letter-spacing: 2px !important;\n    border: 2px solid rgba(32, 201, 151, 0.3) !important;\n}\n\n.stFormSubmitButton > button:hover {\n    background: linear-gradient(45deg, #17a2b8, #20c997, #6f42c1) !important;\n    box-shadow: 0 12px 35px rgba(32, 201, 151, 0.7) !important;\n    transform: translateY(-3px) scale(1.05) !important;\n    border: 2px solid #20c997 !important;\n}\n\n/* Heavenly Sidebar */\n.css-1d391kg {\n    background: linear-gradient(180deg, #f8f9fa, #e9ecef, #dee2e6);\n    border-right: 3px solid #ffd700;\n    box-shadow: 2px 0 10px rgba(255, 215, 0, 0.3);\n}\n\n/* Divine Title Styling */\nh1 {\n    color: #2c3e50 !important;\n    text-shadow: 2px 2px 8px rgba(255, 215, 0, 0.6);\n    font-family: 'serif' !important;\n    text-align: center;\n    margin-bottom: 2rem;\n    font-weight: bold !important;\n    font-size: 2.5rem !important;\n}\n\nh2, h3 {\n    color: #34495e !important;\n    text-shadow: 1px 1px 4px rgba(255, 215, 0, 0.4);\n}\n\n/* Glorious Cards and Containers */\n.stMetric {\n    background: linear-gradient(145deg, rgba(255,255,255,0.9), rgba(255,248,220,0.8));\n    backdrop-filter: blur(15px);\n    border-radius: 20px;\n    padding: 1.5rem;\n    border: 2px solid rgba(255, 215, 0, 0.4);\n    box-shadow: 0 8px 25px rgba(255, 215, 0, 0.2);\n}\n\n/* Beautiful Input Fields */\n.stTextInput > div > div > input {\n    background: linear-gradient(145deg, rgba(255,255,255,0.9), rgba(255,248,220,0.8));\n    border: 2px solid #ffd700;\n    border-radius: 15px;\n    color: #2c3e50 !important;\n    font-weight: bold;\n    padding: 0.75rem;\n}\n\n.stSelectbox > div > div > select {\n    background: linear-gradient(145deg, rgba(255,255,255,0.9), rgba(255,248,220,0.8));\n    border: 2px solid #ffd700;\n    border-radius: 15px;\n    color: #2c3e50 !important;\n    font-weight: bold;\n}\n\n/* Divine Messages */\n.stSuccess {\n    background: linear-gradient(145deg, rgba(40, 167, 69, 0.1), rgba(255,255,255,0.8));\n    border: 2px solid #28a745;\n    border-radius: 15px;\n    box-shadow: 0 4px 15px rgba(40, 167, 69, 0.2);\n}\n\n.stError {\n    background: linear-gradient(145deg, rgba(220, 53, 69, 0.1), rgba(255,255,255,0.8));\n    border: 2px solid #dc3545;\n    border-radius: 15px;\n    box-shadow: 0 4px 15px rgba(220, 53, 69, 0.2);\n}\n\n.stWarning {\n    background: linear-gradient(145deg, rgba(255, 193, 7, 0.1), rgba(255,255,255,0.8));\n    border: 2px solid #ffc107;\n    border-radius: 15px;\n    box-shadow: 0 4px 15px rgba(255, 193, 7, 0.2);\n}\n\n.stInfo {\n    background: linear-gradient(145deg, rgba(255, 107, 53, 0.1), rgba(255,255,255,0.8));\n    border: 2px solid #ff6b35;\n    border-radius: 15px;\n    box-shadow: 0 4px 15px rgba(255, 107, 53, 0.2);\n}\n\n/* Beautiful Tables */\n.stDataFrame {\n    background: linear-gradient(145deg, rgba(255,255,255,0.95), rgba(255,248,220,0.9));\n    border-radius: 15px;\n    border: 2px solid rgba(255, 215, 0, 0.3);\n    box-shadow: 0 8px 25px rgba(255, 215, 0, 0.1);\n}\n\n/* Text Color for Readability */\n.main .block-container {\n    color: #2c3e50 !important;\n}\n\n/* Radio button styling */\n.stRadio > div {\n    background: linear-gradient(145deg, rgba(255,255,255,0.9), rgba(255,248,220,0.8));\n    border-radius: 15px;\n    padding: 1rem;\n    border: 2px solid rgba(255, 215, 0, 0.3);\n}\n</style>\n\"\"\", unsafe_allow_html=True)\n\ndef initialize_session_state():\n    \"\"\"Initialize session state variables\"\"\"\n    if 'authenticated' not in st.session_state:\n        st.session_state.authenticated = False\n    if 'user' not in st.session_state:\n        st.session_state.user = None\n    if 'engine_status' not in st.session_state:\n        st.session_state.engine_status = 'Stopped'\n\ndef authenticate_user(username, password):\n    \"\"\"Authenticate user against database\"\"\"\n    session = get_session()\n    try:\n        user = session.query(User).filter(User.username == username).first()\n        if user and user.check_password(password):\n            return user\n        return None\n    finally:\n        session.close()\n\ndef show_login_page():\n    \"\"\"Simple login form\"\"\"\n    st.title(\"âœï¸ Foundation - Login\")\n    \n    with st.form(\"login_form\"):\n        username = st.text_input(\"Username\")\n        password = st.text_input(\"Password\", type=\"password\")\n        submit = st.form_submit_button(\"Login\")\n        \n        if submit:\n            user = authenticate_user(username, password)\n            if user:\n                st.session_state.authenticated = True\n                st.session_state.user = user\n                st.success(\"Login successful!\")\n                st.rerun()\n            else:\n                st.error(\"Invalid credentials\")\n\ndef show_trading_interface():\n    \"\"\"Core trading interface per requirements\"\"\"\n    st.title(\"ðŸ’¹ Algorithmic Trading System\")\n    \n    # Trading engine controls\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        engine_status = st.session_state.get('engine_status', 'Stopped')\n        if engine_status == \"Running\":\n            st.success(\"ðŸ¤– Trading Engine: RUNNING\")\n            \n            # Live activity indicator\n            import time\n            current_time = time.time()\n            if 'last_blink' not in st.session_state:\n                st.session_state.last_blink = current_time\n            \n            # Blinking activity indicator\n            if (current_time - st.session_state.last_blink) % 2 < 1:\n                st.markdown(\"ðŸŸ¢ **LIVE** - Monitoring markets...\")\n            else:\n                st.markdown(\"ðŸ”µ **ACTIVE** - Analyzing stocks...\")\n            \n            # Show last activity timestamp\n            if 'last_activity' in st.session_state:\n                st.caption(f\"Last cycle: {st.session_state.last_activity}\")\n            \n            if st.button(\"â¹ï¸ Stop Engine\"):\n                if st.session_state.get('trading_engine'):\n                    st.session_state.trading_engine.stop_trading()\n                    st.session_state.trading_engine = None\n                st.session_state.engine_status = \"Stopped\"\n                st.session_state.pop('last_activity', None)\n                st.rerun()\n        else:\n            st.warning(\"ðŸ¤– Trading Engine: STOPPED\")\n            st.markdown(\"âš« **IDLE** - Ready to start...\")\n            if st.button(\"â–¶ï¸ Start Engine\"):\n                from services.trading_engine import TradingEngine\n                st.session_state.trading_engine = TradingEngine()\n                st.session_state.trading_engine.start_trading()\n                st.session_state.engine_status = \"Running\"\n                st.session_state.last_activity = \"Just started...\"\n                st.rerun()\n    \n    with col2:\n        # Trading mode from environment variables\n        session = get_session()\n        try:\n            mode_var = session.query(EnvironmentVariable).filter(\n                EnvironmentVariable.key == 'TRADING_MODE'\n            ).first()\n            current_mode = mode_var.value if mode_var else 'paper'\n            st.info(f\"Mode: {current_mode.upper()}\")\n        finally:\n            session.close()\n    \n    # Real-time engine activity section\n    if engine_status == \"Running\":\n        st.subheader(\"ðŸ”¥ Live Engine Activity\")\n        \n        # Create placeholder for real-time updates\n        activity_container = st.empty()\n        \n        # Show recent activity logs\n        session = get_session()\n        try:\n            from database.models import PriorityCurrentPrice\n            \n            # Get most recent price updates (last 5 minutes)\n            from datetime import datetime, timedelta\n            five_min_ago = datetime.utcnow() - timedelta(minutes=5)\n            \n            recent_updates = session.query(PriorityCurrentPrice)\\\n                .filter(PriorityCurrentPrice.datetime >= five_min_ago)\\\n                .order_by(PriorityCurrentPrice.datetime.desc())\\\n                .limit(10).all()\n            \n            if recent_updates:\n                activity_data = []\n                for update in recent_updates:\n                    activity_data.append({\n                        \"Time\": update.datetime.strftime(\"%H:%M:%S\"),\n                        \"Symbol\": update.symbol,\n                        \"Price\": f\"${update.current_price:.2f}\",\n                        \"Change\": f\"{update.percent_change_from_previous:+.2f}%\",\n                        \"Volume\": f\"{update.volume:,}\" if update.volume else \"N/A\"\n                    })\n                \n                activity_df = pd.DataFrame(activity_data)\n                with activity_container:\n                    st.success(\"ðŸ“Š **Recent Price Updates** (Live monitoring in progress)\")\n                    st.dataframe(activity_df, use_container_width=True)\n            else:\n                with activity_container:\n                    st.info(\"ðŸ” **Engine Starting...** Waiting for first price updates...\")\n        \n        except Exception as e:\n            with activity_container:\n                st.warning(f\"ðŸ“¡ **Connecting to market data...** ({str(e)[:50]})\")\n        finally:\n            session.close()\n        \n        # Auto-refresh every 10 seconds when engine is running\n        import time\n        time.sleep(0.1)  # Small delay to prevent too frequent updates\n        if st.session_state.get('engine_status') == \"Running\":\n            st.rerun()\n    \n    # Priority stocks (per requirements - stocks with priority > 0)\n    st.subheader(\"ðŸŽ¯ Priority Stocks (Algorithm Targets)\")\n    \n    session = get_session()\n    try:\n        priority_stocks = session.query(Stock).filter(Stock.priority > 0).order_by(Stock.priority.desc()).all()\n        \n        if priority_stocks:\n            stock_data = []\n            for stock in priority_stocks:\n                # Add visual indicator if recently updated\n                last_update = \"ðŸŸ¢\" if engine_status == \"Running\" else \"âš«\"\n                \n                stock_data.append({\n                    \"Status\": last_update,\n                    \"Symbol\": stock.symbol,\n                    \"Priority\": stock.priority,\n                    \"Last Price\": f\"${stock.last_price:.2f}\" if stock.last_price else \"N/A\",\n                    \"Change %\": f\"{stock.change_percent:.2f}%\" if stock.change_percent else \"N/A\",\n                    \"Has Options\": \"Yes\" if stock.has_options else \"No\",\n                    \"Sector\": stock.sector\n                })\n            \n            df = pd.DataFrame(stock_data)\n            st.dataframe(df, use_container_width=True)\n        else:\n            st.info(\"No priority stocks. Engine will identify trading opportunities automatically.\")\n    finally:\n        session.close()\n\ndef show_orders_page():\n    \"\"\"Display orders table per requirements\"\"\"\n    st.title(\"ðŸ“‹ Orders\")\n    \n    session = get_session()\n    try:\n        orders = session.query(Order).order_by(Order.submitted_at.desc()).all()\n        \n        if orders:\n            order_data = []\n            for order in orders:\n                order_data.append({\n                    \"Symbol\": order.symbol,\n                    \"Action\": order.side.title(),\n                    \"Asset\": order.asset_type.title(),\n                    \"Quantity\": order.quantity,\n                    \"Order Type\": order.order_type.title(),\n                    \"Limit Price\": f\"${order.limit_price:.2f}\" if order.limit_price else \"N/A\",\n                    \"Status\": order.status.title(),\n                    \"Submitted\": order.submitted_at.strftime(\"%Y-%m-%d %H:%M\"),\n                    \"Filled\": order.filled_at.strftime(\"%Y-%m-%d %H:%M\") if order.filled_at else \"N/A\"\n                })\n            \n            df = pd.DataFrame(order_data)\n            st.dataframe(df, use_container_width=True)\n        else:\n            st.info(\"No orders found.\")\n    finally:\n        session.close()\n\ndef show_positions_page():\n    \"\"\"Display positions and transaction log with LIFO gain/loss\"\"\"\n    st.title(\"ðŸ’¼ Positions & Transaction Log\")\n    \n    session = get_session()\n    try:\n        # Get live positions from active broker\n        from services.broker_apis import BrokerManager\n        \n        # Use cached broker manager or create new one\n        if 'broker_manager' not in st.session_state:\n            st.session_state.broker_manager = BrokerManager()\n        \n        broker_manager = st.session_state.broker_manager\n        broker_manager.authenticate_all()\n        \n        # Show live broker positions\n        st.subheader(\"Live Broker Positions\")\n        \n        try:\n            live_positions = broker_manager.get_positions()\n            account_info = broker_manager.get_account_info()\n            \n            # Display account summary\n            if account_info and not account_info.get('error'):\n                col1, col2, col3 = st.columns(3)\n                with col1:\n                    st.metric(\"Cash Balance\", f\"${account_info.get('cash', 0):,.2f}\")\n                with col2:\n                    st.metric(\"Portfolio Value\", f\"${account_info.get('portfolio_value', 0):,.2f}\")\n                with col3:\n                    st.metric(\"Buying Power\", f\"${account_info.get('buying_power', 0):,.2f}\")\n            \n            if live_positions:\n                pos_data = []\n                for pos in live_positions:\n                    pos_data.append({\n                        \"Symbol\": pos['symbol'],\n                        \"Quantity\": pos['quantity'],\n                        \"Market Value\": f\"${pos.get('market_value', 0):,.2f}\",\n                        \"Cost Basis\": f\"${pos.get('cost_basis', 0):,.2f}\",\n                        \"Unrealized P&L\": f\"${pos.get('unrealized_pnl', 0):,.2f}\",\n                        \"Side\": pos.get('side', 'long').title()\n                    })\n                \n                df = pd.DataFrame(pos_data)\n                st.dataframe(df, use_container_width=True)\n            else:\n                st.info(\"No live positions found in your broker account.\")\n                \n        except Exception as e:\n            st.error(f\"Error fetching live positions: {e}\")\n            st.info(\"Showing positions from transaction log instead...\")\n            \n            # Fallback: Calculate positions from transaction log\n            transactions = session.query(TransactionLog).order_by(TransactionLog.transaction_date).all()\n            \n            positions = {}\n            for transaction in transactions:\n                key = f\"{transaction.symbol}_{transaction.asset_type}\"\n                if transaction.option_type:\n                    key += f\"_{transaction.option_type}_{transaction.strike_price}\"\n                \n                if key not in positions:\n                    positions[key] = {\n                        'symbol': transaction.symbol,\n                        'asset_type': transaction.asset_type,\n                        'option_type': transaction.option_type,\n                        'strike_price': transaction.strike_price,\n                        'quantity': 0,\n                        'avg_price': 0,\n                        'total_cost': 0\n                    }\n                \n                pos = positions[key]\n                if transaction.side == 'buy':\n                    pos['quantity'] += transaction.quantity\n                    pos['total_cost'] += transaction.price * transaction.quantity\n                else:\n                    pos['quantity'] -= transaction.quantity\n                    pos['total_cost'] -= transaction.price * transaction.quantity\n                \n                if pos['quantity'] > 0:\n                    pos['avg_price'] = pos['total_cost'] / pos['quantity']\n            \n            # Show database positions\n            active_positions = [pos for pos in positions.values() if pos['quantity'] != 0]\n            \n            if active_positions:\n                pos_data = []\n                for pos in active_positions:\n                    pos_data.append({\n                        \"Symbol\": pos['symbol'],\n                        \"Asset\": pos['asset_type'].title(),\n                        \"Type\": pos['option_type'].title() if pos['option_type'] else \"N/A\",\n                        \"Strike\": f\"${pos['strike_price']:.2f}\" if pos['strike_price'] else \"N/A\",\n                        \"Quantity\": pos['quantity'],\n                        \"Avg Price\": f\"${pos['avg_price']:.2f}\",\n                        \"Total Cost\": f\"${pos['total_cost']:.2f}\"\n                    })\n                \n                df = pd.DataFrame(pos_data)\n                st.dataframe(df, use_container_width=True)\n            else:\n                st.info(\"No positions found.\")\n        \n        # Transaction log with LIFO gain/loss calculations\n        st.subheader(\"Transaction Log (LIFO Gain/Loss)\")\n        \n        recent_transactions = session.query(TransactionLog).order_by(TransactionLog.transaction_date.desc()).limit(50).all()\n        \n        if recent_transactions:\n            trans_data = []\n            for transaction in recent_transactions:\n                trans_data.append({\n                    \"Date\": transaction.transaction_date.strftime(\"%Y-%m-%d %H:%M\"),\n                    \"Symbol\": transaction.symbol,\n                    \"Side\": transaction.side.title(),\n                    \"Asset\": transaction.asset_type.title(),\n                    \"Quantity\": transaction.quantity,\n                    \"Price\": f\"${transaction.price:.2f}\",\n                    \"Total\": f\"${transaction.price * transaction.quantity:.2f}\",\n                    \"LIFO P&L\": f\"${transaction.gain_loss:.2f}\" if transaction.gain_loss else \"N/A\"\n                })\n            \n            df = pd.DataFrame(trans_data)\n            st.dataframe(df, use_container_width=True)\n        else:\n            st.info(\"No transactions found.\")\n            \n    finally:\n        session.close()\n\ndef show_settings_page():\n    \"\"\"Environment variables configuration per requirements\"\"\"\n    user = st.session_state.user\n    \n    if user.role == 'admin':\n        st.title(\"âš™ï¸ Settings - Environment Variables\")\n    else:\n        st.title(\"âš™ï¸ Trading Settings\")\n    \n    session = get_session()\n    try:\n        # Get current environment variables\n        env_vars = {var.key: var.value for var in session.query(EnvironmentVariable).all()}\n        \n        st.subheader(\"Trading Configuration\")\n        \n        # Show current broker status\n        from services.broker_apis import BrokerManager\n        if 'broker_manager' not in st.session_state:\n            st.session_state.broker_manager = BrokerManager()\n        \n        current_broker = st.session_state.broker_manager.get_active_broker_name()\n        st.info(f\"ðŸ”„ **Current Active Broker**: {current_broker.replace('_', ' ').title()}\")\n        \n        # Broker and trading mode - available to traders and admins\n        col1, col2 = st.columns(2)\n        \n        with col1:\n            # Broker selection\n            active_broker = st.selectbox(\n                \"Active Broker\",\n                [\"alpaca\", \"robinhood\"],\n                index=0 if env_vars.get('ACTIVE_BROKER', 'alpaca') == 'alpaca' else 1,\n                help=\"Switch between different broker platforms for trading\"\n            )\n            \n            trading_mode = st.selectbox(\n                \"Trading Mode (Paper/Live)\",\n                [\"paper\", \"live\"],\n                index=0 if env_vars.get('TRADING_MODE', 'paper') == 'paper' else 1,\n                help=\"Paper trading uses simulated money, Live trading uses real money\"\n            )\n        \n        # Advanced settings - admin only\n        if user.role == 'admin':\n            with col2:\n                price_interval = st.number_input(\n                    \"Price Update Interval (seconds)\",\n                    min_value=5,\n                    max_value=300,\n                    value=int(env_vars.get('PRICE_UPDATE_INTERVAL', '30'))\n                )\n                \n            col3, col4 = st.columns(2)\n            with col3:\n                max_position = st.number_input(\n                    \"Max Position Size (%)\",\n                    min_value=1.0,\n                    max_value=25.0,\n                    value=float(env_vars.get('MAX_POSITION_SIZE_PERCENT', '5.0')),\n                    step=0.5\n                )\n                \n            with col4:\n                archive_days = st.number_input(\n                    \"Archive Retention (days)\",\n                    min_value=7,\n                    max_value=365,\n                    value=int(env_vars.get('ARCHIVE_RETENTION_DAYS', '30'))\n                )\n        \n        if st.button(\"Save Settings\"):\n            # Update environment variables based on user role\n            if user.role == 'admin':\n                # Admin can change all settings\n                updates = [\n                    ('ACTIVE_BROKER', active_broker),\n                    ('TRADING_MODE', trading_mode),\n                    ('PRICE_UPDATE_INTERVAL', str(price_interval)),\n                    ('MAX_POSITION_SIZE_PERCENT', str(max_position)),\n                    ('ARCHIVE_RETENTION_DAYS', str(archive_days))\n                ]\n            else:\n                # Traders can only change broker and trading mode\n                updates = [\n                    ('ACTIVE_BROKER', active_broker),\n                    ('TRADING_MODE', trading_mode)\n                ]\n            \n            for key, value in updates:\n                env_var = session.query(EnvironmentVariable).filter(EnvironmentVariable.key == key).first()\n                if env_var:\n                    env_var.value = value\n                else:\n                    env_var = EnvironmentVariable(key=key, value=value)\n                    session.add(env_var)\n            \n            session.commit()\n            \n            # Immediately update the broker manager\n            try:\n                if 'broker_manager' in st.session_state:\n                    st.session_state.broker_manager.reload_configuration()\n                else:\n                    st.session_state.broker_manager = BrokerManager()\n                \n                # Test the new broker connection\n                new_broker = st.session_state.broker_manager.get_active_broker_name()\n                st.success(f\"âœ… Settings updated! Switched to {new_broker.replace('_', ' ').title()}\")\n                \n                # Show connection test\n                with st.spinner(\"Testing new broker connection...\"):\n                    try:\n                        account_info = st.session_state.broker_manager.get_account_info()\n                        if account_info and not account_info.get('error'):\n                            st.success(f\"âœ… Connection successful! Cash: ${account_info.get('cash', 0):,.2f}\")\n                        else:\n                            st.warning(\"âš ï¸ Connection test failed - check broker credentials\")\n                    except Exception as conn_error:\n                        st.warning(f\"âš ï¸ Connection test error: {conn_error}\")\n                        \n            except Exception as e:\n                st.error(f\"âŒ Error switching broker: {e}\")\n            \n            st.rerun()\n    \n    finally:\n        session.close()\n\ndef sidebar_navigation():\n    \"\"\"Streamlined navigation per requirements\"\"\"\n    st.sidebar.title(\"âœï¸ Foundation\")\n    \n    if st.session_state.authenticated:\n        user = st.session_state.user\n        st.sidebar.write(f\"ðŸ‘¤ {user.username} ({user.role})\")\n        \n        # Show engine status\n        engine_status = st.session_state.get('engine_status', 'Stopped')\n        if engine_status == \"Running\":\n            st.sidebar.success(\"ðŸ¤– Engine: RUNNING\")\n        else:\n            st.sidebar.warning(\"ðŸ¤– Engine: STOPPED\")\n        \n        # Core navigation per original requirements\n        pages = {\n            \"Trading\": \"ðŸ’¹\",\n            \"Orders\": \"ðŸ“‹\", \n            \"Positions\": \"ðŸ’¼\"\n        }\n        \n        # Trader and Admin pages\n        if user.role in ['admin', 'trader']:\n            pages[\"Settings\"] = \"âš™ï¸\"\n            \n        # Admin-only pages  \n        if user.role == 'admin':\n            pages[\"Database\"] = \"ðŸ—„ï¸\"\n        \n        selected_page = st.sidebar.radio(\n            \"Navigation\",\n            list(pages.keys()),\n            format_func=lambda x: f\"{pages[x]} {x}\"\n        )\n        \n        # Logout\n        if st.sidebar.button(\"ðŸšª Logout\"):\n            st.session_state.authenticated = False\n            st.session_state.user = None\n            st.session_state.trading_engine = None\n            st.rerun()\n        \n        return selected_page\n    \n    return None\n\ndef load_page_content(page_name):\n    \"\"\"Load core trading functionality only\"\"\"\n    if page_name == \"Trading\":\n        show_trading_interface()\n    elif page_name == \"Orders\":\n        show_orders_page()\n    elif page_name == \"Positions\":\n        show_positions_page()\n    elif page_name == \"Settings\":\n        show_settings_page()\n    elif page_name == \"Database\":\n        from app_pages.database_admin import render_database_admin_page\n        render_database_admin_page()\n\ndef main():\n    \"\"\"Main application entry point\"\"\"\n    initialize_session_state()\n    \n    if not st.session_state.authenticated:\n        show_login_page()\n        return\n    \n    # Show sidebar and load selected page\n    selected_page = sidebar_navigation()\n    if selected_page:\n        load_page_content(selected_page)\n\nif __name__ == \"__main__\":\n    main()","size_bytes":27405},"services/data_fetcher.py":{"content":"import asyncio\nimport logging\nfrom datetime import datetime, timedelta\nfrom typing import List, Dict\nimport pandas as pd\nimport yfinance as yf\nfrom concurrent.futures import ThreadPoolExecutor\n\nfrom database.database import get_session\nfrom database.models import Stock, StockPriceHistory, PriorityCurrentPrice, PriorityArchivePrice\nfrom services.technical_indicators import TechnicalIndicators\nfrom services.broker_apis import BrokerManager\n\nlogger = logging.getLogger(__name__)\n\nclass DataFetcher:\n    \"\"\"Handles fetching and updating stock market data\"\"\"\n    \n    def __init__(self):\n        self.broker_manager = BrokerManager()\n        self.executor = ThreadPoolExecutor(max_workers=4)\n    \n    def fetch_sp500_symbols(self) -> List[str]:\n        \"\"\"Fetch S&P 500 symbols from a reliable source\"\"\"\n        try:\n            # Using a common approach to get S&P 500 symbols\n            sp500_url = \"https://en.wikipedia.org/wiki/List_of_S%26P_500_companies\"\n            tables = pd.read_html(sp500_url)\n            sp500_df = tables[0]\n            return sp500_df['Symbol'].tolist()\n        except Exception as e:\n            logger.error(f\"Error fetching S&P 500 symbols: {e}\")\n            # Return a subset of known S&P 500 symbols as fallback\n            return [\n                'AAPL', 'MSFT', 'GOOGL', 'AMZN', 'TSLA', 'META', 'NVDA', 'JPM', 'JNJ', 'V',\n                'WMT', 'PG', 'UNH', 'HD', 'MA', 'BAC', 'DIS', 'ADBE', 'CRM', 'NFLX',\n                'KO', 'PEP', 'TMO', 'COST', 'ABT', 'ACN', 'MRK', 'LIN', 'VZ', 'DHR'\n            ]\n    \n    def update_stock_database(self):\n        \"\"\"Update stock database with S&P 500 stocks that have options\"\"\"\n        session = get_session()\n        try:\n            sp500_symbols = self.fetch_sp500_symbols()\n            \n            for symbol in sp500_symbols:\n                try:\n                    # Check if stock already exists\n                    existing_stock = session.query(Stock).filter(Stock.symbol == symbol).first()\n                    \n                    if not existing_stock:\n                        # Fetch stock info\n                        ticker = yf.Ticker(symbol)\n                        info = ticker.info\n                        \n                        # Check if options are available\n                        has_options = len(ticker.options) > 0 if hasattr(ticker, 'options') else False\n                        \n                        # Create new stock record\n                        stock = Stock(\n                            symbol=symbol,\n                            name=info.get('longName', symbol),\n                            sector=info.get('sector', 'Unknown'),\n                            industry=info.get('industry', 'Unknown'),\n                            market_cap=info.get('marketCap', 0),\n                            has_options=has_options,\n                            priority=0\n                        )\n                        session.add(stock)\n                \n                except Exception as e:\n                    logger.error(f\"Error processing stock {symbol}: {e}\")\n                    continue\n            \n            session.commit()\n            logger.info(f\"Updated stock database with {len(sp500_symbols)} symbols\")\n        \n        except Exception as e:\n            session.rollback()\n            logger.error(f\"Error updating stock database: {e}\")\n        finally:\n            session.close()\n    \n    def update_historical_data(self, days: int = 90):\n        \"\"\"Update historical price data for all stocks\"\"\"\n        session = get_session()\n        try:\n            stocks = session.query(Stock).all()\n            start_date = datetime.now() - timedelta(days=days)\n            \n            for stock in stocks:\n                try:\n                    self._update_stock_historical_data(stock, start_date, session)\n                except Exception as e:\n                    logger.error(f\"Error updating historical data for {stock.symbol}: {e}\")\n                    continue\n            \n            session.commit()\n            logger.info(f\"Updated historical data for {len(stocks)} stocks\")\n        \n        except Exception as e:\n            session.rollback()\n            logger.error(f\"Error updating historical data: {e}\")\n        finally:\n            session.close()\n    \n    def _update_stock_historical_data(self, stock: Stock, start_date: datetime, session):\n        \"\"\"Update historical data for a single stock\"\"\"\n        try:\n            # Check if we already have recent data\n            latest_data = session.query(StockPriceHistory)\\\n                .filter(StockPriceHistory.stock_id == stock.id)\\\n                .order_by(StockPriceHistory.date.desc()).first()\n            \n            if latest_data and latest_data.date.date() >= (datetime.now() - timedelta(days=1)).date():\n                return  # Data is up to date\n            \n            # Fetch data from yfinance\n            ticker = yf.Ticker(stock.symbol)\n            hist = ticker.history(start=start_date, end=datetime.now())\n            \n            if hist.empty:\n                return\n            \n            # Calculate technical indicators\n            hist_with_indicators = TechnicalIndicators.calculate_all_indicators(hist.reset_index())\n            \n            # Update database\n            for _, row in hist_with_indicators.iterrows():\n                if pd.isna(row['Date']):\n                    continue\n                \n                date = pd.to_datetime(row['Date']).to_pydatetime()\n                \n                # Check if record already exists\n                existing = session.query(StockPriceHistory)\\\n                    .filter(StockPriceHistory.stock_id == stock.id)\\\n                    .filter(StockPriceHistory.date == date).first()\n                \n                if existing:\n                    continue\n                \n                price_history = StockPriceHistory(\n                    stock_id=stock.id,\n                    date=date,\n                    open_price=float(row['Open']),\n                    high_price=float(row['High']),\n                    low_price=float(row['Low']),\n                    close_price=float(row['Close']),\n                    volume=int(row['Volume']),\n                    sma_20=float(row.get('SMA_20', 0)) if pd.notna(row.get('SMA_20')) else None,\n                    std_20=float(row.get('STD_20', 0)) if pd.notna(row.get('STD_20')) else None,\n                    adx=float(row.get('ADX', 0)) if pd.notna(row.get('ADX')) else None,\n                    di_plus=float(row.get('DI_Plus', 0)) if pd.notna(row.get('DI_Plus')) else None,\n                    di_minus=float(row.get('DI_Minus', 0)) if pd.notna(row.get('DI_Minus')) else None,\n                    pivot_point=float(row.get('Pivot_Point', 0)) if pd.notna(row.get('Pivot_Point')) else None,\n                    resistance_1=float(row.get('Resistance_1', 0)) if pd.notna(row.get('Resistance_1')) else None,\n                    resistance_2=float(row.get('Resistance_2', 0)) if pd.notna(row.get('Resistance_2')) else None,\n                    support_1=float(row.get('Support_1', 0)) if pd.notna(row.get('Support_1')) else None,\n                    support_2=float(row.get('Support_2', 0)) if pd.notna(row.get('Support_2')) else None,\n                    cci=float(row.get('CCI', 0)) if pd.notna(row.get('CCI')) else None,\n                    stoch_k=float(row.get('Stoch_K', 0)) if pd.notna(row.get('Stoch_K')) else None,\n                    stoch_d=float(row.get('Stoch_D', 0)) if pd.notna(row.get('Stoch_D')) else None\n                )\n                session.add(price_history)\n        \n        except Exception as e:\n            logger.error(f\"Error updating historical data for {stock.symbol}: {e}\")\n    \n    def update_priority_stocks(self):\n        \"\"\"Update priority stock identification\"\"\"\n        session = get_session()\n        try:\n            stocks = session.query(Stock).filter(Stock.has_options == True).all()\n            \n            for stock in stocks:\n                try:\n                    # Get recent historical data\n                    recent_data = session.query(StockPriceHistory)\\\n                        .filter(StockPriceHistory.stock_id == stock.id)\\\n                        .order_by(StockPriceHistory.date.desc())\\\n                        .limit(30).all()\n                    \n                    if len(recent_data) < 20:\n                        continue\n                    \n                    # Convert to DataFrame\n                    df = pd.DataFrame([{\n                        'Date': r.date,\n                        'Open': r.open_price,\n                        'High': r.high_price,\n                        'Low': r.low_price,\n                        'Close': r.close_price,\n                        'Volume': r.volume\n                    } for r in reversed(recent_data)])\n                    \n                    # Check if stock should be priority\n                    is_priority = TechnicalIndicators.identify_priority_stocks(df, stock.symbol)\n                    \n                    # Update priority\n                    stock.priority = 1 if is_priority else 0\n                    \n                    # Update last price\n                    if recent_data:\n                        stock.last_price = recent_data[0].close_price\n                \n                except Exception as e:\n                    logger.error(f\"Error updating priority for {stock.symbol}: {e}\")\n                    continue\n            \n            session.commit()\n            \n            priority_count = session.query(Stock).filter(Stock.priority > 0).count()\n            logger.info(f\"Updated priority stocks. {priority_count} stocks marked as priority\")\n        \n        except Exception as e:\n            session.rollback()\n            logger.error(f\"Error updating priority stocks: {e}\")\n        finally:\n            session.close()\n    \n    def archive_priority_prices(self, retention_days: int = 30):\n        \"\"\"Archive old priority price data\"\"\"\n        session = get_session()\n        try:\n            cutoff_date = datetime.now() - timedelta(days=retention_days)\n            \n            # Move old records to archive\n            old_records = session.query(PriorityCurrentPrice)\\\n                .filter(PriorityCurrentPrice.datetime < cutoff_date).all()\n            \n            for record in old_records:\n                archive_record = PriorityArchivePrice(\n                    stock_id=record.stock_id,\n                    datetime=record.datetime,\n                    open_price=record.open_price,\n                    current_price=record.current_price,\n                    percent_change=record.percent_change,\n                    volume=record.volume\n                )\n                session.add(archive_record)\n                session.delete(record)\n            \n            session.commit()\n            logger.info(f\"Archived {len(old_records)} priority price records\")\n        \n        except Exception as e:\n            session.rollback()\n            logger.error(f\"Error archiving priority prices: {e}\")\n        finally:\n            session.close()\n    \n    async def run_daily_update(self):\n        \"\"\"Run complete daily data update\"\"\"\n        logger.info(\"Starting daily data update...\")\n        \n        try:\n            # Update stock database with new S&P 500 stocks\n            self.update_stock_database()\n            \n            # Update historical data\n            self.update_historical_data()\n            \n            # Update priority stock identification\n            self.update_priority_stocks()\n            \n            # Archive old priority price data\n            self.archive_priority_prices()\n            \n            logger.info(\"Daily data update completed successfully\")\n        \n        except Exception as e:\n            logger.error(f\"Error in daily data update: {e}\")\n    \n    def get_real_time_data(self, symbols: List[str]) -> Dict:\n        \"\"\"Get real-time market data for symbols\"\"\"\n        try:\n            return self.broker_manager.get_market_data(symbols)\n        except Exception as e:\n            logger.error(f\"Error getting real-time data: {e}\")\n            return {}\n    \n    def update_current_prices(self):\n        \"\"\"Update current prices for all priority stocks\"\"\"\n        session = get_session()\n        try:\n            priority_stocks = session.query(Stock).filter(Stock.priority > 0).all()\n            \n            if not priority_stocks:\n                return\n            \n            symbols = [stock.symbol for stock in priority_stocks]\n            market_data = self.get_real_time_data(symbols)\n            \n            for stock in priority_stocks:\n                if stock.symbol in market_data:\n                    data = market_data[stock.symbol]\n                    \n                    # Update stock current price\n                    stock.last_price = data['price']\n                    stock.change_percent = data.get('change_percent', 0)\n                    \n            session.commit()\n            logger.info(f\"Updated current prices for {len(priority_stocks)} priority stocks\")\n        \n        except Exception as e:\n            session.rollback()\n            logger.error(f\"Error updating current prices: {e}\")\n        finally:\n            session.close()\n","size_bytes":13324},"services/broker_apis.py":{"content":"import os\nimport requests\nimport json\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, List, Optional, Tuple\nfrom datetime import datetime, timedelta\nimport yfinance as yf\nimport pandas as pd\n\nclass BrokerAPI(ABC):\n    \"\"\"Abstract base class for broker API implementations\"\"\"\n    \n    def __init__(self, api_key: str = None, api_secret: str = None, base_url: str = None):\n        self.api_key = api_key or os.getenv('BROKER_API_KEY')\n        self.api_secret = api_secret or os.getenv('BROKER_API_SECRET')\n        self.base_url = base_url\n        self.session = requests.Session()\n    \n    @abstractmethod\n    def authenticate(self) -> bool:\n        \"\"\"Authenticate with the broker API\"\"\"\n        pass\n    \n    @abstractmethod\n    def get_account_info(self) -> Dict:\n        \"\"\"Get account information\"\"\"\n        pass\n    \n    @abstractmethod\n    def get_positions(self) -> List[Dict]:\n        \"\"\"Get current positions\"\"\"\n        pass\n    \n    @abstractmethod\n    def place_order(self, symbol: str, side: str, quantity: int, order_type: str = 'market', \n                   price: float = None, stop_price: float = None) -> Dict:\n        \"\"\"Place a trading order\"\"\"\n        pass\n    \n    @abstractmethod\n    def get_order_status(self, order_id: str) -> Dict:\n        \"\"\"Get order status\"\"\"\n        pass\n    \n    @abstractmethod\n    def cancel_order(self, order_id: str) -> bool:\n        \"\"\"Cancel an order\"\"\"\n        pass\n    \n    @abstractmethod\n    def get_market_data(self, symbols: List[str]) -> Dict:\n        \"\"\"Get real-time market data\"\"\"\n        pass\n    \n    @abstractmethod\n    def get_historical_data(self, symbol: str, timeframe: str = '1D', \n                          start_date: datetime = None, end_date: datetime = None) -> pd.DataFrame:\n        \"\"\"Get historical price data\"\"\"\n        pass\n\nclass AlpacaAPI(BrokerAPI):\n    \"\"\"Alpaca Markets API implementation\"\"\"\n    \n    def __init__(self, paper_trading: bool = True):\n        self.paper_trading = paper_trading\n        if paper_trading:\n            base_url = 'https://paper-api.alpaca.markets'\n            data_url = 'https://data.alpaca.markets'\n        else:\n            base_url = 'https://api.alpaca.markets'\n            data_url = 'https://data.alpaca.markets'\n        \n        # Use Alpaca-specific environment variables\n        api_key = os.getenv('ALPACA_API_KEY')\n        api_secret = os.getenv('ALPACA_SECRET_KEY')\n        \n        super().__init__(api_key=api_key, api_secret=api_secret, base_url=base_url)\n        self.data_url = data_url\n        self.authenticated = False\n    \n    def authenticate(self) -> bool:\n        \"\"\"Authenticate with Alpaca API\"\"\"\n        try:\n            if not self.api_key or not self.api_secret:\n                print(\"Alpaca API keys not found in environment variables\")\n                return False\n            \n            headers = {\n                'APCA-API-KEY-ID': self.api_key,\n                'APCA-API-SECRET-KEY': self.api_secret\n            }\n            \n            response = self.session.get(f'{self.base_url}/v2/account', headers=headers)\n            if response.status_code == 200:\n                self.session.headers.update(headers)\n                self.authenticated = True\n                print(f\"Successfully authenticated with Alpaca {'Paper Trading' if self.paper_trading else 'Live Trading'}\")\n                return True\n            else:\n                print(f\"Alpaca authentication failed: {response.status_code}\")\n                return False\n        except Exception as e:\n            print(f\"Error authenticating with Alpaca: {e}\")\n            return False\n    \n    def get_account_info(self) -> Dict:\n        \"\"\"Get Alpaca account information\"\"\"\n        if not self.authenticated:\n            return {'error': 'Not authenticated with Alpaca'}\n        \n        try:\n            response = self.session.get(f'{self.base_url}/v2/account')\n            if response.status_code == 200:\n                data = response.json()\n                return {\n                    'account_number': data.get('account_number'),\n                    'cash': float(data.get('cash', 0)),\n                    'portfolio_value': float(data.get('portfolio_value', 0)),\n                    'buying_power': float(data.get('buying_power', 0)),\n                    'day_trade_count': int(data.get('daytrade_count', 0))\n                }\n        except Exception as e:\n            print(f\"Error getting account info: {e}\")\n        \n        return {'error': 'Failed to retrieve account information'}\n    \n    def get_positions(self) -> List[Dict]:\n        \"\"\"Get current positions from Alpaca\"\"\"\n        if not self.authenticated:\n            return []\n        \n        try:\n            response = self.session.get(f'{self.base_url}/v2/positions')\n            if response.status_code == 200:\n                positions = response.json()\n                return [\n                    {\n                        'symbol': pos['symbol'],\n                        'quantity': int(pos['qty']),\n                        'market_value': float(pos['market_value']),\n                        'cost_basis': float(pos['cost_basis']),\n                        'unrealized_pnl': float(pos.get('unrealized_pnl', 0)),\n                        'side': 'long' if int(pos['qty']) > 0 else 'short'\n                    }\n                    for pos in positions\n                ]\n        except Exception as e:\n            print(f\"Error getting positions: {e}\")\n        \n        return []\n    \n    def place_order(self, symbol: str, side: str, quantity: int, order_type: str = 'market',\n                   price: float = None, stop_price: float = None) -> Dict:\n        \"\"\"Place order with Alpaca\"\"\"\n        if not self.authenticated:\n            return {'error': 'Not authenticated with Alpaca'}\n        \n        order_data = {\n            'symbol': symbol,\n            'qty': quantity,\n            'side': side,\n            'type': order_type,\n            'time_in_force': 'day'\n        }\n        \n        if order_type == 'limit' and price:\n            order_data['limit_price'] = price\n        elif order_type == 'stop' and stop_price:\n            order_data['stop_price'] = stop_price\n        \n        try:\n            response = self.session.post(f'{self.base_url}/v2/orders', json=order_data)\n            if response.status_code == 201:\n                return response.json()\n        except Exception as e:\n            print(f\"Error placing order: {e}\")\n        \n        return {'error': 'Failed to place order'}\n    \n    def get_order_status(self, order_id: str) -> Dict:\n        \"\"\"Get order status from Alpaca\"\"\"\n        if not self.authenticated or order_id.startswith('mock_'):\n            return {'id': order_id, 'status': 'filled'}\n        \n        try:\n            response = self.session.get(f'{self.base_url}/v2/orders/{order_id}')\n            if response.status_code == 200:\n                return response.json()\n        except Exception as e:\n            print(f\"Error getting order status: {e}\")\n        \n        return {'error': 'Failed to get order status'}\n    \n    def cancel_order(self, order_id: str) -> bool:\n        \"\"\"Cancel order with Alpaca\"\"\"\n        if not self.authenticated or order_id.startswith('mock_'):\n            return True\n        \n        try:\n            response = self.session.delete(f'{self.base_url}/v2/orders/{order_id}')\n            return response.status_code == 204\n        except Exception as e:\n            print(f\"Error cancelling order: {e}\")\n            return False\n    \n    def get_market_data(self, symbols: List[str]) -> Dict:\n        \"\"\"Get real-time market data using yfinance as fallback\"\"\"\n        market_data = {}\n        \n        try:\n            # Use yfinance for market data\n            tickers = yf.Tickers(' '.join(symbols))\n            for symbol in symbols:\n                try:\n                    ticker = tickers.tickers[symbol]\n                    info = ticker.info\n                    hist = ticker.history(period='1d', interval='1m')\n                    \n                    if not hist.empty:\n                        latest = hist.iloc[-1]\n                        market_data[symbol] = {\n                            'price': float(latest['Close']),\n                            'high': float(latest['High']),\n                            'low': float(latest['Low']),\n                            'volume': int(latest['Volume']),\n                            'change_percent': ((float(latest['Close']) - float(hist.iloc[0]['Open'])) / float(hist.iloc[0]['Open'])) * 100\n                        }\n                except Exception:\n                    # Fallback to basic info\n                    market_data[symbol] = {\n                        'price': 100.0,\n                        'high': 102.0,\n                        'low': 98.0,\n                        'volume': 1000000,\n                        'change_percent': 0.5\n                    }\n        except Exception as e:\n            print(f\"Error getting market data: {e}\")\n        \n        return market_data\n    \n    def get_historical_data(self, symbol: str, timeframe: str = '1D',\n                          start_date: datetime = None, end_date: datetime = None) -> pd.DataFrame:\n        \"\"\"Get historical data using yfinance\"\"\"\n        try:\n            if not start_date:\n                start_date = datetime.now() - timedelta(days=90)\n            if not end_date:\n                end_date = datetime.now()\n            \n            ticker = yf.Ticker(symbol)\n            hist = ticker.history(start=start_date, end=end_date)\n            \n            if not hist.empty:\n                hist.reset_index(inplace=True)\n                hist.columns = ['Date', 'Open', 'High', 'Low', 'Close', 'Volume', 'Dividends', 'Stock Splits']\n                return hist[['Date', 'Open', 'High', 'Low', 'Close', 'Volume']]\n            \n        except Exception as e:\n            print(f\"Error getting historical data for {symbol}: {e}\")\n        \n        return pd.DataFrame()\n\nclass RobinhoodAPI(BrokerAPI):\n    \"\"\"Robinhood API implementation (mock for development)\"\"\"\n    \n    def __init__(self):\n        super().__init__(base_url='https://robinhood.com/api')\n        self.authenticated = False\n    \n    def authenticate(self) -> bool:\n        \"\"\"Mock authentication for Robinhood\"\"\"\n        self.authenticated = True\n        return True\n    \n    def get_account_info(self) -> Dict:\n        \"\"\"Mock account info for Robinhood\"\"\"\n        return {\n            'account_number': 'RH_MOCK_ACCOUNT',\n            'cash': 50000.0,\n            'portfolio_value': 50000.0,\n            'buying_power': 50000.0,\n            'day_trade_count': 0\n        }\n    \n    def get_positions(self) -> List[Dict]:\n        \"\"\"Mock positions for Robinhood\"\"\"\n        return []\n    \n    def place_order(self, symbol: str, side: str, quantity: int, order_type: str = 'market',\n                   price: float = None, stop_price: float = None) -> Dict:\n        \"\"\"Mock order placement for Robinhood\"\"\"\n        return {\n            'id': f'rh_mock_order_{datetime.now().timestamp()}',\n            'status': 'filled',\n            'symbol': symbol,\n            'side': side,\n            'quantity': quantity,\n            'filled_price': price or 100.0\n        }\n    \n    def get_order_status(self, order_id: str) -> Dict:\n        \"\"\"Mock order status for Robinhood\"\"\"\n        return {'id': order_id, 'status': 'filled'}\n    \n    def cancel_order(self, order_id: str) -> bool:\n        \"\"\"Mock order cancellation for Robinhood\"\"\"\n        return True\n    \n    def get_market_data(self, symbols: List[str]) -> Dict:\n        \"\"\"Mock market data for Robinhood\"\"\"\n        return {symbol: {'price': 100.0, 'change_percent': 0.5} for symbol in symbols}\n    \n    def get_historical_data(self, symbol: str, timeframe: str = '1D',\n                          start_date: datetime = None, end_date: datetime = None) -> pd.DataFrame:\n        \"\"\"Mock historical data for Robinhood\"\"\"\n        return pd.DataFrame()\n\nclass TradierAPI(BrokerAPI):\n    \"\"\"Tradier API implementation (mock for development)\"\"\"\n    \n    def __init__(self, sandbox: bool = True):\n        self.sandbox = sandbox\n        base_url = 'https://sandbox.tradier.com' if sandbox else 'https://api.tradier.com'\n        super().__init__(base_url=base_url)\n        self.authenticated = False\n    \n    def authenticate(self) -> bool:\n        \"\"\"Mock authentication for Tradier\"\"\"\n        self.authenticated = True\n        print(\"Successfully authenticated with Tradier (Mock)\")\n        return True\n    \n    def get_account_info(self) -> Dict:\n        \"\"\"Mock account info for Tradier\"\"\"\n        return {\n            'account_number': 'TRADIER_MOCK_ACCOUNT',\n            'cash': 75000.0,\n            'portfolio_value': 75000.0,\n            'buying_power': 75000.0,\n            'day_trade_count': 0\n        }\n    \n    def get_positions(self) -> List[Dict]:\n        \"\"\"Mock positions for Tradier\"\"\"\n        return []\n    \n    def place_order(self, symbol: str, side: str, quantity: int, order_type: str = 'market',\n                   price: float = None, stop_price: float = None) -> Dict:\n        \"\"\"Mock order placement for Tradier\"\"\"\n        return {\n            'id': f'tradier_mock_order_{datetime.now().timestamp()}',\n            'status': 'filled',\n            'symbol': symbol,\n            'side': side,\n            'quantity': quantity,\n            'filled_price': price or 100.0\n        }\n    \n    def get_order_status(self, order_id: str) -> Dict:\n        \"\"\"Mock order status for Tradier\"\"\"\n        return {'id': order_id, 'status': 'filled'}\n    \n    def cancel_order(self, order_id: str) -> bool:\n        \"\"\"Mock order cancellation for Tradier\"\"\"\n        return True\n    \n    def get_market_data(self, symbols: List[str]) -> Dict:\n        \"\"\"Mock market data for Tradier\"\"\"\n        return {symbol: {'price': 100.0, 'change_percent': 0.5} for symbol in symbols}\n    \n    def get_historical_data(self, symbol: str, timeframe: str = '1D',\n                          start_date: datetime = None, end_date: datetime = None) -> pd.DataFrame:\n        \"\"\"Mock historical data for Tradier\"\"\"\n        return pd.DataFrame()\n\nclass BrokerManager:\n    \"\"\"Manager class to handle multiple broker APIs with dynamic configuration\"\"\"\n    \n    def __init__(self):\n        self.brokers = {\n            'alpaca_paper': AlpacaAPI(paper_trading=True),\n            'alpaca_live': AlpacaAPI(paper_trading=False),\n            'robinhood': RobinhoodAPI(),\n            'tradier_paper': TradierAPI(sandbox=True),\n            'tradier_live': TradierAPI(sandbox=False)\n        }\n        self.active_broker = self._get_broker_from_env()\n        self._authenticate_active_broker()\n    \n    def _get_broker_from_env(self) -> str:\n        \"\"\"Get active broker from environment variables or database\"\"\"\n        from database.database import get_session\n        from database.models import EnvironmentVariable\n        \n        try:\n            session = get_session()\n            trading_mode = session.query(EnvironmentVariable)\\\n                .filter(EnvironmentVariable.key == 'TRADING_MODE').first()\n            active_broker = session.query(EnvironmentVariable)\\\n                .filter(EnvironmentVariable.key == 'ACTIVE_BROKER').first()\n            \n            mode = trading_mode.value if trading_mode else 'paper'\n            broker_base = active_broker.value if active_broker else 'alpaca'\n            \n            # Map broker names to internal broker keys\n            if broker_base == 'alpaca':\n                broker = 'alpaca_paper' if mode == 'paper' else 'alpaca_live'\n            elif broker_base == 'robinhood':\n                broker = 'robinhood'\n            elif broker_base == 'tradier':\n                broker = 'tradier_paper' if mode == 'paper' else 'tradier_live'\n            else:\n                broker = 'alpaca_paper'  # Default\n            \n            session.close()\n            return broker\n        except Exception:\n            return 'alpaca_paper'  # Default fallback\n    \n    def _authenticate_active_broker(self):\n        \"\"\"Authenticate with the currently active broker\"\"\"\n        if self.active_broker in self.brokers:\n            self.brokers[self.active_broker].authenticate()\n    \n    def get_active_broker_name(self) -> str:\n        \"\"\"Get the name of the currently active broker\"\"\"\n        return self.active_broker\n    \n    def switch_broker(self, broker_name: str) -> bool:\n        \"\"\"Switch to a different broker and authenticate\"\"\"\n        if broker_name in self.brokers:\n            self.active_broker = broker_name\n            self._authenticate_active_broker()\n            return True\n        return False\n    \n    def reload_configuration(self):\n        \"\"\"Reload broker configuration from database\"\"\"\n        self.active_broker = self._get_broker_from_env()\n        self._authenticate_active_broker()\n    \n    def set_active_broker(self, broker_name: str):\n        \"\"\"Set the active broker\"\"\"\n        if broker_name in self.brokers:\n            self.active_broker = broker_name\n            return True\n        return False\n    \n    def get_active_broker(self) -> BrokerAPI:\n        \"\"\"Get the currently active broker API\"\"\"\n        return self.brokers[self.active_broker]\n    \n    def authenticate_all(self):\n        \"\"\"Authenticate with all broker APIs\"\"\"\n        results = {}\n        for name, broker in self.brokers.items():\n            results[name] = broker.authenticate()\n        return results\n    \n    # Delegate methods to active broker\n    def get_account_info(self) -> Dict:\n        return self.get_active_broker().get_account_info()\n    \n    def get_positions(self) -> List[Dict]:\n        return self.get_active_broker().get_positions()\n    \n    def place_order(self, symbol: str, side: str, quantity: int, order_type: str = 'market',\n                   price: float = None, stop_price: float = None) -> Dict:\n        return self.get_active_broker().place_order(symbol, side, quantity, order_type, price, stop_price)\n    \n    def get_order_status(self, order_id: str) -> Dict:\n        return self.get_active_broker().get_order_status(order_id)\n    \n    def cancel_order(self, order_id: str) -> bool:\n        return self.get_active_broker().cancel_order(order_id)\n    \n    def get_market_data(self, symbols: List[str]) -> Dict:\n        return self.get_active_broker().get_market_data(symbols)\n    \n    def get_historical_data(self, symbol: str, timeframe: str = '1D',\n                          start_date: datetime = None, end_date: datetime = None) -> pd.DataFrame:\n        return self.get_active_broker().get_historical_data(symbol, timeframe, start_date, end_date)\n","size_bytes":18655},"app_pages/trading.py":{"content":"import streamlit as st\nimport pandas as pd\nimport plotly.graph_objects as go\nfrom datetime import datetime, timedelta\n\nfrom database.database import get_session\nfrom database.models import Stock, Order, TransactionLog, PriorityCurrentPrice\nfrom services.technical_indicators import TechnicalIndicators\nfrom services.broker_apis import BrokerManager\nfrom utils.helpers import format_currency, format_percentage\nfrom utils.broker_status_widget import display_mini_broker_status\n\ndef show_trading_page():\n    st.title(\"ðŸ’¹ Advanced Trading\")\n    \n    # Check user permissions - only traders and admins can access trading\n    from utils.auth import check_permission\n    if not check_permission(st.session_state.user, 'trader'):\n        st.error(\"ðŸš« Access denied. Trading privileges required.\")\n        st.info(\"Viewers can only access Dashboard, Portfolio (read-only), and AI Assistant.\")\n        return\n    \n    # Initialize broker manager with centralized configuration\n    if 'broker_manager' not in st.session_state:\n        st.session_state.broker_manager = BrokerManager()\n    \n    broker_manager = st.session_state.broker_manager\n    \n    # Mini broker status widget\n    is_connected = display_mini_broker_status()\n    \n    if not is_connected:\n        st.error(\"âŒ Broker connection failed. Please check Settings > Broker Configuration.\")\n        return\n    \n    # Get active broker name for trading mode display\n    active_broker = broker_manager.get_active_broker_name()\n    \n    # Trading controls\n    col1, col2, col3 = st.columns([1, 1, 1])\n    \n    with col1:\n        # Show current trading mode from broker configuration\n        current_mode = \"Paper Trading\" if \"paper\" in active_broker else \"Live Trading\"\n        trading_mode = st.selectbox(\"Mode\", [current_mode], disabled=True)\n    \n    with col2:\n        auto_trading = st.toggle(\"Auto Trading\", value=False)\n    \n    with col3:\n        risk_level = st.selectbox(\"Risk Level\", [\"Conservative\", \"Moderate\", \"Aggressive\"])\n    \n    # Account information\n    account_info = broker_manager.get_account_info()\n    if 'error' not in account_info:\n        col1, col2, col3, col4 = st.columns(4)\n        with col1:\n            st.metric(\"Cash\", f\"${account_info.get('cash', 0):,.2f}\")\n        with col2:\n            st.metric(\"Portfolio Value\", f\"${account_info.get('portfolio_value', 0):,.2f}\")\n        with col3:\n            st.metric(\"Buying Power\", f\"${account_info.get('buying_power', 0):,.2f}\")\n        with col4:\n            st.metric(\"Day Trades\", account_info.get('day_trade_count', 0))\n    \n    # Live market data section\n    st.subheader(\"ðŸ“Š Live Market Data\")\n    \n    symbols = ['AAPL', 'GOOGL', 'MSFT', 'TSLA', 'AMZN', 'META', 'NVDA']\n    market_data = broker_manager.get_market_data(symbols)\n    \n    if market_data:\n        cols = st.columns(len(symbols))\n        for i, (symbol, data) in enumerate(market_data.items()):\n            with cols[i]:\n                price = data.get('price', 0)\n                change_pct = data.get('change_percent', 0)\n                delta_color = \"normal\" if change_pct >= 0 else \"inverse\"\n                st.metric(\n                    symbol,\n                    f\"${price:.2f}\",\n                    f\"{change_pct:+.2f}%\",\n                    delta_color=delta_color\n                )\n    \n    # Quick trading interface\n    st.subheader(\"ðŸŽ¯ Quick Trade\")\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.write(\"**Place Order**\")\n        \n        trade_symbol = st.selectbox(\"Symbol\", symbols, key=\"trade_symbol\")\n        trade_side = st.selectbox(\"Action\", [\"buy\", \"sell\"], key=\"trade_side\")\n        trade_quantity = st.number_input(\"Quantity\", min_value=1, value=1, key=\"trade_quantity\")\n        trade_type = st.selectbox(\"Order Type\", [\"market\", \"limit\"], key=\"trade_type\")\n        \n        limit_price = None\n        if trade_type == \"limit\":\n            current_price = market_data.get(trade_symbol, {}).get('price', 100)\n            limit_price = st.number_input(\n                \"Limit Price\", \n                min_value=0.01, \n                value=float(current_price),\n                key=\"limit_price\"\n            )\n        \n        if st.button(\"Place Order\", type=\"primary\"):\n            order_result = broker_manager.place_order(\n                symbol=trade_symbol,\n                side=trade_side,\n                quantity=trade_quantity,\n                order_type=trade_type,\n                price=limit_price\n            )\n            \n            if 'error' not in order_result:\n                st.success(f\"âœ… Order placed: {trade_side.upper()} {trade_quantity} {trade_symbol}\")\n                st.json(order_result)\n                \n                # Log to database\n                _log_order(trade_symbol, trade_side, trade_quantity, trade_type)\n            else:\n                st.error(f\"âŒ Order failed: {order_result.get('error', 'Unknown error')}\")\n    \n    with col2:\n        st.write(\"**Current Positions**\")\n        \n        positions = broker_manager.get_positions()\n        if positions:\n            positions_df = pd.DataFrame(positions)\n            st.dataframe(positions_df, use_container_width=True)\n        else:\n            st.info(\"No current positions\")\n    \n    # Real-time monitoring\n    st.subheader(\"ðŸ“ˆ Real-Time Monitoring\")\n    \n    # Get priority stocks\n    session = get_session()\n    try:\n        priority_stocks = session.query(Stock).filter(Stock.priority > 0).all()\n        \n        if priority_stocks:\n            # Stock selector\n            selected_stock = st.selectbox(\n                \"Select Stock for Analysis\",\n                options=priority_stocks,\n                format_func=lambda x: f\"{x.symbol} - {x.name}\"\n            )\n            \n            if selected_stock:\n                _show_stock_analysis(selected_stock, session)\n        else:\n            st.warning(\"No priority stocks available for trading\")\n    \n    finally:\n        session.close()\n    \n    # Trading strategies\n    st.subheader(\"ðŸŽ¯ Active Strategies\")\n    _show_active_strategies()\n    \n    # Options trading\n    st.subheader(\"ðŸ“‹ Options Trading\")\n    _show_options_interface()\n\ndef _show_stock_analysis(stock: Stock, session):\n    \"\"\"Show detailed analysis for selected stock\"\"\"\n    col1, col2 = st.columns([2, 1])\n    \n    with col1:\n        # Price chart with technical indicators\n        _show_price_chart(stock, session)\n    \n    with col2:\n        # Stock metrics\n        st.metric(\"Current Price\", f\"${stock.last_price:.2f}\", f\"{stock.change_percent:.2f}%\")\n        \n        # Technical indicators\n        st.subheader(\"Technical Indicators\")\n        \n        # Get recent price data for indicators\n        recent_prices = session.query(PriorityCurrentPrice)\\\n            .filter(PriorityCurrentPrice.stock_id == stock.id)\\\n            .order_by(PriorityCurrentPrice.datetime.desc())\\\n            .limit(50).all()\n        \n        if recent_prices:\n            prices = [p.current_price for p in reversed(recent_prices)]\n            \n            # Calculate simple indicators\n            if len(prices) >= 20:\n                sma_20 = sum(prices[-20:]) / 20\n                current_price = prices[-1]\n                \n                st.metric(\"20-Day SMA\", f\"${sma_20:.2f}\")\n                st.metric(\"Price vs SMA\", f\"{((current_price - sma_20) / sma_20 * 100):.2f}%\")\n        \n        # Trading signals\n        st.subheader(\"Trading Signals\")\n        _show_trading_signals(stock, session)\n\ndef _show_price_chart(stock: Stock, session):\n    \"\"\"Show price chart with technical analysis\"\"\"\n    # Get historical price data\n    recent_prices = session.query(PriorityCurrentPrice)\\\n        .filter(PriorityCurrentPrice.stock_id == stock.id)\\\n        .order_by(PriorityCurrentPrice.datetime.desc())\\\n        .limit(100).all()\n    \n    if not recent_prices:\n        st.info(\"No price data available\")\n        return\n    \n    # Convert to DataFrame\n    df = pd.DataFrame([{\n        'time': p.datetime,\n        'price': p.current_price,\n        'volume': p.volume or 0\n    } for p in reversed(recent_prices)])\n    \n    # Create candlestick chart (simplified to line chart for demo)\n    fig = go.Figure()\n    \n    # Add price line\n    fig.add_trace(go.Scatter(\n        x=df['time'],\n        y=df['price'],\n        mode='lines',\n        name='Price',\n        line=dict(color='blue', width=2)\n    ))\n    \n    # Add volume bars\n    fig.add_trace(go.Bar(\n        x=df['time'],\n        y=df['volume'],\n        name='Volume',\n        yaxis='y2',\n        opacity=0.3\n    ))\n    \n    # Update layout\n    fig.update_layout(\n        title=f\"{stock.symbol} Price Chart\",\n        xaxis_title=\"Time\",\n        yaxis_title=\"Price ($)\",\n        yaxis2=dict(\n            title=\"Volume\",\n            overlaying='y',\n            side='right'\n        ),\n        height=400\n    )\n    \n    st.plotly_chart(fig, use_container_width=True)\n\ndef _show_trading_signals(stock: Stock, session):\n    \"\"\"Show trading signals and recommendations\"\"\"\n    # Get recent technical data\n    recent_prices = session.query(PriorityCurrentPrice)\\\n        .filter(PriorityCurrentPrice.stock_id == stock.id)\\\n        .order_by(PriorityCurrentPrice.datetime.desc())\\\n        .limit(20).all()\n    \n    if len(recent_prices) < 5:\n        st.info(\"Insufficient data for signals\")\n        return\n    \n    prices = [p.current_price for p in reversed(recent_prices)]\n    \n    # Determine momentum\n    momentum = TechnicalIndicators.detect_price_momentum(prices, 3)\n    \n    # Signal strength\n    signal_strength = \"Strong\" if abs(prices[-1] - prices[-5]) / prices[-5] > 0.02 else \"Weak\"\n    \n    # Display signals\n    if momentum == 'up':\n        st.success(f\"ðŸŸ¢ **BUY Signal** ({signal_strength})\")\n        st.write(\"Price showing upward momentum\")\n        \n        if stock.has_options:\n            st.info(\"ðŸ’¡ Consider call options for leveraged exposure\")\n    \n    elif momentum == 'down':\n        st.error(f\"ðŸ”´ **SELL Signal** ({signal_strength})\")\n        st.write(\"Price showing downward momentum\")\n        \n        if stock.has_options:\n            st.info(\"ðŸ’¡ Consider put options or protective strategies\")\n    \n    else:\n        st.warning(\"ðŸŸ¡ **HOLD Signal**\")\n        st.write(\"Price showing sideways movement\")\n    \n    # Risk assessment\n    volatility = _calculate_volatility(prices)\n    if volatility > 0.05:\n        st.warning(\"âš ï¸ High volatility detected\")\n    elif volatility < 0.01:\n        st.info(\"â„¹ï¸ Low volatility - consider volatility strategies\")\n\ndef _calculate_volatility(prices):\n    \"\"\"Calculate simple volatility measure\"\"\"\n    if len(prices) < 2:\n        return 0\n    \n    returns = [(prices[i] - prices[i-1]) / prices[i-1] for i in range(1, len(prices))]\n    return sum(abs(r) for r in returns) / len(returns)\n\ndef _show_active_strategies():\n    \"\"\"Show active trading strategies\"\"\"\n    strategies = [\n        {\n            \"Strategy\": \"Momentum Following\",\n            \"Status\": \"Active\",\n            \"Stocks\": 5,\n            \"P&L\": \"+$1,250\",\n            \"Success Rate\": \"68%\"\n        },\n        {\n            \"Strategy\": \"Mean Reversion\",\n            \"Status\": \"Paused\",\n            \"Stocks\": 0,\n            \"P&L\": \"+$850\",\n            \"Success Rate\": \"72%\"\n        },\n        {\n            \"Strategy\": \"Options Arbitrage\",\n            \"Status\": \"Active\",\n            \"Stocks\": 3,\n            \"P&L\": \"+$420\",\n            \"Success Rate\": \"85%\"\n        }\n    ]\n    \n    df = pd.DataFrame(strategies)\n    \n    # Color code status\n    def color_status(val):\n        if val == 'Active':\n            return 'background-color: lightgreen'\n        elif val == 'Paused':\n            return 'background-color: lightyellow'\n        else:\n            return ''\n    \n    styled_df = df.style.map(color_status, subset=['Status'])\n    st.dataframe(styled_df, use_container_width=True)\n\ndef _show_options_interface():\n    \"\"\"Show options trading interface\"\"\"\n    session = get_session()\n    \n    try:\n        # Get stocks with options\n        options_stocks = session.query(Stock).filter(Stock.has_options == True).all()\n        \n        if not options_stocks:\n            st.info(\"No stocks with options available\")\n            return\n        \n        col1, col2, col3 = st.columns([2, 1, 1])\n        \n        with col1:\n            selected_stock = st.selectbox(\n                \"Stock for Options\",\n                options=options_stocks,\n                format_func=lambda x: f\"{x.symbol} - ${x.last_price:.2f}\" if x.last_price is not None else f\"{x.symbol} - No Price\"\n            )\n        \n        with col2:\n            option_type = st.selectbox(\"Option Type\", [\"Call\", \"Put\"])\n        \n        with col3:\n            expiry_days = st.selectbox(\"Days to Expiry\", [7, 14, 21, 30, 45, 60])\n        \n        if selected_stock:\n            # Options chain (simplified)\n            current_price = selected_stock.last_price or 100.0\n            \n            # Generate strike prices around current price\n            strikes = []\n            for i in range(-5, 6):\n                strike = round(current_price + (i * 5), 2)\n                moneyness = \"ITM\" if (option_type == \"Call\" and strike < current_price) or \\\n                                   (option_type == \"Put\" and strike > current_price) else \"OTM\"\n                \n                # Simplified option pricing\n                intrinsic = max(0, current_price - strike) if option_type == \"Call\" else max(0, strike - current_price)\n                time_value = 2.5 * (expiry_days / 30)  # Simplified\n                option_price = float(intrinsic) + time_value\n                \n                strikes.append({\n                    \"Strike\": f\"${strike:.2f}\",\n                    \"Type\": moneyness,\n                    \"Bid\": f\"${option_price * 0.95:.2f}\",\n                    \"Ask\": f\"${option_price * 1.05:.2f}\",\n                    \"Volume\": f\"{1000 + i*100:,}\",\n                    \"Open Interest\": f\"{5000 + i*500:,}\"\n                })\n            \n            st.subheader(f\"{option_type} Options Chain - {selected_stock.symbol}\")\n            options_df = pd.DataFrame(strikes)\n            st.dataframe(options_df, use_container_width=True)\n            \n            # Quick trade buttons\n            col1, col2, col3, col4 = st.columns(4)\n            \n            with col1:\n                if st.button(\"Buy ATM Call\"):\n                    st.success(f\"Placed order: Buy ATM Call {selected_stock.symbol}\")\n            \n            with col2:\n                if st.button(\"Buy ATM Put\"):\n                    st.success(f\"Placed order: Buy ATM Put {selected_stock.symbol}\")\n            \n            with col3:\n                if st.button(\"Sell Covered Call\"):\n                    st.success(f\"Placed order: Sell Covered Call {selected_stock.symbol}\")\n            \n            with col4:\n                if st.button(\"Buy Protective Put\"):\n                    st.success(f\"Placed order: Buy Protective Put {selected_stock.symbol}\")\n    \n    finally:\n        session.close()\n","size_bytes":15017},"utils/broker_status_widget.py":{"content":"import streamlit as st\nimport time\nfrom datetime import datetime\nfrom services.broker_apis import BrokerManager\n\ndef display_animated_broker_status():\n    \"\"\"Display animated broker connection status widget\"\"\"\n    \n    # Initialize broker manager\n    if 'broker_manager' not in st.session_state:\n        st.session_state.broker_manager = BrokerManager()\n    \n    broker_manager = st.session_state.broker_manager\n    \n    # Get broker info\n    active_broker = broker_manager.get_active_broker_name()\n    \n    # Create container for the widget\n    status_container = st.container()\n    \n    with status_container:\n        # CSS for animations and styling\n        st.markdown(\"\"\"\n        <style>\n        .broker-status-widget {\n            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n            border-radius: 15px;\n            padding: 20px;\n            margin: 10px 0;\n            color: white;\n            box-shadow: 0 8px 32px rgba(0,0,0,0.1);\n            position: relative;\n            overflow: hidden;\n        }\n        \n        .broker-status-widget::before {\n            content: '';\n            position: absolute;\n            top: 0;\n            left: -100%;\n            width: 100%;\n            height: 100%;\n            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);\n            animation: shimmer 2s infinite;\n        }\n        \n        @keyframes shimmer {\n            0% { left: -100%; }\n            100% { left: 100%; }\n        }\n        \n        .connection-indicator {\n            display: inline-block;\n            width: 12px;\n            height: 12px;\n            border-radius: 50%;\n            margin-right: 8px;\n            animation: pulse 2s infinite;\n        }\n        \n        .connected {\n            background-color: #4CAF50;\n            box-shadow: 0 0 10px #4CAF50;\n        }\n        \n        .connecting {\n            background-color: #FF9800;\n            box-shadow: 0 0 10px #FF9800;\n        }\n        \n        .disconnected {\n            background-color: #F44336;\n            box-shadow: 0 0 10px #F44336;\n        }\n        \n        @keyframes pulse {\n            0% { opacity: 1; transform: scale(1); }\n            50% { opacity: 0.6; transform: scale(1.2); }\n            100% { opacity: 1; transform: scale(1); }\n        }\n        \n        .broker-name {\n            font-size: 18px;\n            font-weight: bold;\n            margin-bottom: 5px;\n        }\n        \n        .broker-details {\n            font-size: 14px;\n            opacity: 0.9;\n        }\n        \n        .status-metrics {\n            display: flex;\n            justify-content: space-between;\n            margin-top: 15px;\n            flex-wrap: wrap;\n        }\n        \n        .metric-item {\n            text-align: center;\n            flex: 1;\n            min-width: 100px;\n        }\n        \n        .metric-value {\n            font-size: 16px;\n            font-weight: bold;\n            color: #FFD700;\n        }\n        \n        .metric-label {\n            font-size: 12px;\n            opacity: 0.8;\n        }\n        \n        .refresh-button {\n            background: rgba(255,255,255,0.2);\n            border: 1px solid rgba(255,255,255,0.3);\n            border-radius: 20px;\n            color: white;\n            padding: 8px 16px;\n            font-size: 12px;\n            cursor: pointer;\n            transition: all 0.3s ease;\n            float: right;\n            margin-top: -10px;\n        }\n        \n        .refresh-button:hover {\n            background: rgba(255,255,255,0.3);\n            transform: scale(1.05);\n        }\n        \n        .last-updated {\n            font-size: 10px;\n            opacity: 0.7;\n            margin-top: 10px;\n            text-align: right;\n        }\n        \n        .live-indicator {\n            display: inline-block;\n            background: #FF6B6B;\n            color: white;\n            padding: 2px 6px;\n            border-radius: 10px;\n            font-size: 10px;\n            font-weight: bold;\n            margin-left: 10px;\n            animation: livePulse 1.5s infinite;\n        }\n        \n        @keyframes livePulse {\n            0% { opacity: 1; transform: scale(1); }\n            50% { opacity: 0.7; transform: scale(1.1); }\n            100% { opacity: 1; transform: scale(1); }\n        }\n        \n        .auto-refresh-badge {\n            position: absolute;\n            top: 15px;\n            right: 15px;\n            background: rgba(255,255,255,0.2);\n            padding: 4px 8px;\n            border-radius: 12px;\n            font-size: 10px;\n            font-weight: bold;\n        }\n        </style>\n        \"\"\", unsafe_allow_html=True)\n        \n        # Test connection\n        try:\n            account_info = broker_manager.get_account_info()\n            is_connected = 'error' not in account_info\n            \n            if is_connected:\n                status_class = \"connected\"\n                status_text = \"Connected\"\n                status_icon = \"ðŸŸ¢\"\n            else:\n                status_class = \"disconnected\"\n                status_text = \"Disconnected\"\n                status_icon = \"ðŸ”´\"\n                \n        except Exception:\n            status_class = \"disconnected\"\n            status_text = \"Connection Error\"\n            status_icon = \"ðŸ”´\"\n            account_info = {}\n            is_connected = False\n        \n        # Format broker name for display\n        broker_display_names = {\n            'alpaca_paper': 'Alpaca Paper Trading',\n            'alpaca_live': 'Alpaca Live Trading',\n            'tradier_paper': 'Tradier Sandbox',\n            'tradier_live': 'Tradier Live',\n            'robinhood': 'Robinhood'\n        }\n        \n        broker_display = broker_display_names.get(active_broker, active_broker.title())\n        \n        # Create the widget HTML\n        widget_html = f\"\"\"\n        <div class=\"broker-status-widget\">\n            <div class=\"auto-refresh-badge\">LIVE</div>\n            <div class=\"broker-name\">\n                <span class=\"connection-indicator {status_class}\"></span>\n                {status_icon} {broker_display}\n                <span class=\"live-indicator\">LIVE</span>\n            </div>\n            <div class=\"broker-details\">\n                Status: {status_text} | Mode: {'Paper' if 'paper' in active_broker else 'Live'} Trading\n            </div>\n        \"\"\"\n        \n        if is_connected:\n            portfolio_value = account_info.get('portfolio_value', 0)\n            cash = account_info.get('cash', 0)\n            buying_power = account_info.get('buying_power', 0)\n            day_trades = account_info.get('day_trade_count', 0)\n            \n            widget_html += f\"\"\"\n            <div class=\"status-metrics\">\n                <div class=\"metric-item\">\n                    <div class=\"metric-value\">${portfolio_value:,.0f}</div>\n                    <div class=\"metric-label\">Portfolio</div>\n                </div>\n                <div class=\"metric-item\">\n                    <div class=\"metric-value\">${cash:,.0f}</div>\n                    <div class=\"metric-label\">Cash</div>\n                </div>\n                <div class=\"metric-item\">\n                    <div class=\"metric-value\">${buying_power:,.0f}</div>\n                    <div class=\"metric-label\">Buying Power</div>\n                </div>\n                <div class=\"metric-item\">\n                    <div class=\"metric-value\">{day_trades}/3</div>\n                    <div class=\"metric-label\">Day Trades</div>\n                </div>\n            </div>\n            \"\"\"\n        \n        current_time = datetime.now().strftime(\"%H:%M:%S\")\n        widget_html += f\"\"\"\n            <div class=\"last-updated\">Last updated: {current_time}</div>\n        </div>\n        \"\"\"\n        \n        # Display the widget\n        st.markdown(widget_html, unsafe_allow_html=True)\n        \n        # Refresh button\n        col1, col2, col3 = st.columns([1, 1, 1])\n        with col2:\n            if st.button(\"ðŸ”„ Refresh Status\", key=\"refresh_broker_status\"):\n                # Force refresh broker manager\n                if 'broker_manager' in st.session_state:\n                    st.session_state.broker_manager.reload_configuration()\n                st.rerun()\n        \n        return is_connected, account_info\n\ndef display_mini_broker_status():\n    \"\"\"Display a compact version of the broker status widget\"\"\"\n    \n    if 'broker_manager' not in st.session_state:\n        st.session_state.broker_manager = BrokerManager()\n    \n    broker_manager = st.session_state.broker_manager\n    active_broker = broker_manager.get_active_broker_name()\n    \n    try:\n        account_info = broker_manager.get_account_info()\n        is_connected = 'error' not in account_info\n        status_icon = \"ðŸŸ¢\" if is_connected else \"ðŸ”´\"\n        status_text = \"Connected\" if is_connected else \"Disconnected\"\n    except Exception:\n        status_icon = \"ðŸ”´\"\n        status_text = \"Error\"\n        is_connected = False\n    \n    # Compact status display\n    broker_display_names = {\n        'alpaca_paper': 'Alpaca Paper',\n        'alpaca_live': 'Alpaca Live',\n        'tradier_paper': 'Tradier Sandbox',\n        'tradier_live': 'Tradier Live',\n        'robinhood': 'Robinhood'\n    }\n    \n    broker_display = broker_display_names.get(active_broker, active_broker)\n    \n    st.markdown(f\"\"\"\n    <div style=\"\n        background: linear-gradient(45deg, #667eea, #764ba2);\n        border-radius: 10px;\n        padding: 10px;\n        color: white;\n        text-align: center;\n        margin: 5px 0;\n        font-size: 14px;\n        box-shadow: 0 4px 16px rgba(0,0,0,0.1);\n    \">\n        {status_icon} {broker_display} - {status_text}\n    </div>\n    \"\"\", unsafe_allow_html=True)\n    \n    return is_connected\n\ndef display_connection_health_chart():\n    \"\"\"Display a connection health monitoring chart\"\"\"\n    \n    # Store connection history in session state\n    if 'connection_history' not in st.session_state:\n        st.session_state.connection_history = []\n    \n    if 'broker_manager' not in st.session_state:\n        st.session_state.broker_manager = BrokerManager()\n    \n    broker_manager = st.session_state.broker_manager\n    \n    # Test connection\n    try:\n        account_info = broker_manager.get_account_info()\n        is_connected = 'error' not in account_info\n        response_time = 0.1  # Mock response time\n    except Exception:\n        is_connected = False\n        response_time = None\n    \n    # Add to history\n    current_time = datetime.now()\n    st.session_state.connection_history.append({\n        'timestamp': current_time,\n        'connected': is_connected,\n        'response_time': response_time\n    })\n    \n    # Keep only last 20 data points\n    if len(st.session_state.connection_history) > 20:\n        st.session_state.connection_history = st.session_state.connection_history[-20:]\n    \n    # Create chart if we have data\n    if len(st.session_state.connection_history) >= 2:\n        import plotly.graph_objects as go\n        \n        timestamps = [h['timestamp'] for h in st.session_state.connection_history]\n        connected_status = [1 if h['connected'] else 0 for h in st.session_state.connection_history]\n        \n        fig = go.Figure()\n        fig.add_trace(go.Scatter(\n            x=timestamps,\n            y=connected_status,\n            mode='lines+markers',\n            name='Connection Status',\n            line=dict(color='green', width=3),\n            fill='tozeroy',\n            fillcolor='rgba(0, 255, 0, 0.2)'\n        ))\n        \n        fig.update_layout(\n            title=\"Broker Connection Health\",\n            xaxis_title=\"Time\",\n            yaxis_title=\"Status\",\n            yaxis=dict(tickmode='array', tickvals=[0, 1], ticktext=['Disconnected', 'Connected']),\n            height=200,\n            margin=dict(l=0, r=0, t=30, b=0),\n            showlegend=False\n        )\n        \n        st.plotly_chart(fig, use_container_width=True)","size_bytes":11938}},"version":2}